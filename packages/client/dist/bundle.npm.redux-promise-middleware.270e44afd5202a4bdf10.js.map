{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/redux-promise-middleware/dist/es/isPromise.js","webpack:////var/www/html/utter/node_modules/redux-promise-middleware/dist/es/index.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","isPromise","value","then","__webpack_require__","d","__webpack_exports__","promiseMiddleware","es_typeof","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","_slicedToArray","arr","Array","isArray","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","err","sliceIterator","TypeError","defaultTypes","config","promiseTypeSuffixes","promiseTypeSeparator","ref","dispatch","action","payload","promise","type","meta","_promiseTypeSuffixes","_PENDING","_FULFILLED","_REJECTED","getAction","newPayload","isRejected","join","error","data","resolvedAction","reason","rejectedAction"],"mappings":"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","file":"bundle.npm.redux-promise-middleware.270e44afd5202a4bdf10.js","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexport default function isPromise(value) {\n  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n    return value && typeof value.then === 'function';\n  }\n\n  return false;\n}","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nimport isPromise from './isPromise.js';\n\nexport var PENDING = 'PENDING';\nexport var FULFILLED = 'FULFILLED';\nexport var REJECTED = 'REJECTED';\n\nvar defaultTypes = [PENDING, FULFILLED, REJECTED];\n\n/**\n * @function promiseMiddleware\n * @description\n * @returns {function} thunk\n */\nexport default function promiseMiddleware() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var promiseTypeSuffixes = config.promiseTypeSuffixes || defaultTypes;\n  var promiseTypeSeparator = config.promiseTypeSeparator || '_';\n\n  return function (ref) {\n    var dispatch = ref.dispatch;\n\n\n    return function (next) {\n      return function (action) {\n        if (action.payload) {\n          if (!isPromise(action.payload) && !isPromise(action.payload.promise)) {\n            return next(action);\n          }\n        } else {\n          return next(action);\n        }\n\n        // Deconstruct the properties of the original action object to constants\n        var type = action.type,\n            payload = action.payload,\n            meta = action.meta;\n\n        // Assign values for promise type suffixes\n\n        var _promiseTypeSuffixes = _slicedToArray(promiseTypeSuffixes, 3),\n            _PENDING = _promiseTypeSuffixes[0],\n            _FULFILLED = _promiseTypeSuffixes[1],\n            _REJECTED = _promiseTypeSuffixes[2];\n\n        /**\n         * @function getAction\n         * @description Utility function for creating a rejected or fulfilled\n         * flux standard action object.\n         * @param {boolean} Is the action rejected?\n         * @returns {object} action\n         */\n\n\n        var getAction = function getAction(newPayload, isRejected) {\n          return _extends({\n            type: [type, isRejected ? _REJECTED : _FULFILLED].join(promiseTypeSeparator)\n          }, newPayload === null || typeof newPayload === 'undefined' ? {} : {\n            payload: newPayload\n          }, meta !== undefined ? { meta: meta } : {}, isRejected ? {\n            error: true\n          } : {});\n        };\n\n        /**\n         * Assign values for promise and data variables. In the case the payload\n         * is an object with a `promise` and `data` property, the values of those\n         * properties will be used. In the case the payload is a promise, the\n         * value of the payload will be used and data will be null.\n         */\n        var promise = void 0;\n        var data = void 0;\n\n        if (!isPromise(action.payload) && _typeof(action.payload) === 'object') {\n          promise = payload.promise;\n          data = payload.data;\n        } else {\n          promise = payload;\n          data = undefined;\n        }\n\n        /**\n         * First, dispatch the pending action. This flux standard action object\n         * describes the pending state of a promise and will include any data\n         * (for optimistic updates) and/or meta from the original action.\n         */\n        next(_extends({\n          type: [type, _PENDING].join(promiseTypeSeparator)\n        }, data !== undefined ? { payload: data } : {}, meta !== undefined ? { meta: meta } : {}));\n\n        /*\n         * @function handleReject\n         * @description Dispatch the rejected action and return\n         * an error object. The error object is the original error\n         * that was thrown. The user of the library is responsible for\n         * best practices in ensure that they are throwing an Error object.\n         * @params reason The reason the promise was rejected\n         * @returns {object}\n         */\n        var handleReject = function handleReject(reason) {\n          var rejectedAction = getAction(reason, true);\n          dispatch(rejectedAction);\n\n          throw reason;\n        };\n\n        /*\n         * @function handleFulfill\n         * @description Dispatch the fulfilled action and\n         * return the success object. The success object should\n         * contain the value and the dispatched action.\n         * @param value The value the promise was resloved with\n         * @returns {object}\n         */\n        var handleFulfill = function handleFulfill() {\n          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n          var resolvedAction = getAction(value, false);\n          dispatch(resolvedAction);\n\n          return { value: value, action: resolvedAction };\n        };\n\n        /**\n         * Second, dispatch a rejected or fulfilled action. This flux standard\n         * action object will describe the resolved state of the promise. In\n         * the case of a rejected promise, it will include an `error` property.\n         *\n         * In order to allow proper chaining of actions using `then`, a new\n         * promise is constructed and returned. This promise will resolve\n         * with two properties: (1) the value (if fulfilled) or reason\n         * (if rejected) and (2) the flux standard action.\n         *\n         * Rejected object:\n         * {\n         *   reason: ...\n         *   action: {\n         *     error: true,\n         *     type: 'ACTION_REJECTED',\n         *     payload: ...\n         *   }\n         * }\n         *\n         * Fulfilled object:\n         * {\n         *   value: ...\n         *   action: {\n         *     type: 'ACTION_FULFILLED',\n         *     payload: ...\n         *   }\n         * }\n         */\n        return promise.then(handleFulfill, handleReject);\n      };\n    };\n  };\n}"],"sourceRoot":""}