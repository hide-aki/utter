{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/optimism/lib/entry.js","webpack:////var/www/html/utter/node_modules/optimism/lib/cache.js","webpack:////var/www/html/utter/node_modules/optimism/lib/index.js","webpack:////var/www/html/utter/node_modules/optimism/lib/local.js"],"names":["getLocal","__webpack_require__","get","UNKNOWN_VALUE","Object","create","emptySetPool","entryPool","assert","condition","optionalMessage","Error","Entry","fn","key","args","this","parents","Set","childValues","Map","dirtyChildren","reset","count","entry","value","dirty","subscribe","unsubscribe","recomputing","reportOrphan","exports","POOL_TARGET_SIZE","acquire","pop","Ep","prototype","maybeReportOrphan","report","size","reportDirty","forEach","parent","reportDirtyChild","reportClean","reportCleanChild","mightBeDirty","child","has","add","cv","childValue","set","setDirty","removeDirtyChild","dc","delete","length","push","reallyRecompute","originalChildren","forgetChildren","local","currentParentEntry","threw","apply","e","setClean","recompute","rememberParent","recomputeIfDirty","dispose","forgetChild","release","reusableEmptyArray","children","unsub","Cache","options","map","newest","oldest","max","Cp","getEntry","cache","older","newer","clean","tuple","defaultMakeCacheKey","wrap","disposable","makeCacheKey","Math","pow","normalizeOptions","optimistic","arguments","len","module","fakeNullFiber","getCurrentFiber","Fiber","split","reverse","join","current","fiber"],"mappings":"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","file":"bundle.npm.optimism.9b460f42fdf8c2e34c40.js","sourcesContent":["\"use strict\";\n\nvar getLocal = require(\"./local.js\").get;\nvar UNKNOWN_VALUE = Object.create(null);\nvar emptySetPool = [];\nvar entryPool = [];\n\n// Don't let the emptySetPool or entryPool grow larger than this size,\n// since unconstrained pool growth could lead to memory leaks.\nexports.POOL_TARGET_SIZE = 100;\n\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n  if (! condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\nfunction Entry(fn, key, args) {\n  this.parents = new Set;\n  this.childValues = new Map;\n\n  // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n  this.dirtyChildren = null;\n\n  reset(this, fn, key, args);\n\n  ++Entry.count;\n}\n\nEntry.count = 0;\n\nfunction reset(entry, fn, key, args) {\n  entry.fn = fn;\n  entry.key = key;\n  entry.args = args;\n  entry.value = UNKNOWN_VALUE;\n  entry.dirty = true;\n  entry.subscribe = null;\n  entry.unsubscribe = null;\n  entry.recomputing = false;\n  // Optional callback that will be invoked when entry.parents becomes\n  // empty. The Entry object is given as the first parameter. If the\n  // callback returns true, then this entry can be removed from the graph\n  // and safely recycled into the entryPool.\n  entry.reportOrphan = null;\n}\n\nEntry.acquire = function (fn, key, args) {\n  var entry = entryPool.pop();\n  if (entry) {\n    reset(entry, fn, key, args);\n    return entry;\n  }\n  return new Entry(fn, key, args);\n};\n\nfunction release(entry) {\n  assert(entry.parents.size === 0);\n  assert(entry.childValues.size === 0);\n  assert(entry.dirtyChildren === null);\n  if (entryPool.length < exports.POOL_TARGET_SIZE) {\n    entryPool.push(entry);\n  }\n}\n\nexports.Entry = Entry;\n\nvar Ep = Entry.prototype;\n\n// The public API of Entry objects consists of the Entry constructor,\n// along with the recompute, setDirty, and dispose methods.\n\nEp.recompute = function recompute() {\n  if (! rememberParent(this) &&\n      maybeReportOrphan(this)) {\n    // The recipient of the entry.reportOrphan callback decided to dispose\n    // of this orphan entry by calling entry.dispos(), which recycles it\n    // into the entryPool, so we don't need to (and should not) proceed\n    // with the recomputation.\n    return;\n  }\n\n  return recomputeIfDirty(this);\n};\n\n// If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\nfunction maybeReportOrphan(entry) {\n  var report = entry.reportOrphan;\n  return typeof report === \"function\" &&\n    entry.parents.size === 0 &&\n    report(entry) === true;\n}\n\nEp.setDirty = function setDirty() {\n  if (this.dirty) return;\n  this.dirty = true;\n  this.value = UNKNOWN_VALUE;\n  reportDirty(this);\n  // We can go ahead and unsubscribe here, since any further dirty\n  // notifications we receive will be redundant, and unsubscribing may\n  // free up some resources, e.g. file watchers.\n  unsubscribe(this);\n};\n\nEp.dispose = function dispose() {\n  var entry = this;\n  forgetChildren(entry).forEach(maybeReportOrphan);\n  unsubscribe(entry);\n\n  // Because this entry has been kicked out of the cache (in index.js),\n  // we've lost the ability to find out if/when this entry becomes dirty,\n  // whether that happens through a subscription, because of a direct call\n  // to entry.setDirty(), or because one of its children becomes dirty.\n  // Because of this loss of future information, we have to assume the\n  // worst (that this entry might have become dirty very soon), so we must\n  // immediately mark this entry's parents as dirty. Normally we could\n  // just call entry.setDirty() rather than calling parent.setDirty() for\n  // each parent, but that would leave this entry in parent.childValues\n  // and parent.dirtyChildren, which would prevent the child from being\n  // truly forgotten.\n  entry.parents.forEach(function (parent) {\n    parent.setDirty();\n    forgetChild(parent, entry);\n  });\n\n  // Since this entry has no parents and no children anymore, and the\n  // caller of Entry#dispose has indicated that entry.value no longer\n  // matters, we can safely recycle this Entry object for later use.\n  release(entry);\n};\n\nfunction setClean(entry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(entry) {\n  entry.parents.forEach(function (parent) {\n    reportDirtyChild(parent, entry);\n  });\n}\n\nfunction reportClean(entry) {\n  entry.parents.forEach(function (parent) {\n    reportCleanChild(parent, entry);\n  });\n}\n\nfunction mightBeDirty(entry) {\n  return entry.dirty ||\n    (entry.dirtyChildren &&\n     entry.dirtyChildren.size);\n}\n\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(entry, child) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(entry.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (! entry.dirtyChildren) {\n    entry.dirtyChildren = emptySetPool.pop() || new Set;\n\n  } else if (entry.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  entry.dirtyChildren.add(child);\n  reportDirty(entry);\n}\n\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(entry, child) {\n  var cv = entry.childValues;\n\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(cv.has(child));\n  assert(! mightBeDirty(child));\n\n  var childValue = cv.get(child);\n  if (childValue === UNKNOWN_VALUE) {\n    cv.set(child, child.value);\n  } else if (childValue !== child.value) {\n    entry.setDirty();\n  }\n\n  removeDirtyChild(entry, child);\n\n  if (mightBeDirty(entry)) {\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction removeDirtyChild(entry, child) {\n  var dc = entry.dirtyChildren;\n  if (dc) {\n    dc.delete(child);\n    if (dc.size === 0) {\n      if (emptySetPool.length < exports.POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n      entry.dirtyChildren = null;\n    }\n  }\n}\n\nfunction rememberParent(entry) {\n  var local = getLocal();\n  var parent = local.currentParentEntry;\n  if (parent) {\n    entry.parents.add(parent);\n\n    if (! parent.childValues.has(entry)) {\n      parent.childValues.set(entry, UNKNOWN_VALUE);\n    }\n\n    if (mightBeDirty(entry)) {\n      reportDirtyChild(parent, entry);\n    } else {\n      reportCleanChild(parent, entry);\n    }\n\n    return parent;\n  }\n}\n\n// This is the most important method of the Entry API, because it\n// determines whether the cached entry.value can be returned immediately,\n// or must be recomputed. The overall performance of the caching system\n// depends on the truth of the following observations: (1) this.dirty is\n// usually false, (2) this.dirtyChildren is usually null/empty, and thus\n// (3) this.value is usally returned very quickly, without recomputation.\nfunction recomputeIfDirty(entry) {\n  if (entry.dirty) {\n    // If this Entry is explicitly dirty because someone called\n    // entry.setDirty(), recompute.\n    return reallyRecompute(entry);\n  }\n\n  if (mightBeDirty(entry)) {\n    // Get fresh values for any dirty children, and if those values\n    // disagree with this.childValues, mark this Entry explicitly dirty.\n    entry.dirtyChildren.forEach(function (child) {\n      assert(entry.childValues.has(child));\n      try {\n        recomputeIfDirty(child);\n      } catch (e) {\n        entry.setDirty();\n      }\n    });\n\n    if (entry.dirty) {\n      // If this Entry has become explicitly dirty after comparing the fresh\n      // values of its dirty children against this.childValues, recompute.\n      return reallyRecompute(entry);\n    }\n  }\n\n  assert(entry.value !== UNKNOWN_VALUE);\n\n  return entry.value;\n}\n\nfunction reallyRecompute(entry) {\n  assert(! entry.recomputing, \"already recomputing\");\n  entry.recomputing = true;\n\n  // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n  var originalChildren = forgetChildren(entry);\n\n  var local = getLocal();\n  var parent = local.currentParentEntry;\n  local.currentParentEntry = entry;\n\n  var threw = true;\n  try {\n    entry.value = entry.fn.apply(null, entry.args);\n    threw = false;\n\n  } finally {\n    entry.recomputing = false;\n\n    assert(local.currentParentEntry === entry);\n    local.currentParentEntry = parent;\n\n    if (threw || ! subscribe(entry)) {\n      // Mark this Entry dirty if entry.fn threw or we failed to\n      // resubscribe. This is important because, if we have a subscribe\n      // function and it failed, then we're going to miss important\n      // notifications about the potential dirtiness of entry.value.\n      entry.setDirty();\n    } else {\n      // If we successfully recomputed entry.value and did not fail to\n      // (re)subscribe, then this Entry is no longer explicitly dirty.\n      setClean(entry);\n    }\n  }\n\n  // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n  originalChildren.forEach(maybeReportOrphan);\n\n  return entry.value;\n}\n\nvar reusableEmptyArray = [];\n\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(entry) {\n  var children = reusableEmptyArray;\n\n  if (entry.childValues.size > 0) {\n    children = [];\n    entry.childValues.forEach(function (value, child) {\n      forgetChild(entry, child);\n      children.push(child);\n    });\n  }\n\n  // After we forget all our children, this.dirtyChildren must be empty\n  // and therefor must have been reset to null.\n  assert(entry.dirtyChildren === null);\n\n  return children;\n}\n\nfunction forgetChild(entry, child) {\n  child.parents.delete(entry);\n  entry.childValues.delete(child);\n  removeDirtyChild(entry, child);\n}\n\nfunction subscribe(entry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      unsubscribe(entry); // Prevent double subscriptions.\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  }\n\n  // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n  return true;\n}\n\nfunction unsubscribe(entry) {\n  var unsub = entry.unsubscribe;\n  if (typeof unsub === \"function\") {\n    entry.unsubscribe = null;\n    unsub();\n  }\n}\n","\"use strict\";\n\nfunction Cache(options) {\n  this.map = new Map;\n  this.newest = null;\n  this.oldest = null;\n  this.max = options && options.max;\n  this.dispose = options && options.dispose;\n}\n\nexports.Cache = Cache;\n\nvar Cp = Cache.prototype;\n\nCp.has = function (key) {\n  return this.map.has(key);\n};\n\nCp.get = function (key) {\n  var entry = getEntry(this, key);\n  return entry && entry.value;\n};\n\nfunction getEntry(cache, key) {\n  var entry = cache.map.get(key);\n  if (entry &&\n      entry !== cache.newest) {\n    var older = entry.older;\n    var newer = entry.newer;\n\n    if (newer) {\n      newer.older = older;\n    }\n\n    if (older) {\n      older.newer = newer;\n    }\n\n    entry.older = cache.newest;\n    entry.older.newer = entry;\n\n    entry.newer = null;\n    cache.newest = entry;\n\n    if (entry === cache.oldest) {\n      cache.oldest = newer;\n    }\n  }\n\n  return entry;\n}\n\nCp.set = function (key, value) {\n  var entry = getEntry(this, key);\n  if (entry) {\n    return entry.value = value;\n  }\n\n  entry = {\n    key: key,\n    value: value,\n    newer: null,\n    older: this.newest\n  };\n\n  if (this.newest) {\n    this.newest.newer = entry;\n  }\n\n  this.newest = entry;\n  this.oldest = this.oldest || entry;\n\n  this.map.set(key, entry);\n\n  return entry.value;\n};\n\nCp.clean = function () {\n  if (typeof this.max === \"number\") {\n    while (this.oldest &&\n           this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  }\n};\n\nCp.delete = function (key) {\n  var entry = this.map.get(key);\n  if (entry) {\n    if (entry === this.newest) {\n      this.newest = entry.older;\n    }\n\n    if (entry === this.oldest) {\n      this.oldest = entry.newer;\n    }\n\n    if (entry.newer) {\n      entry.newer.older = entry.older;\n    }\n\n    if (entry.older) {\n      entry.older.newer = entry.newer;\n    }\n\n    this.map.delete(key);\n\n    if (typeof this.dispose === \"function\") {\n      this.dispose(key, entry.value);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","\"use strict\";\n\nvar Cache = require(\"./cache.js\").Cache;\nvar tuple = require(\"immutable-tuple\").tuple;\nvar Entry = require(\"./entry.js\").Entry;\nvar getLocal = require(\"./local.js\").get;\n\n// Exported so that custom makeCacheKey functions can easily reuse the\n// default implementation (with different arguments).\nexports.defaultMakeCacheKey = tuple;\n\nfunction normalizeOptions(options) {\n  options = options || Object.create(null);\n\n  if (typeof options.makeCacheKey !== \"function\") {\n    options.makeCacheKey = tuple;\n  }\n\n  if (typeof options.max !== \"number\") {\n    options.max = Math.pow(2, 16);\n  }\n\n  return options;\n}\n\nfunction wrap(fn, options) {\n  options = normalizeOptions(options);\n\n  // If this wrapped function is disposable, then its creator does not\n  // care about its return value, and it should be removed from the cache\n  // immediately when it no longer has any parents that depend on it.\n  var disposable = !! options.disposable;\n\n  var cache = new Cache({\n    max: options.max,\n    dispose: function (key, entry) {\n      entry.dispose();\n    }\n  });\n\n  function reportOrphan(entry) {\n    if (disposable) {\n      // Triggers the entry.dispose() call above.\n      cache.delete(entry.key);\n      return true;\n    }\n  }\n\n  function optimistic() {\n    if (disposable && ! getLocal().currentParentEntry) {\n      // If there's no current parent computation, and this wrapped\n      // function is disposable (meaning we don't care about entry.value,\n      // just dependency tracking), then we can short-cut everything else\n      // in this function, because entry.recompute() is going to recycle\n      // the entry object without recomputing anything, anyway.\n      return;\n    }\n\n    var key = options.makeCacheKey.apply(null, arguments);\n    if (! key) {\n      return fn.apply(null, arguments);\n    }\n\n    var args = [], len = arguments.length;\n    while (len--) args[len] = arguments[len];\n\n    var entry = cache.get(key);\n    if (entry) {\n      entry.args = args;\n    } else {\n      cache.set(key, entry = Entry.acquire(fn, key, args));\n      entry.subscribe = options.subscribe;\n      if (disposable) {\n        entry.reportOrphan = reportOrphan;\n      }\n    }\n\n    var value = entry.recompute();\n\n    // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n    cache.set(key, entry);\n\n    // Clean up any excess entries in the cache, but only if this entry\n    // has no parents, which means we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n    if (entry.parents.size === 0) {\n      cache.clean();\n    }\n\n    // If options.disposable is truthy, the caller of wrap is telling us\n    // they don't care about the result of entry.recompute(), so we should\n    // avoid returning the value, so it won't be accidentally used.\n    if (! disposable) {\n      return value;\n    }\n  }\n\n  optimistic.dirty = function () {\n    var key = options.makeCacheKey.apply(null, arguments);\n    if (! key) {\n      return;\n    }\n\n    if (! cache.has(key)) {\n      return;\n    }\n\n    cache.get(key).setDirty();\n  };\n\n  return optimistic;\n}\n\nexports.wrap = wrap;\n","\"use strict\";\n\nvar fakeNullFiber = new (function Fiber(){});\nvar localKey = \"_optimism_local\";\n\nfunction getCurrentFiber() {\n  return fakeNullFiber;\n}\n\nif (typeof module === \"object\") {\n  try {\n    var Fiber = module[\"eriuqer\".split(\"\").reverse().join(\"\")](\"fibers\");\n    // If we were able to require fibers, redefine the getCurrentFiber\n    // function so that it has a chance to return Fiber.current.\n    getCurrentFiber = function () {\n      return Fiber.current || fakeNullFiber;\n    };\n  } catch (e) {}\n}\n\n// Returns an object unique to Fiber.current, if fibers are enabled.\n// This object is used for Fiber-local storage in ./entry.js.\nexports.get = function () {\n  var fiber = getCurrentFiber();\n  return fiber[localKey] || (fiber[localKey] = Object.create(null));\n};\n"],"sourceRoot":""}