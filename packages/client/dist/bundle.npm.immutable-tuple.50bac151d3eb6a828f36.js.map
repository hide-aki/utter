{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/immutable-tuple/dist/tuple.mjs"],"names":["__webpack_require__","r","__webpack_exports__","d","tuple","lookup","lookupArray","useSymbol","Symbol","for","brand","globalKey","def","obj","name","value","enumerable","Object","defineProperty","writable","configurable","freeze","isObjRef","UniversalWeakMap","this","_weakMap","_strongMap","data","prototype","get","key","map","_getMap","set","canCreate","WeakMap","Map","root","Array","arguments","array","node","len","length","i","item","create","arguments$1","apply","t","argc","isTuple","that","toArray","fn","call","mustConvertThisToArray","desc","getOwnPropertyDescriptor","iterator","forEachArrayMethod","method","args","result","isArray","concat"],"mappings":"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","file":"bundle.npm.immutable-tuple.50bac151d3eb6a828f36.js","sourcesContent":["// Although `Symbol` is widely supported these days, we can safely fall\n// back to using a non-enumerable string property without violating any\n// assumptions elsewhere in the implementation.\nvar useSymbol =\n  typeof Symbol === \"function\" &&\n  typeof Symbol.for === \"function\";\n\n// Used to mark `tuple.prototype` so that all objects that inherit from\n// any `tuple.prototype` object (there could be more than one) will test\n// positive according to `tuple.isTuple`.\nvar brand = useSymbol\n  ? Symbol.for(\"immutable-tuple\")\n  : \"@@__IMMUTABLE_TUPLE__@@\";\n\n// Used to save a reference to the globally shared `UniversalWeakMap` that\n// stores all known `tuple` objects.\nvar globalKey = useSymbol\n  ? Symbol.for(\"immutable-tuple-root\")\n  : \"@@__IMMUTABLE_TUPLE_ROOT__@@\";\n\n// Convenient helper for defining hidden immutable properties.\nfunction def(obj, name, value, enumerable) {\n  Object.defineProperty(obj, name, {\n    value: value,\n    enumerable: !! enumerable,\n    writable: false,\n    configurable: false\n  });\n  return value;\n}\n\nvar freeze = Object.freeze || function (obj) {\n  return obj;\n};\n\nfunction isObjRef(value) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) {\n      return false;\n    }\n  case \"function\":\n    return true;\n  default:\n    return false;\n  }\n}\n\n// The `mustConvertThisToArray` value is true when the corresponding\n// `Array` method does not attempt to modify `this`, which means we can\n// pass a `tuple` object as `this` without first converting it to an\n// `Array`.\nfunction forEachArrayMethod(fn) {\n  function call(name, mustConvertThisToArray) {\n    var desc = Object.getOwnPropertyDescriptor(Array.prototype, name);\n    fn(name, desc, !! mustConvertThisToArray);\n  }\n\n  call(\"every\");\n  call(\"filter\");\n  call(\"find\");\n  call(\"findIndex\");\n  call(\"forEach\");\n  call(\"includes\");\n  call(\"indexOf\");\n  call(\"join\");\n  call(\"lastIndexOf\");\n  call(\"map\");\n  call(\"reduce\");\n  call(\"reduceRight\");\n  call(\"slice\");\n  call(\"some\");\n  call(\"toLocaleString\");\n  call(\"toString\");\n\n  // The `reverse` and `sort` methods are usually destructive, but for\n  // `tuple` objects they return a new `tuple` object that has been\n  // appropriately reversed/sorted.\n  call(\"reverse\", true);\n  call(\"sort\", true);\n\n  // Make `[...someTuple]` work.\n  call(useSymbol && Symbol.iterator || \"@@iterator\");\n}\n\n// A map data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\nvar UniversalWeakMap = function UniversalWeakMap() {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  this._weakMap = null;\n  this._strongMap = null;\n  this.data = null;\n};\n\n// Since `get` and `set` are the only methods used, that's all I've\n// implemented here.\n\nUniversalWeakMap.prototype.get = function get (key) {\n  var map = this._getMap(key, false);\n  if (map) {\n    return map.get(key);\n  }\n};\n\nUniversalWeakMap.prototype.set = function set (key, value) {\n  this._getMap(key, true).set(key, value);\n  // An actual `Map` or `WeakMap` would return `this` here, but\n  // returning the `value` is more convenient for the `tuple`\n  // implementation.\n  return value;\n};\n\nUniversalWeakMap.prototype._getMap = function _getMap (key, canCreate) {\n  if (! canCreate) {\n    return isObjRef(key) ? this._weakMap : this._strongMap;\n  }\n  if (isObjRef(key)) {\n    return this._weakMap || (this._weakMap = new WeakMap);\n  }\n  return this._strongMap || (this._strongMap = new Map);\n};\n\n// See [`universal-weak-map.js`](universal-weak-map.html).\n// See [`util.js`](util.html).\n// If this package is installed multiple times, there could be mutiple\n// implementations of the `tuple` function with distinct `tuple.prototype`\n// objects, but the shared pool of `tuple` objects must be the same across\n// all implementations. While it would be ideal to use the `global`\n// object, there's no reliable way to get the global object across all JS\n// environments without using the `Function` constructor, so instead we\n// use the global `Array` constructor as a shared namespace.\nvar root = Array[globalKey] || def(Array, globalKey, new UniversalWeakMap, false);\n\nfunction lookup() {\n  return lookupArray(arguments);\n}\n\nfunction lookupArray(array) {\n  var node = root;\n\n  // Because we are building a tree of *weak* maps, the tree will not\n  // prevent objects in tuples from being garbage collected, since the\n  // tree itself will be pruned over time when the corresponding `tuple`\n  // objects become unreachable. In addition to internalization, this\n  // property is a key advantage of the `immutable-tuple` package.\n  var len = array.length;\n  for (var i = 0; i < len; ++i) {\n    var item = array[i];\n    node = node.get(item) || node.set(item, new UniversalWeakMap);\n  }\n\n  // Return node.data rather than node itself to prevent tampering with\n  // the UniversalWeakMap tree.\n  return node.data || (node.data = Object.create(null));\n}\n\n// See [`lookup.js`](lookup.html).\n// See [`util.js`](util.html).\n// When called with any number of arguments, this function returns an\n// object that inherits from `tuple.prototype` and is guaranteed to be\n// `===` any other `tuple` object that has exactly the same items. In\n// computer science jargon, `tuple` instances are \"internalized\" or just\n// \"interned,\" which allows for constant-time equality checking, and makes\n// it possible for tuple objects to be used as `Map` or `WeakMap` keys, or\n// stored in a `Set`.\nfunction tuple() {\n  var arguments$1 = arguments;\n\n  var node = lookup.apply(null, arguments);\n\n  if (node.tuple) {\n    return node.tuple;\n  }\n\n  var t = Object.create(tuple.prototype);\n\n  // Define immutable items with numeric indexes, and permanently fix the\n  // `.length` property.\n  var argc = arguments.length;\n  for (var i = 0; i < argc; ++i) {\n    t[i] = arguments$1[i];\n  }\n\n  def(t, \"length\", argc, false);\n\n  // Remember this new `tuple` object so that we can return the same object\n  // earlier next time.\n  return freeze(node.tuple = t);\n}\n\n// Since the `immutable-tuple` package could be installed multiple times\n// in an application, there is no guarantee that the `tuple` constructor\n// or `tuple.prototype` will be unique, so `value instanceof tuple` is\n// unreliable. Instead, to test if a value is a tuple, you should use\n// `tuple.isTuple(value)`.\ndef(tuple.prototype, brand, true, false);\nfunction isTuple(that) {\n  return !! (that && that[brand] === true);\n}\n\ntuple.isTuple = isTuple;\n\nfunction toArray(tuple) {\n  var array = [];\n  var i = tuple.length;\n  while (i--) { array[i] = tuple[i]; }\n  return array;\n}\n\n// Copy all generic non-destructive Array methods to `tuple.prototype`.\n// This works because (for example) `Array.prototype.slice` can be invoked\n// against any `Array`-like object.\nforEachArrayMethod(function (name, desc, mustConvertThisToArray) {\n  var method = desc && desc.value;\n  if (typeof method === \"function\") {\n    desc.value = function () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var result = method.apply(\n        mustConvertThisToArray ? toArray(this) : this,\n        args\n      );\n      // Of course, `tuple.prototype.slice` should return a `tuple` object,\n      // not a new `Array`.\n      return Array.isArray(result) ? tuple.apply(void 0, result) : result;\n    };\n    Object.defineProperty(tuple.prototype, name, desc);\n  }\n});\n\n// Like `Array.prototype.concat`, except for the extra effort required to\n// convert any tuple arguments to arrays, so that\n// ```\n// tuple(1).concat(tuple(2), 3) === tuple(1, 2, 3)\n// ```\nvar ref = Array.prototype;\nvar concat = ref.concat;\ntuple.prototype.concat = function () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return tuple.apply(void 0, concat.apply(toArray(this), args.map(\n    function (item) { return isTuple(item) ? toArray(item) : item; }\n  )));\n};\n\nexport default tuple;\nexport { tuple, lookup, lookupArray };\n"],"sourceRoot":""}