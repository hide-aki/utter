{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/apollo-cache-inmemory/lib/fragmentMatcher.js","webpack:////var/www/html/utter/node_modules/apollo-cache-inmemory/lib/cacheKeys.js","webpack:////var/www/html/utter/node_modules/apollo-cache-inmemory/lib/depTrackingCache.js","webpack:////var/www/html/utter/node_modules/apollo-cache-inmemory/lib/readFromStore.js","webpack:////var/www/html/utter/node_modules/apollo-cache-inmemory/lib/objectCache.js","webpack:////var/www/html/utter/node_modules/apollo-cache-inmemory/lib/writeToStore.js","webpack:////var/www/html/utter/node_modules/apollo-cache-inmemory/lib/inMemoryCache.js","webpack:////var/www/html/utter/node_modules/apollo-cache-inmemory/lib/fixPolyfills.js"],"names":["haveWarned","fragmentMatcher_HeuristicFragmentMatcher","HeuristicFragmentMatcher","prototype","ensureReady","Promise","resolve","canBypassInit","match","idValue","typeCondition","context","obj","store","get","id","__typename","Object","warnOnce","console","warn","environment","IntrospectionFragmentMatcher","options","introspectionQueryResultData","this","possibleTypesMap","parseIntrospectionResult","isReady","bind","Error","JSON","stringify","implementingTypes","indexOf","introspectionResultData","typeMap","__schema","types","forEach","type","kind","name","possibleTypes","map","implementingType","CacheKeyNode","children","key","lookup","args","_i","arguments","length","lookupArray","array","node","value","getOrCreate","create","Map","set","hasOwn","hasOwnProperty","depTrackingCache_DepTrackingCache","DepTrackingCache","data","_this","depend","lib","dataId","disposable","makeCacheKey","toObject","dirty","delete","call","clear","replace","newData","keys","defaultNormalizedCacheFactory","seed","readFromStore_StoreReader","StoreReader","cacheKeyRoot","reader","executeStoreQuery","executeSelectionSet","_a","query","rootValue","contextValue","variableValues","fragmentMatcher","selectionSet","execContext","readQueryFromStore","diffQueryAgainstStore","tslib_es6","returnPartialData","result","variables","previousResult","_b","_c","rootId","fragmentMatcherFunction","config","queryDefinition","getFromAST","util_assign","dataIdFromObject","cacheRedirects","execResult","generated","typename","hasMissingFields","missing","info","tolerable","fieldName","object","isEqual","complete","defaultFragmentMatcher","mainDefinition","fragments","fragmentMap","target","pastCopies","finalResult","objectsToMerge","handleMissing","push","apply","selections","selection","lib_directives","storeUtils","fieldResult","executeField","fragment","fragmentExecResult","source","mergeHelper","isExtensible","shallowCopyForMerge","sourceKey","sourceValue","readFromStore_hasOwn","targetValue","field","readStoreResult","resultKey","directives","storeKeyName","fieldValue","resolver","getCacheKey","storeObj","json","readStoreResolver","Array","isArray","combineExecResults","executeSubSelectedArray","assertSelectionSetForIdValue","execResults","pop","childResult","item","slice","ObjectCache","writeToStore_WriteError","_super","WriteError","writeToStore_StoreWriter","StoreWriter","writeQueryToStore","writeResultToStore","document","operationDefinition","writeSelectionSetToStore","processedData","e","error","enhancedError","message","stack","enhanceErrorWithDocument","resultFieldKey","writeFieldToStore","some","directive","substring","matches","undefined","fakeContext","self","storeValue","storeObject","storeFieldName","generatedId","processArrayValue","valueDataId","isGeneratedId","semanticId","isDataProcessed","escapedId","hadTypename","hasTypename","typenameChanged","mergeWithGenerated","generatedKey","realKey","cache","real","madeChanges","realValue","newRealValue","index","itemDataId","__webpack_require__","d","__webpack_exports__","inMemoryCache_InMemoryCache","defaultConfig","_id","addTypename","resultCaching","inMemoryCache_hasOwn","inMemoryCache_OptimisticCacheLayer","OptimisticCacheLayer","optimisticId","parent","transaction","InMemoryCache","watches","Set","typenameDocumentCache","silenceBroadcast","customResolvers","cacheResolvers","optimisticData","storeReader","storeWriter","maybeBroadcastWatch","c","optimistic","restore","extract","read","transformDocument","write","broadcastWatches","diff","watch","add","evict","reset","removeOptimistic","idToRemove","toReapply","removedCount","layer","layer_1","performTransaction","recordOptimisticTransaction","transform","callback","lib_cache","testMap","set_1","testSet","add_1","frozen","freeze","wrap","method","seal","preventExtensions"],"mappings":"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","file":"bundle.npm.apollo-cache-inmemory.220286466fa61e245d89.js","sourcesContent":["import { isTest, warnOnceInDevelopment } from 'apollo-utilities';\nvar haveWarned = false;\nvar HeuristicFragmentMatcher = (function () {\n    function HeuristicFragmentMatcher() {\n    }\n    HeuristicFragmentMatcher.prototype.ensureReady = function () {\n        return Promise.resolve();\n    };\n    HeuristicFragmentMatcher.prototype.canBypassInit = function () {\n        return true;\n    };\n    HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        var obj = context.store.get(idValue.id);\n        if (!obj && idValue.id === 'ROOT_QUERY') {\n            return true;\n        }\n        if (!obj) {\n            return false;\n        }\n        if (!obj.__typename) {\n            if (!haveWarned) {\n                console.warn(\"You're using fragments in your queries, but either don't have the addTypename:\\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\\n   can accurately match fragments.\");\n                console.warn('Could not find __typename on Fragment ', typeCondition, obj);\n                console.warn(\"DEPRECATION WARNING: using fragments without __typename is unsupported behavior \" +\n                    \"and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.\");\n                if (!isTest()) {\n                    haveWarned = true;\n                }\n            }\n            return 'heuristic';\n        }\n        if (obj.__typename === typeCondition) {\n            return true;\n        }\n        warnOnceInDevelopment('You are using the simple (heuristic) fragment matcher, but your ' +\n            'queries contain union or interface types. Apollo Client will not be ' +\n            'able to accurately map fragments. To make this error go away, use ' +\n            'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n            'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher', 'error');\n        return 'heuristic';\n    };\n    return HeuristicFragmentMatcher;\n}());\nexport { HeuristicFragmentMatcher };\nvar IntrospectionFragmentMatcher = (function () {\n    function IntrospectionFragmentMatcher(options) {\n        if (options && options.introspectionQueryResultData) {\n            this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);\n            this.isReady = true;\n        }\n        else {\n            this.isReady = false;\n        }\n        this.match = this.match.bind(this);\n    }\n    IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        if (!this.isReady) {\n            throw new Error('FragmentMatcher.match() was called before FragmentMatcher.init()');\n        }\n        var obj = context.store.get(idValue.id);\n        if (!obj) {\n            return false;\n        }\n        if (!obj.__typename) {\n            throw new Error(\"Cannot match fragment because __typename property is missing: \" + JSON.stringify(obj));\n        }\n        if (obj.__typename === typeCondition) {\n            return true;\n        }\n        var implementingTypes = this.possibleTypesMap[typeCondition];\n        if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {\n            return true;\n        }\n        return false;\n    };\n    IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {\n        var typeMap = {};\n        introspectionResultData.__schema.types.forEach(function (type) {\n            if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n                typeMap[type.name] = type.possibleTypes.map(function (implementingType) { return implementingType.name; });\n            }\n        });\n        return typeMap;\n    };\n    return IntrospectionFragmentMatcher;\n}());\nexport { IntrospectionFragmentMatcher };\n//# sourceMappingURL=fragmentMatcher.js.map","var CacheKeyNode = (function () {\n    function CacheKeyNode() {\n        this.children = null;\n        this.key = null;\n    }\n    CacheKeyNode.prototype.lookup = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return this.lookupArray(args);\n    };\n    CacheKeyNode.prototype.lookupArray = function (array) {\n        var node = this;\n        array.forEach(function (value) {\n            node = node.getOrCreate(value);\n        });\n        return node.key || (node.key = Object.create(null));\n    };\n    CacheKeyNode.prototype.getOrCreate = function (value) {\n        var map = this.children || (this.children = new Map());\n        var node = map.get(value);\n        if (!node) {\n            map.set(value, (node = new CacheKeyNode()));\n        }\n        return node;\n    };\n    return CacheKeyNode;\n}());\nexport { CacheKeyNode };\n//# sourceMappingURL=cacheKeys.js.map","import { wrap } from 'optimism';\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar DepTrackingCache = (function () {\n    function DepTrackingCache(data) {\n        if (data === void 0) { data = Object.create(null); }\n        var _this = this;\n        this.data = data;\n        this.depend = wrap(function (dataId) { return _this.data[dataId]; }, {\n            disposable: true,\n            makeCacheKey: function (dataId) {\n                return dataId;\n            }\n        });\n    }\n    DepTrackingCache.prototype.toObject = function () {\n        return this.data;\n    };\n    DepTrackingCache.prototype.get = function (dataId) {\n        this.depend(dataId);\n        return this.data[dataId];\n    };\n    DepTrackingCache.prototype.set = function (dataId, value) {\n        var oldValue = this.data[dataId];\n        if (value !== oldValue) {\n            this.data[dataId] = value;\n            this.depend.dirty(dataId);\n        }\n    };\n    DepTrackingCache.prototype.delete = function (dataId) {\n        if (hasOwn.call(this.data, dataId)) {\n            delete this.data[dataId];\n            this.depend.dirty(dataId);\n        }\n    };\n    DepTrackingCache.prototype.clear = function () {\n        this.replace(null);\n    };\n    DepTrackingCache.prototype.replace = function (newData) {\n        var _this = this;\n        if (newData) {\n            Object.keys(newData).forEach(function (dataId) {\n                _this.set(dataId, newData[dataId]);\n            });\n            Object.keys(this.data).forEach(function (dataId) {\n                if (!hasOwn.call(newData, dataId)) {\n                    _this.delete(dataId);\n                }\n            });\n        }\n        else {\n            Object.keys(this.data).forEach(function (dataId) {\n                _this.delete(dataId);\n            });\n        }\n    };\n    return DepTrackingCache;\n}());\nexport { DepTrackingCache };\nexport function defaultNormalizedCacheFactory(seed) {\n    return new DepTrackingCache(seed);\n}\n//# sourceMappingURL=depTrackingCache.js.map","import * as tslib_1 from \"tslib\";\nimport { assign, getDefaultValues, getQueryDefinition, isEqual, argumentsObjectFromField, createFragmentMap, getDirectiveInfoFromField, getFragmentDefinitions, getMainDefinition, getStoreKeyName, isField, isIdValue, isInlineFragment, isJsonValue, resultKeyNameFromField, shouldInclude, toIdValue, } from 'apollo-utilities';\nimport { wrap } from 'optimism';\nimport { CacheKeyNode } from './cacheKeys';\nimport { DepTrackingCache } from './depTrackingCache';\nvar StoreReader = (function () {\n    function StoreReader(cacheKeyRoot) {\n        if (cacheKeyRoot === void 0) { cacheKeyRoot = new CacheKeyNode; }\n        var _this = this;\n        this.cacheKeyRoot = cacheKeyRoot;\n        var reader = this;\n        var executeStoreQuery = reader.executeStoreQuery, executeSelectionSet = reader.executeSelectionSet;\n        this.executeStoreQuery = wrap(function (options) {\n            return executeStoreQuery.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, fragmentMatcher = _a.fragmentMatcher;\n                if (contextValue.store instanceof DepTrackingCache) {\n                    return reader.cacheKeyRoot.lookup(query, contextValue.store, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);\n                }\n                return;\n            }\n        });\n        this.executeSelectionSet = wrap(function (options) {\n            return executeSelectionSet.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;\n                if (execContext.contextValue.store instanceof DepTrackingCache) {\n                    return reader.cacheKeyRoot.lookup(selectionSet, execContext.contextValue.store, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);\n                }\n                return;\n            }\n        });\n    }\n    StoreReader.prototype.readQueryFromStore = function (options) {\n        var optsPatch = { returnPartialData: false };\n        return this.diffQueryAgainstStore(tslib_1.__assign({}, options, optsPatch)).result;\n    };\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? 'ROOT_QUERY' : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;\n        var queryDefinition = getQueryDefinition(query);\n        variables = assign({}, getDefaultValues(queryDefinition), variables);\n        var context = {\n            store: store,\n            dataIdFromObject: (config && config.dataIdFromObject) || null,\n            cacheRedirects: (config && config.cacheRedirects) || {},\n        };\n        var execResult = this.executeStoreQuery({\n            query: query,\n            rootValue: {\n                type: 'id',\n                id: rootId,\n                generated: true,\n                typename: 'Query',\n            },\n            contextValue: context,\n            variableValues: variables,\n            fragmentMatcher: fragmentMatcherFunction,\n        });\n        var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n        if (hasMissingFields && !returnPartialData) {\n            execResult.missing.forEach(function (info) {\n                if (info.tolerable)\n                    return;\n                throw new Error(\"Can't find field \" + info.fieldName + \" on object \" + JSON.stringify(info.object, null, 2) + \".\");\n            });\n        }\n        if (previousResult) {\n            if (isEqual(previousResult, execResult.result)) {\n                execResult.result = previousResult;\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !hasMissingFields,\n        };\n    };\n    StoreReader.prototype.executeStoreQuery = function (_a) {\n        var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;\n        var mainDefinition = getMainDefinition(query);\n        var fragments = getFragmentDefinitions(query);\n        var fragmentMap = createFragmentMap(fragments);\n        var execContext = {\n            query: query,\n            fragmentMap: fragmentMap,\n            contextValue: contextValue,\n            variableValues: variableValues,\n            fragmentMatcher: fragmentMatcher,\n        };\n        return this.executeSelectionSet({\n            selectionSet: mainDefinition.selectionSet,\n            rootValue: rootValue,\n            execContext: execContext,\n        });\n    };\n    StoreReader.prototype.executeSelectionSet = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;\n        var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;\n        var finalResult = {\n            result: {},\n        };\n        var objectsToMerge = [];\n        var object = contextValue.store.get(rootValue.id);\n        var typename = (object && object.__typename) ||\n            (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n            void 0;\n        function handleMissing(result) {\n            var _a;\n            if (result.missing) {\n                finalResult.missing = finalResult.missing || [];\n                (_a = finalResult.missing).push.apply(_a, result.missing);\n            }\n            return result.result;\n        }\n        selectionSet.selections.forEach(function (selection) {\n            var _a;\n            if (!shouldInclude(selection, variables)) {\n                return;\n            }\n            if (isField(selection)) {\n                var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));\n                if (typeof fieldResult !== 'undefined') {\n                    objectsToMerge.push((_a = {},\n                        _a[resultKeyNameFromField(selection)] = fieldResult,\n                        _a));\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (isInlineFragment(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = fragmentMap[selection.name.value];\n                    if (!fragment) {\n                        throw new Error(\"No fragment named \" + selection.name.value);\n                    }\n                }\n                var typeCondition = fragment.typeCondition.name.value;\n                var match = execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n                if (match) {\n                    var fragmentExecResult = _this.executeSelectionSet({\n                        selectionSet: fragment.selectionSet,\n                        rootValue: rootValue,\n                        execContext: execContext,\n                    });\n                    if (match === 'heuristic' && fragmentExecResult.missing) {\n                        fragmentExecResult = tslib_1.__assign({}, fragmentExecResult, { missing: fragmentExecResult.missing.map(function (info) {\n                                return tslib_1.__assign({}, info, { tolerable: true });\n                            }) });\n                    }\n                    objectsToMerge.push(handleMissing(fragmentExecResult));\n                }\n            }\n        });\n        merge(finalResult.result, objectsToMerge);\n        return finalResult;\n    };\n    StoreReader.prototype.executeField = function (object, typename, field, execContext) {\n        var variables = execContext.variableValues, contextValue = execContext.contextValue;\n        var fieldName = field.name.value;\n        var args = argumentsObjectFromField(field, variables);\n        var info = {\n            resultKey: resultKeyNameFromField(field),\n            directives: getDirectiveInfoFromField(field, variables),\n        };\n        var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);\n        if (Array.isArray(readStoreResult.result)) {\n            return this.combineExecResults(readStoreResult, this.executeSubSelectedArray(field, readStoreResult.result, execContext));\n        }\n        if (!field.selectionSet) {\n            assertSelectionSetForIdValue(field, readStoreResult.result);\n            return readStoreResult;\n        }\n        if (readStoreResult.result == null) {\n            return readStoreResult;\n        }\n        return this.combineExecResults(readStoreResult, this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            rootValue: readStoreResult.result,\n            execContext: execContext,\n        }));\n    };\n    StoreReader.prototype.combineExecResults = function () {\n        var execResults = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            execResults[_i] = arguments[_i];\n        }\n        var missing = null;\n        execResults.forEach(function (execResult) {\n            if (execResult.missing) {\n                missing = missing || [];\n                missing.push.apply(missing, execResult.missing);\n            }\n        });\n        return {\n            result: execResults.pop().result,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.executeSubSelectedArray = function (field, result, execContext) {\n        var _this = this;\n        var missing = null;\n        function handleMissing(childResult) {\n            if (childResult.missing) {\n                missing = missing || [];\n                missing.push.apply(missing, childResult.missing);\n            }\n            return childResult.result;\n        }\n        result = result.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            if (Array.isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray(field, item, execContext));\n            }\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    rootValue: item,\n                    execContext: execContext,\n                }));\n            }\n            assertSelectionSetForIdValue(field, item);\n            return item;\n        });\n        return { result: result, missing: missing };\n    };\n    return StoreReader;\n}());\nexport { StoreReader };\nfunction assertSelectionSetForIdValue(field, value) {\n    if (!field.selectionSet && isIdValue(value)) {\n        throw new Error(\"Missing selection set for object of type \" + value.typename + \" returned for query field \" + field.name.value);\n    }\n}\nfunction defaultFragmentMatcher() {\n    return true;\n}\nexport function assertIdValue(idValue) {\n    if (!isIdValue(idValue)) {\n        throw new Error(\"Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.\");\n    }\n}\nfunction readStoreResolver(object, typename, fieldName, args, context, _a) {\n    var resultKey = _a.resultKey, directives = _a.directives;\n    var storeKeyName = fieldName;\n    if (args || directives) {\n        storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n    }\n    var fieldValue = void 0;\n    if (object) {\n        fieldValue = object[storeKeyName];\n        if (typeof fieldValue === 'undefined' &&\n            context.cacheRedirects &&\n            typeof typename === 'string') {\n            var type = context.cacheRedirects[typename];\n            if (type) {\n                var resolver = type[fieldName];\n                if (resolver) {\n                    fieldValue = resolver(object, args, {\n                        getCacheKey: function (storeObj) {\n                            return toIdValue({\n                                id: context.dataIdFromObject(storeObj),\n                                typename: storeObj.__typename,\n                            });\n                        },\n                    });\n                }\n            }\n        }\n    }\n    if (typeof fieldValue === 'undefined') {\n        return {\n            result: fieldValue,\n            missing: [{\n                    object: object,\n                    fieldName: storeKeyName,\n                    tolerable: false,\n                }],\n        };\n    }\n    if (isJsonValue(fieldValue)) {\n        fieldValue = fieldValue.json;\n    }\n    return {\n        result: fieldValue,\n    };\n}\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction merge(target, sources) {\n    var pastCopies = [];\n    sources.forEach(function (source) {\n        mergeHelper(target, source, pastCopies);\n    });\n    return target;\n}\nfunction mergeHelper(target, source, pastCopies) {\n    if (source !== null && typeof source === 'object') {\n        if (Object.isExtensible && !Object.isExtensible(target)) {\n            target = shallowCopyForMerge(target, pastCopies);\n        }\n        Object.keys(source).forEach(function (sourceKey) {\n            var sourceValue = source[sourceKey];\n            if (hasOwn.call(target, sourceKey)) {\n                var targetValue = target[sourceKey];\n                if (sourceValue !== targetValue) {\n                    target[sourceKey] = mergeHelper(shallowCopyForMerge(targetValue, pastCopies), sourceValue, pastCopies);\n                }\n            }\n            else {\n                target[sourceKey] = sourceValue;\n            }\n        });\n    }\n    return target;\n}\nfunction shallowCopyForMerge(value, pastCopies) {\n    if (value !== null &&\n        typeof value === 'object' &&\n        pastCopies.indexOf(value) < 0) {\n        if (Array.isArray(value)) {\n            value = value.slice(0);\n        }\n        else {\n            value = tslib_1.__assign({}, value);\n        }\n        pastCopies.push(value);\n    }\n    return value;\n}\n//# sourceMappingURL=readFromStore.js.map","var ObjectCache = (function () {\n    function ObjectCache(data) {\n        if (data === void 0) { data = Object.create(null); }\n        this.data = data;\n    }\n    ObjectCache.prototype.toObject = function () {\n        return this.data;\n    };\n    ObjectCache.prototype.get = function (dataId) {\n        return this.data[dataId];\n    };\n    ObjectCache.prototype.set = function (dataId, value) {\n        this.data[dataId] = value;\n    };\n    ObjectCache.prototype.delete = function (dataId) {\n        this.data[dataId] = void 0;\n    };\n    ObjectCache.prototype.clear = function () {\n        this.data = Object.create(null);\n    };\n    ObjectCache.prototype.replace = function (newData) {\n        this.data = newData || Object.create(null);\n    };\n    return ObjectCache;\n}());\nexport { ObjectCache };\nexport function defaultNormalizedCacheFactory(seed) {\n    return new ObjectCache(seed);\n}\n//# sourceMappingURL=objectCache.js.map","import * as tslib_1 from \"tslib\";\nimport { assign, createFragmentMap, getDefaultValues, getFragmentDefinitions, getOperationDefinition, isField, isIdValue, isInlineFragment, isProduction, resultKeyNameFromField, shouldInclude, storeKeyNameFromField, toIdValue, isEqual, } from 'apollo-utilities';\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\nvar WriteError = (function (_super) {\n    tslib_1.__extends(WriteError, _super);\n    function WriteError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'WriteError';\n        return _this;\n    }\n    return WriteError;\n}(Error));\nexport { WriteError };\nexport function enhanceErrorWithDocument(error, document) {\n    var enhancedError = new WriteError(\"Error writing result to store for query:\\n \" + JSON.stringify(document));\n    enhancedError.message += '\\n' + error.message;\n    enhancedError.stack = error.stack;\n    return enhancedError;\n}\nvar StoreWriter = (function () {\n    function StoreWriter() {\n    }\n    StoreWriter.prototype.writeQueryToStore = function (_a) {\n        var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        return this.writeResultToStore({\n            dataId: 'ROOT_QUERY',\n            result: result,\n            document: query,\n            store: store,\n            variables: variables,\n            dataIdFromObject: dataIdFromObject,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n        });\n    };\n    StoreWriter.prototype.writeResultToStore = function (_a) {\n        var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        var operationDefinition = getOperationDefinition(document);\n        try {\n            return this.writeSelectionSetToStore({\n                result: result,\n                dataId: dataId,\n                selectionSet: operationDefinition.selectionSet,\n                context: {\n                    store: store,\n                    processedData: {},\n                    variables: assign({}, getDefaultValues(operationDefinition), variables),\n                    dataIdFromObject: dataIdFromObject,\n                    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n                    fragmentMatcherFunction: fragmentMatcherFunction,\n                },\n            });\n        }\n        catch (e) {\n            throw enhanceErrorWithDocument(e, document);\n        }\n    };\n    StoreWriter.prototype.writeSelectionSetToStore = function (_a) {\n        var _this = this;\n        var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;\n        var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;\n        selectionSet.selections.forEach(function (selection) {\n            if (!shouldInclude(selection, variables)) {\n                return;\n            }\n            if (isField(selection)) {\n                var resultFieldKey = resultKeyNameFromField(selection);\n                var value = result[resultFieldKey];\n                if (typeof value !== 'undefined') {\n                    _this.writeFieldToStore({\n                        dataId: dataId,\n                        value: value,\n                        field: selection,\n                        context: context,\n                    });\n                }\n                else {\n                    var isDefered = selection.directives &&\n                        selection.directives.length &&\n                        selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });\n                    if (!isDefered && context.fragmentMatcherFunction) {\n                        if (!isProduction()) {\n                            console.warn(\"Missing field \" + resultFieldKey + \" in \" + JSON.stringify(result, null, 2).substring(0, 100));\n                        }\n                    }\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (isInlineFragment(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = (fragmentMap || {})[selection.name.value];\n                    if (!fragment) {\n                        throw new Error(\"No fragment named \" + selection.name.value + \".\");\n                    }\n                }\n                var matches = true;\n                if (context.fragmentMatcherFunction && fragment.typeCondition) {\n                    var idValue = toIdValue({ id: 'self', typename: undefined });\n                    var fakeContext = {\n                        store: new ObjectCache({ self: result }),\n                        cacheRedirects: {},\n                    };\n                    var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);\n                    if (!isProduction() && match === 'heuristic') {\n                        console.error('WARNING: heuristic fragment matching going on!');\n                    }\n                    matches = !!match;\n                }\n                if (matches) {\n                    _this.writeSelectionSetToStore({\n                        result: result,\n                        selectionSet: fragment.selectionSet,\n                        dataId: dataId,\n                        context: context,\n                    });\n                }\n            }\n        });\n        return store;\n    };\n    StoreWriter.prototype.writeFieldToStore = function (_a) {\n        var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;\n        var _b;\n        var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;\n        var storeValue;\n        var storeObject;\n        var storeFieldName = storeKeyNameFromField(field, variables);\n        if (!field.selectionSet || value === null) {\n            storeValue =\n                value != null && typeof value === 'object'\n                    ?\n                        { type: 'json', json: value }\n                    :\n                        value;\n        }\n        else if (Array.isArray(value)) {\n            var generatedId = dataId + \".\" + storeFieldName;\n            storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);\n        }\n        else {\n            var valueDataId = dataId + \".\" + storeFieldName;\n            var generated = true;\n            if (!isGeneratedId(valueDataId)) {\n                valueDataId = '$' + valueDataId;\n            }\n            if (dataIdFromObject) {\n                var semanticId = dataIdFromObject(value);\n                if (semanticId && isGeneratedId(semanticId)) {\n                    throw new Error('IDs returned by dataIdFromObject cannot begin with the \"$\" character.');\n                }\n                if (semanticId ||\n                    (typeof semanticId === 'number' && semanticId === 0)) {\n                    valueDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(valueDataId, field, context.processedData)) {\n                this.writeSelectionSetToStore({\n                    dataId: valueDataId,\n                    result: value,\n                    selectionSet: field.selectionSet,\n                    context: context,\n                });\n            }\n            var typename = value.__typename;\n            storeValue = toIdValue({ id: valueDataId, typename: typename }, generated);\n            storeObject = store.get(dataId);\n            var escapedId = storeObject && storeObject[storeFieldName];\n            if (escapedId !== storeValue && isIdValue(escapedId)) {\n                var hadTypename = escapedId.typename !== undefined;\n                var hasTypename = typename !== undefined;\n                var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;\n                if (generated && !escapedId.generated && !typenameChanged) {\n                    throw new Error(\"Store error: the application attempted to write an object with no provided id\" +\n                        (\" but the store already contains an id of \" + escapedId.id + \" for this object. The selectionSet\") +\n                        \" that was trying to be written is:\\n\" +\n                        JSON.stringify(field));\n                }\n                if (hadTypename && !hasTypename) {\n                    throw new Error(\"Store error: the application attempted to write an object with no provided typename\" +\n                        (\" but the store already contains an object with typename of \" + escapedId.typename + \" for the object of id \" + escapedId.id + \". The selectionSet\") +\n                        \" that was trying to be written is:\\n\" +\n                        JSON.stringify(field));\n                }\n                if (escapedId.generated) {\n                    if (typenameChanged) {\n                        if (!generated) {\n                            store.delete(escapedId.id);\n                        }\n                    }\n                    else {\n                        mergeWithGenerated(escapedId.id, storeValue.id, store);\n                    }\n                }\n            }\n        }\n        storeObject = store.get(dataId);\n        if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n            store.set(dataId, tslib_1.__assign({}, storeObject, (_b = {}, _b[storeFieldName] = storeValue, _b)));\n        }\n    };\n    StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {\n        var _this = this;\n        return value.map(function (item, index) {\n            if (item === null) {\n                return null;\n            }\n            var itemDataId = generatedId + \".\" + index;\n            if (Array.isArray(item)) {\n                return _this.processArrayValue(item, itemDataId, selectionSet, context);\n            }\n            var generated = true;\n            if (context.dataIdFromObject) {\n                var semanticId = context.dataIdFromObject(item);\n                if (semanticId) {\n                    itemDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n                _this.writeSelectionSetToStore({\n                    dataId: itemDataId,\n                    result: item,\n                    selectionSet: selectionSet,\n                    context: context,\n                });\n            }\n            return toIdValue({ id: itemDataId, typename: item.__typename }, generated);\n        });\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nfunction isGeneratedId(id) {\n    return id[0] === '$';\n}\nfunction mergeWithGenerated(generatedKey, realKey, cache) {\n    if (generatedKey === realKey) {\n        return false;\n    }\n    var generated = cache.get(generatedKey);\n    var real = cache.get(realKey);\n    var madeChanges = false;\n    Object.keys(generated).forEach(function (key) {\n        var value = generated[key];\n        var realValue = real[key];\n        if (isIdValue(value) &&\n            isGeneratedId(value.id) &&\n            isIdValue(realValue) &&\n            !isEqual(value, realValue) &&\n            mergeWithGenerated(value.id, realValue.id, cache)) {\n            madeChanges = true;\n        }\n    });\n    cache.delete(generatedKey);\n    var newRealValue = tslib_1.__assign({}, generated, real);\n    if (isEqual(newRealValue, real)) {\n        return madeChanges;\n    }\n    cache.set(realKey, newRealValue);\n    return true;\n}\nfunction isDataProcessed(dataId, field, processedData) {\n    if (!processedData) {\n        return false;\n    }\n    if (processedData[dataId]) {\n        if (processedData[dataId].indexOf(field) >= 0) {\n            return true;\n        }\n        else {\n            processedData[dataId].push(field);\n        }\n    }\n    else {\n        processedData[dataId] = [field];\n    }\n    return false;\n}\n//# sourceMappingURL=writeToStore.js.map","import * as tslib_1 from \"tslib\";\nimport './fixPolyfills';\nimport { ApolloCache } from 'apollo-cache';\nimport { addTypenameToDocument } from 'apollo-utilities';\nimport { wrap } from 'optimism';\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { CacheKeyNode } from './cacheKeys';\nimport { ObjectCache } from './objectCache';\nvar defaultConfig = {\n    fragmentMatcher: new HeuristicFragmentMatcher(),\n    dataIdFromObject: defaultDataIdFromObject,\n    addTypename: true,\n    resultCaching: true,\n};\nexport function defaultDataIdFromObject(result) {\n    if (result.__typename) {\n        if (result.id !== undefined) {\n            return result.__typename + \":\" + result.id;\n        }\n        if (result._id !== undefined) {\n            return result.__typename + \":\" + result._id;\n        }\n    }\n    return null;\n}\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar OptimisticCacheLayer = (function (_super) {\n    tslib_1.__extends(OptimisticCacheLayer, _super);\n    function OptimisticCacheLayer(optimisticId, parent, transaction) {\n        var _this = _super.call(this, Object.create(null)) || this;\n        _this.optimisticId = optimisticId;\n        _this.parent = parent;\n        _this.transaction = transaction;\n        return _this;\n    }\n    OptimisticCacheLayer.prototype.toObject = function () {\n        return tslib_1.__assign({}, this.parent.toObject(), this.data);\n    };\n    OptimisticCacheLayer.prototype.get = function (dataId) {\n        return hasOwn.call(this.data, dataId)\n            ? this.data[dataId]\n            : this.parent.get(dataId);\n    };\n    return OptimisticCacheLayer;\n}(ObjectCache));\nexport { OptimisticCacheLayer };\nvar InMemoryCache = (function (_super) {\n    tslib_1.__extends(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) { config = {}; }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.typenameDocumentCache = new Map();\n        _this.cacheKeyRoot = new CacheKeyNode();\n        _this.silenceBroadcast = false;\n        _this.config = tslib_1.__assign({}, defaultConfig, config);\n        if (_this.config.customResolvers) {\n            console.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');\n            _this.config.cacheRedirects = _this.config.customResolvers;\n        }\n        if (_this.config.cacheResolvers) {\n            console.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');\n            _this.config.cacheRedirects = _this.config.cacheResolvers;\n        }\n        _this.addTypename = _this.config.addTypename;\n        _this.data = _this.config.resultCaching\n            ? new DepTrackingCache()\n            : new ObjectCache();\n        _this.optimisticData = _this.data;\n        _this.storeReader = new StoreReader(_this.cacheKeyRoot);\n        _this.storeWriter = new StoreWriter();\n        var cache = _this;\n        var maybeBroadcastWatch = cache.maybeBroadcastWatch;\n        _this.maybeBroadcastWatch = wrap(function (c) {\n            return maybeBroadcastWatch.call(_this, c);\n        }, {\n            makeCacheKey: function (c) {\n                if (c.optimistic) {\n                    return;\n                }\n                if (c.previousResult) {\n                    return;\n                }\n                if (cache.data instanceof DepTrackingCache) {\n                    return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));\n                }\n            }\n        });\n        return _this;\n    }\n    InMemoryCache.prototype.restore = function (data) {\n        if (data)\n            this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function (optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return (optimistic ? this.optimisticData : this.data).toObject();\n    };\n    InMemoryCache.prototype.read = function (options) {\n        if (typeof options.rootId === 'string' &&\n            typeof this.data.get(options.rootId) === 'undefined') {\n            return null;\n        }\n        return this.storeReader.readQueryFromStore({\n            store: options.optimistic ? this.optimisticData : this.data,\n            query: this.transformDocument(options.query),\n            variables: options.variables,\n            rootId: options.rootId,\n            fragmentMatcherFunction: this.config.fragmentMatcher.match,\n            previousResult: options.previousResult,\n            config: this.config,\n        });\n    };\n    InMemoryCache.prototype.write = function (write) {\n        this.storeWriter.writeResultToStore({\n            dataId: write.dataId,\n            result: write.result,\n            variables: write.variables,\n            document: this.transformDocument(write.query),\n            store: this.data,\n            dataIdFromObject: this.config.dataIdFromObject,\n            fragmentMatcherFunction: this.config.fragmentMatcher.match,\n        });\n        this.broadcastWatches();\n    };\n    InMemoryCache.prototype.diff = function (query) {\n        return this.storeReader.diffQueryAgainstStore({\n            store: query.optimistic ? this.optimisticData : this.data,\n            query: this.transformDocument(query.query),\n            variables: query.variables,\n            returnPartialData: query.returnPartialData,\n            previousResult: query.previousResult,\n            fragmentMatcherFunction: this.config.fragmentMatcher.match,\n            config: this.config,\n        });\n    };\n    InMemoryCache.prototype.watch = function (watch) {\n        var _this = this;\n        this.watches.add(watch);\n        return function () {\n            _this.watches.delete(watch);\n        };\n    };\n    InMemoryCache.prototype.evict = function (query) {\n        throw new Error(\"eviction is not implemented on InMemory Cache\");\n    };\n    InMemoryCache.prototype.reset = function () {\n        this.data.clear();\n        this.broadcastWatches();\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n        var toReapply = [];\n        var removedCount = 0;\n        var layer = this.optimisticData;\n        while (layer instanceof OptimisticCacheLayer) {\n            if (layer.optimisticId === idToRemove) {\n                ++removedCount;\n            }\n            else {\n                toReapply.push(layer);\n            }\n            layer = layer.parent;\n        }\n        if (removedCount > 0) {\n            this.optimisticData = layer;\n            while (toReapply.length > 0) {\n                var layer_1 = toReapply.pop();\n                this.performTransaction(layer_1.transaction, layer_1.optimisticId);\n            }\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {\n        var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;\n        this.silenceBroadcast = true;\n        if (typeof optimisticId === 'string') {\n            this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);\n        }\n        try {\n            transaction(this);\n        }\n        finally {\n            this.silenceBroadcast = silenceBroadcast;\n            this.data = data;\n        }\n        this.broadcastWatches();\n    };\n    InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {\n        return this.performTransaction(transaction, id);\n    };\n    InMemoryCache.prototype.transformDocument = function (document) {\n        if (this.addTypename) {\n            var result = this.typenameDocumentCache.get(document);\n            if (!result) {\n                result = addTypenameToDocument(document);\n                this.typenameDocumentCache.set(document, result);\n                this.typenameDocumentCache.set(result, result);\n            }\n            return result;\n        }\n        return document;\n    };\n    InMemoryCache.prototype.broadcastWatches = function () {\n        var _this = this;\n        if (!this.silenceBroadcast) {\n            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c); });\n        }\n    };\n    InMemoryCache.prototype.maybeBroadcastWatch = function (c) {\n        c.callback(this.diff({\n            query: c.query,\n            variables: c.variables,\n            previousResult: c.previousResult && c.previousResult(),\n            optimistic: c.optimistic,\n        }));\n    };\n    return InMemoryCache;\n}(ApolloCache));\nexport { InMemoryCache };\n//# sourceMappingURL=inMemoryCache.js.map","var testMap = new Map();\nif (testMap.set(1, 2) !== testMap) {\n    var set_1 = testMap.set;\n    Map.prototype.set = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        set_1.apply(this, args);\n        return this;\n    };\n}\nvar testSet = new Set();\nif (testSet.add(3) !== testSet) {\n    var add_1 = testSet.add;\n    Set.prototype.add = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        add_1.apply(this, args);\n        return this;\n    };\n}\nvar frozen = {};\nif (typeof Object.freeze === 'function') {\n    Object.freeze(frozen);\n}\ntry {\n    testMap.set(frozen, frozen).delete(frozen);\n}\ncatch (_a) {\n    var wrap = function (method) {\n        return method && (function (obj) {\n            try {\n                testMap.set(obj, obj).delete(obj);\n            }\n            finally {\n                return method.call(Object, obj);\n            }\n        });\n    };\n    Object.freeze = wrap(Object.freeze);\n    Object.seal = wrap(Object.seal);\n    Object.preventExtensions = wrap(Object.preventExtensions);\n}\n//# sourceMappingURL=fixPolyfills.js.map"],"sourceRoot":""}