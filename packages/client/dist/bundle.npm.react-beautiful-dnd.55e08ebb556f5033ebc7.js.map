{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/react-beautiful-dnd/node_modules/memoize-one/dist/memoize-one.esm.js","webpack:////var/www/html/utter/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js"],"names":["areInputsEqual","newInputs","lastInputs","length","i","memoize_one_esm","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","_len","arguments","newArgs","Array","_key","this","apply","__webpack_require__","d","__webpack_exports__","DragDropContext","ConnectedDraggable","ConnectedDroppable","resetServerContext","shouldRecover","error","message","indexOf","react_beautiful_dnd_esm_ErrorBoundary","_React$Component","ErrorBoundary","_this","args","call","concat","onError","setOnError","fn","onFatalError","setState","Object","inheritsLoose","_proto","prototype","componentDidMount","window","addEventListener","componentWillUnmount","removeEventListener","componentDidCatch","render","props","children","react_default","a","Component","origin","x","y","react_beautiful_dnd_esm_add","point1","point2","subtract","negate","point","react_beautiful_dnd_esm_patch","line","value","otherValue","_ref","distance","Math","sqrt","pow","react_beautiful_dnd_esm_closest","target","points","min","map","offsetByPosition","spacing","top","left","bottom","right","getCorners","react_beautiful_dnd_esm_clip","frame","shouldClipSubject","subject","result","css_box_model_esm","max","width","height","executeClip","pageMarginBox","getSubject","page","withPlaceholder","axis","increased","_extends2","increasedBy","esm_extends","end","react_beautiful_dnd_esm_increase","scroll","diff","displacement","react_beautiful_dnd_esm_scroll","marginBox","active","react_beautiful_dnd_esm_scrollDroppable","droppable","newScroll","tiny_invariant_esm","scrollable","scrollDiff","initial","scrollDisplacement","current","react_beautiful_dnd_esm_start","key","finish","whatIsDraggedOver","impact","merge","destination","droppableId","combine","react_beautiful_dnd_esm_values","values_default","findIndex","list","predicate","find","index","toDroppableMap","droppables","reduce","previous","descriptor","id","toDraggableMap","draggables","toDroppableList","toDraggableList","isWithin","lowerBound","upperBound","isPositionInFrame","isWithinVertical","isWithinHorizontal","getDraggablesInsideDroppable","filter","draggable","sort","b","vertical","direction","crossAxisLine","start","size","crossAxisStart","crossAxisEnd","crossAxisSize","horizontal","isUserMovingForward","didStartDisplaced","draggableId","onLift","Boolean","wasDisplaced","getCombinedItemDisplacement","displaced","combineWith","displacedBy","isDisplaced","getWhenEntered","oldMerge","whenEntered","getCombineImpact","_ref2","currentCenter","pageBorderBoxCenterWithDroppableScrollChange","previousImpact","insideDestinationWithoutDraggable","userDirection","isCombineEnabled","movement","canBeDisplacedBy","child","displaceBy","borderBox","currentUserDirection","twoThirdsOfSize","isMovingForward","targetCenter","isCombiningWith","isPartiallyVisibleThroughFrame","isPartiallyVisibleVertically","isPartiallyVisibleHorizontally","isBiggerVertically","isBiggerHorizontally","isTotallyVisibleThroughFrame","isVisible","toBeDisplaced","viewport","withDroppableDisplacement","isVisibleThroughFrameFn","displacedTarget","getDroppableDisplaced","isVisibleInDroppable","isVisibleInViewport","react_beautiful_dnd_esm_isPartiallyVisible","react_beautiful_dnd_esm_isTotallyVisible","getDisplacement","forceShouldAnimate","expandBy","react_beautiful_dnd_esm_getTarget","shouldAnimate","getShouldAnimate","getDisplacementMap","getDisplacedBy","noMovement","noImpact","removeDraggableFromList","remove","item","getDragImpact","pageBorderBoxCenter","destinationId","maybe","isEnabled","getDroppableOver","insideDestination","withMerge","didStartDisplaced$1","dimension","newIndex","getReorderImpact","getHomeOnLift","home","originallyDisplaced","slice","offsetDraggable","offset$1","offset","initialWindowScroll","client","placeholder","updateDraggables","updatedDroppables","criticalId","unmodifiedExisting","existing","unmodifiedAdditions","additions","removals","addedDraggables","removedDraggables","shifted","forEach","original","toShift","addShift","shift","indexChange","withRemovals","sibling","withAdditions","splice","additionMap","moved","updated","adjustExistingForAdditionsAndRemovals","dragging","adjustAdditionsForCollapsedHome","windowScrollChange","droppableScrollChange","totalChange","adjustAdditionsForScrollChanges","getMaxScroll","scrollHeight","scrollWidth","maxScroll","getDroppableDimension","isFixedOnPage","closest","scrollSize","frameClient","paddingBox","isHomeOf","react_beautiful_dnd_esm_withMaxScroll","react_beautiful_dnd_esm_addPlaceholder","placeholderSize","requiredGrowth","availableSpace","contentBox","needsToGrowBy","sum","getRequiredGrowthForPlaceholder","added","oldFrameMaxScroll","_subject","newFrame","react_beautiful_dnd_esm_removePlaceholder","_subject2","oldMaxScroll","getFrame","patchDroppableMap","recomputePlaceholders","cleaned","last","now","lastDroppable","clearUnusedPlaceholder","isOver","patched","publishWhileDragging","_extends3","state","published","modified","adjusted","provided","raw","old","fresh","oldClient","newClient","oldScrollable","newScrollable","margin","border","padding","withSizeChanged","updateDroppables","dimensions","critical","_getDragPositions","oldInitial","oldCurrent","oldClientBorderBoxCenter","newClientBorderBoxCenter","selection","borderBoxCenter","reverse","getDragPositions","center","_getHomeOnLift","homeImpact","withoutAnimation","withNoAnimatedDisplacement","movementMode","draggingState","phase","onLiftImpact","reason","isWaiting","forward","backward","moveToNextIndex","isInHomeList","instruction","initialInside","location","currentIndex","proposedIndex","modifyDisplacement","fromReorder","combineId","combineIndex","fromCombine","lastDisplaced","add","addClosest","distanceFromStartToBorderBoxCenter","box","getCrossAxisBorderBoxCenter","isMoving","goAfter","moveRelativeTo","goBefore","distanceFromEndToBorderBoxCenter","whenReordering","draggablePage","_ref3","moveInto","goIntoStart","closestAfter","withDisplacement","getResultWithoutDroppableDisplacement","whenCombining","getPageBorderBoxCenterFromImpact","withoutDisplacement","scrollViewport","withNewDisplacement","getClientFromPageBorderBoxCenter","withoutPageScrollChange","withViewportDisplacement","isTotallyVisibleInNewLocation","newPageBorderBoxCenter","_ref$onlyOnMainAxis","onlyOnMainAxis","changeNeeded","react_beautiful_dnd_esm_isTotallyVisibleOnAxis","moveToNextPlace","previousPageBorderBoxCenter","previousClientSelection","originalInsideDestination","shallow","currentInsideDestination","targetIndex","moveToNextCombine","clientSelection","scrollJumpRequest","maxScrollChange","scrolledViewport","scrolledDroppable","entry","withScrolledViewport","withScrolledDroppable","speculativelyIncrease","react_beautiful_dnd_esm_getKnownActive","rect","getCurrentPageBorderBoxCenter","getCurrentPageBorderBox","moveCrossAxis","source","isBetweenSourceClipped","candidates","activeOfTarget","isBetweenDestinationClipped","first","second","array","contains","isWithinDroppable","getBestCrossAxisDroppable","proposed","proposedPageBorderBoxCenter","isGoingBeforeTarget","moveToNewDroppable","distanceToA","distanceToB","getClosestDraggable","moveInDirection","type","isActuallyOver","getDroppableOver$1","isMainAxisMovementAllowed","isMovingOnMainAxis","_state$dimensions","react_beautiful_dnd_esm_isMovementAllowed","getRemainder","getVertical","getHorizontal","react_beautiful_dnd_esm_update","oldPageBorderBoxCenter","forcedClientSelection","forcedDimensions","forcedViewport","forcedImpact","currentWindowScroll","newImpact","withUpdatedPlaceholders","recompute","getClientBorderBoxCenter","refreshSnap","needsVisibilityCheck","isSnapping","postDroppableChange","isEnabledChanging","patchDimensionMap","react_beautiful_dnd_esm_idle","completed","shouldFlush","reducer","action","payload","_action$payload","isWindowScrollAllowed","every","isDragging","_clientSelection","_action$payload2","scrolled","_action$payload3","_id","_target","_action$payload4","_id2","_target2","_updated","_viewport","withMaxScroll","_result2","_action$payload5","dropDuration","newHomeClientOffset","_action$payload6","publishWhileDragging$1","collectionStarting","react_beautiful_dnd_esm_updateDroppableScroll","react_beautiful_dnd_esm_updateDroppableIsEnabled","react_beautiful_dnd_esm_updateDroppableIsCombineEnabled","react_beautiful_dnd_esm_move","clean$1","completeDrop","react_beautiful_dnd_esm_drop","curves","react_beautiful_dnd_esm_combine","drop","combining","outOfTheWayTiming","transitions","fluid","snap","duration","timing","outOfTheWay","moveTo","transforms","isCombining","translate","minDropTime","maxDropTime","dropTimeRange","drop$1","getState","dispatch","next","_getDropImpact","lastImpact","didDropInsideDroppable","getDropImpact","mode","newClientCenter","getNewHomeClientOffset","distance$1","Number","toFixed","getDropDuration","animateDrop","react_beautiful_dnd_esm_dropPending","position","withLocation","startPosition","endPosition","withCombine","returnedToStart","preset","update","getAsyncMarshal","entries","timerId","setTimeout","callback","execute","push","flush","clearTimeout","withTimings","getDragStart","react_beautiful_dnd_esm_execute","responder","data","announce","getDefaultMessage","willExpire","wasCalled","isExpired","timeoutId","getExpiringAnnounce","responders","getResponders","publisher","asyncMarshal","onDragEnd","beforeStart","onBeforeDragStart","lastCritical","lastLocation","lastCombine","onDragStart","hasCriticalChanged","isDraggableEqual","isDroppableEqual","isCriticalEqual","hasLocationChanged","hasGroupingChanged","isCombineEqual","onDragUpdate","abort","getPublisher","store","dropAnimationFinish","pendingDrop","postActionState","composeEnhancers","redux","createStore","marshal","dimensionMarshal","styleMarshal","autoScroller","dropping","resting","stopPublishing","dimensionMarshalStopper","request","scrollOptions","shouldPublishImmediately","_marshal$startPublish","startPublishing","lift$1","shouldEnd","stop","shouldCancelPending","cancelPending","autoScroll","getWindowScroll","pageXOffset","pageYOffset","getDocumentElement","doc","document","documentElement","getMaxWindowScroll","clientWidth","clientHeight","getInitialPublish","windowScroll","callbacks","getDimensionAndWatchScroll","getDimension","react_beautiful_dnd_esm_throwIfAddOrRemoveOfWrongType","collection","createDimensionMarshal","getEntries","advancedUsageWarning","staging","frameId","collect","requestAnimationFrame","getCritical","_staging","keys_default","options","withoutPlaceholder","recollect","publish","cancelAnimationFrame","createPublisher","registerDraggable","updateDraggable","unregisterDraggable","registerDroppable","droppableCallbacks","unregisterDroppable","updateDroppableIsEnabled","updateDroppableIsCombineEnabled","scrollDroppable","change","updateDroppableScroll","dragStopped","canStartDrag","react_beautiful_dnd_esm_scrollWindow","scrollBy","getScrollableDroppables","getBestScrollableDroppable","_dimension","react_beautiful_dnd_esm_getScrollableDroppableOver","config","percentage","stopDampeningAt","accelerateAt","getPercentage","startOfRange","endOfRange","range","stopAt","getValue","distanceToEdge","thresholds","dragStartTime","shouldUseTimeDampening","startScrollingFrom","maxScrollValueAt","percentageFromMaxScrollValueAt","ceil","getValueFromDistance","proposedScroll","runTime","now_default","betweenAccelerateAtAndStopAtPercentage","dampenValueByTime","getScrollOnAxis","container","distanceToEdges","getDistanceThresholds","clean$3","getScroll","required","limited","isTooBigVertically","isTooBigHorizontally","adjustForSizeLimits","smallestSigned","getOverlap","targetScroll","overlap","canPartiallyScroll","rawMax","smallestChange","canScrollWindow","canScrollDroppable","scroll$1","scrollWindow","_change","getWindowScrollChange","getDroppableScrollChange","createJumpScroller","move","scrollDroppableAsMuchAsItCan","getDroppableOverlap","whatTheDroppableCanScroll","scrollWindowAsMuchAsItCan","getWindowOverlap","whatTheWindowCanScroll","droppableRemainder","windowRemainder","moveByOffset","createAutoScroller","fluidScroller","scheduleWindowScroll","raf_schd_esm","scheduleDroppableScroll","tryScroll","_dragging","cancel","wasScrollNeeded","fakeScrollCallback","createFluidScroller","jumpScroll","prefix","react_beautiful_dnd_esm_dragHandle","react_beautiful_dnd_esm_draggable","react_beautiful_dnd_esm_droppable","getStyles","rules","property","rule","styles","selector","join","getStyles$1","uniqueContext","context","grabCursor","transition","getSelector","attribute","dragHandle$1","always","dropAnimating","userCancel","useIsomorphicLayoutEffect","react","react_beautiful_dnd_esm_getHead","head","querySelector","createStyleEl","el","createElement","StoreContext","createContext","getBodyElement","body","visuallyHidden","overflow","clip","clip-path","getId","uniqueId","AppContext","usePrevious","ref","createResponders","getStore","lazyRef","App","lazyStoreRef","lastPropsRef","use_memo_one_esm","setAttribute","assign_default","style","appendChild","toBeRemoved","removeChild","textContent","useAnnouncer","alwaysRef","dynamicRef","setDynamicStyle","setAlwaysStyle","dynamic","styleContext","useStyleMarshal","lazyDispatch","tryResetStore","getCanLift","getIsMovementAllowed","appContext","canLift","isMovementAllowed","Provider","es","instanceCount","isEqual$2","base","isScroll","isAuto","isEither","overflowX","overflowY","isElementScrollable","getComputedStyle","getClosestScrollable","parentElement","getScroll$1","scrollLeft","scrollTop","getEnv","closestScrollable","getIsFixed","react_beautiful_dnd_esm_getDimension","env","isDropDisabled","targetRef","react_beautiful_dnd_esm_getClient","immediate","passive","delayed","getListenerOptions","useRequiredContext","Context","getClosestScrollableFromDrag","noop","empty","getStyle","isAnimatingOpenOnMount","animate","getSize","display","boxSizing","marginTop","marginRight","marginBottom","marginLeft","flexShrink","flexGrow","pointerEvents","Placeholder$1","memo","animateOpenTimerRef","tryClearAnimateOpenTimer","onTransitionEnd","onClose","_useState","setIsAnimatingOpenOnMount","onSizeChangeEnd","event","propertyName","tagName","data-react-beautiful-dnd-placeholder","innerRef","DroppableContext","getWindowFromEl","ownerDocument","defaultView","isHtmlElement","HTMLElement","react_beautiful_dnd_esm_AnimateInOut","_React$PureComponent","AnimateInOut","on","getDerivedStateFromProps","PureComponent","isStrictEqual","whatIsDraggedOverFromResult","isMatchingType","getDraggable","mapDispatchToProps","updateViewportMaxScroll","idle","shouldAnimatePlaceholder","snapshot","isDraggingOver","draggingOverWith","draggingFromThisWith","idleWithoutAnimation","getMapProps","getSnapshot","ownProps","_snapshot","_completed","wasOver","wasCombining","pure","areStatePropsEqual","whileDraggingRef","previousRef","publishedDescriptorRef","memoizedUpdateScroll","getClosestScroll","updateScroll","scheduleScrollUpdate","onClosestScroll","droppableRef","placeholderRef","ignoreContainerClipping","getDroppableRef","getPlaceholderRef","setDroppableRef","setPlaceholderRef","onPlaceholderTransitionEnd","droppableProps","data-react-beautiful-dnd-droppable","droppableContext","defaultProps","zIndexOptions","getDraggingTransition","shouldAnimateDragMovement","getDraggingOpacity","isDropAnimating","getShouldDraggingAnimate","getStyle$1","mapped","transform","opacity","zIndex","secondary","shouldAnimateDisplacement","_preventedKeys","createEventMarshal","isMouseDownHandled","handle","isHandled","reset","react_beautiful_dnd_esm_getOptions","shared","fromBinding","bindEvents","bindings","sharedOptions","binding","eventName","unbindEvents","createScheduler","memoizedMove","onMove","moveUp","onMoveUp","moveDown","onMoveDown","moveRight","onMoveRight","moveLeft","onMoveLeft","windowScrollMove","onWindowScroll","react_beautiful_dnd_esm_escape","space","arrowLeft","arrowUp","arrowRight","arrowDown","supportedEventName","capture","createPostDragEventPreventer","getWindow","isBound","unbind","preventDefault","preventNext","isSloppyClickThresholdExceeded","abs","preventedKeys","preventStandardKeyEvents","keyCode","primaryButton","noop$1","mouseDownMarshal","isElement","Element","_scrollJumpKeys","interactiveTagNames","input","button","textarea","select","option","optgroup","video","audio","shouldAllowDraggingFromTarget","canDragInteractiveElements","currentTarget","isAnInteractiveElement","parent","toLowerCase","getAttribute","getBorderBoxCenterPosition","getBoundingClientRect","scrollJumpKeys","noop$2","timeForLongPress","forcePressThreshold","touchStartMarshal","noop$3","webkitHack","stub","preventTouchMove","releaseTouchMove","isBlocking","defaultPrevented","react_beautiful_dnd_esm_selector","react_beautiful_dnd_esm_throwIfSVG","SVGElement","isSvgElement","react_beautiful_dnd_esm_getDragHandleRef","draggableRef","hasAttribute","onWindowFocusChange","retainingFocusFor","listenerOptions","clearRetentionOnFocusChange","retainer","retain","tryRestoreFocus","dragHandleRef","focus","noop$4","preventHtml5Dnd","useDragHandle","capturingRef","onCaptureStart","onCaptureEnd","abortCapture","_useRequiredContext","getDraggableRef","getShouldRespectForcePress","lastArgsRef","useValidation$1","canStartCapturing","_useFocusRetainer","isFocusedRef","onFocus","onBlur","dragHandle","lastDraggableRef","useFocusRetainer","onMouseDown","pendingRef","isDraggingRef","unbindWindowEventsRef","getIsCapturing","schedule","postDragEventPreventer","shouldBlockClick","wasDragging","onCancel","startDragging","pending","windowBindings","clientX","clientY","onDrop","webkitForce","MouseEvent","WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN","isForcePressing","bindWindowEvents","win","startPendingDrag","ctrlKey","metaKey","shiftKey","altKey","useMouseSensor","onKeyDown","getIsDragging","useKeyboardSensor","onTouchStart","hasMovedRef","postDragClickPreventer","longPressTimerId","_event$touches$","touches","force","touch","useTouchSensor","tabIndex","data-react-beautiful-dnd-drag-handle","aria-roledescription","useDraggableDimensionPublisher","makeDimension","latest","computedStyles","getDimension$1","mapDispatchToProps$1","lift","moveByWindowScroll","dropAnimationFinished","getDraggingSnapshot","draggingOver","dropAnimation","combineTargetFor","getSecondarySnapshot","defaultMapProps","memoizedOffset","getDraggingProps","getSecondaryProps","getSecondaryMovement","ownId","draggingId","isCombinedWith","_mode","_draggingOver","_combineWith","getCombineWithFromResult","curve","scale","draggingSelector","secondarySelector","setRef","getRef","isDragDisabled","shouldRespectForcePress","disableInteractiveElementBlocking","moveUpAction","moveAction","dropAction","moveDownAction","moveRightAction","moveLeftAction","moveByWindowScrollAction","liftAction","dropAnimationFinishedAction","dragHandleProps","onMoveEnd","draggableProps","data-react-beautiful-dnd-draggable"],"mappings":"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","file":"bundle.npm.react-beautiful-dnd.55e08ebb556f5033ebc7.js","sourcesContent":["function areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n\n  for (var i = 0; i < newInputs.length; i++) {\n    if (newInputs[i] !== lastInputs[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction index (resultFn, isEqual) {\n  if (isEqual === void 0) {\n    isEqual = areInputsEqual;\n  }\n\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  var result = function result() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  };\n\n  return result;\n}\n\nexport default index;\n","import _extends from '@babel/runtime-corejs2/helpers/esm/extends';\nimport React, { useLayoutEffect, useEffect, useRef, useContext, useState } from 'react';\nimport { useMemo, useCallback } from 'use-memo-one';\nimport _inheritsLoose from '@babel/runtime-corejs2/helpers/esm/inheritsLoose';\nimport invariant from 'tiny-invariant';\nimport { createStore as createStore$1, applyMiddleware, compose, bindActionCreators } from 'redux';\nimport { Provider, connect } from 'react-redux';\nimport { getRect, expand, offset, withScroll, createBox, getBox, calculateBox } from 'css-box-model';\nimport memoizeOne from 'memoize-one';\nimport _Object$values from '@babel/runtime-corejs2/core-js/object/values';\nimport _Object$keys from '@babel/runtime-corejs2/core-js/object/keys';\nimport _Date$now from '@babel/runtime-corejs2/core-js/date/now';\nimport rafSchd from 'raf-schd';\nimport _Object$assign from '@babel/runtime-corejs2/core-js/object/assign';\nimport _Number$isInteger from '@babel/runtime-corejs2/core-js/number/is-integer';\n\nvar isProduction = process.env.NODE_ENV === 'production';\nvar spacesAndTabs = /[ \\t]{2,}/g;\nvar lineStartWithSpaces = /^[ \\t]*/gm;\n\nvar clean = function clean(value) {\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\n};\n\nvar getDevMessage = function getDevMessage(message) {\n  return clean(\"\\n  %creact-beautiful-dnd\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77\\u200D This is a development only message. It will be removed in production builds.\\n\");\n};\n\nvar getFormattedMessage = function getFormattedMessage(message) {\n  return [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];\n};\nvar isDisabledFlag = '__react-beautiful-dnd-disable-dev-warnings';\nvar warning = function warning(message) {\n  var _console;\n\n  if (isProduction) {\n    return;\n  }\n\n  if (typeof window !== 'undefined' && window[isDisabledFlag]) {\n    return;\n  }\n\n  (_console = console).warn.apply(_console, getFormattedMessage(message));\n};\n\nfunction printFatalError(error) {\n  var _console;\n\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  (_console = console).error.apply(_console, getFormattedMessage(\"\\n        An error has occurred while a drag is occurring.\\n        Any existing drag will be cancelled.\\n\\n        > \" + error.message + \"\\n        \"));\n\n  console.error('raw', error);\n}\n\nfunction shouldRecover(error) {\n  return error.message.indexOf('Invariant failed') !== -1;\n}\n\nvar ErrorBoundary = function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.onError = void 0;\n\n    _this.setOnError = function (fn) {\n      _this.onError = fn;\n    };\n\n    _this.onFatalError = function (error) {\n      printFatalError(error);\n\n      if (_this.onError) {\n        _this.onError();\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning('Could not find recovering function') : void 0;\n      }\n\n      if (shouldRecover(error)) {\n        _this.setState({});\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    window.addEventListener('error', this.onFatalError);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    window.removeEventListener('error', this.onFatalError);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error) {\n    this.onFatalError(error);\n\n    if (!shouldRecover(error)) {\n      throw error;\n    }\n  };\n\n  _proto.render = function render() {\n    return this.props.children(this.setOnError);\n  };\n\n  return ErrorBoundary;\n}(React.Component);\n\nvar origin = {\n  x: 0,\n  y: 0\n};\nvar add = function add(point1, point2) {\n  return {\n    x: point1.x + point2.x,\n    y: point1.y + point2.y\n  };\n};\nvar subtract = function subtract(point1, point2) {\n  return {\n    x: point1.x - point2.x,\n    y: point1.y - point2.y\n  };\n};\nvar isEqual = function isEqual(point1, point2) {\n  return point1.x === point2.x && point1.y === point2.y;\n};\nvar negate = function negate(point) {\n  return {\n    x: point.x !== 0 ? -point.x : 0,\n    y: point.y !== 0 ? -point.y : 0\n  };\n};\nvar patch = function patch(line, value, otherValue) {\n  var _ref;\n\n  if (otherValue === void 0) {\n    otherValue = 0;\n  }\n\n  return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;\n};\nvar distance = function distance(point1, point2) {\n  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n};\nvar closest = function closest(target, points) {\n  return Math.min.apply(Math, points.map(function (point) {\n    return distance(target, point);\n  }));\n};\nvar apply = function apply(fn) {\n  return function (point) {\n    return {\n      x: fn(point.x),\n      y: fn(point.y)\n    };\n  };\n};\n\nvar executeClip = (function (frame, subject) {\n  var result = getRect({\n    top: Math.max(subject.top, frame.top),\n    right: Math.min(subject.right, frame.right),\n    bottom: Math.min(subject.bottom, frame.bottom),\n    left: Math.max(subject.left, frame.left)\n  });\n\n  if (result.width <= 0 || result.height <= 0) {\n    return null;\n  }\n\n  return result;\n});\n\nvar isEqual$1 = function isEqual(first, second) {\n  return first.top === second.top && first.right === second.right && first.bottom === second.bottom && first.left === second.left;\n};\nvar offsetByPosition = function offsetByPosition(spacing, point) {\n  return {\n    top: spacing.top + point.y,\n    left: spacing.left + point.x,\n    bottom: spacing.bottom + point.y,\n    right: spacing.right + point.x\n  };\n};\nvar getCorners = function getCorners(spacing) {\n  return [{\n    x: spacing.left,\n    y: spacing.top\n  }, {\n    x: spacing.right,\n    y: spacing.top\n  }, {\n    x: spacing.left,\n    y: spacing.bottom\n  }, {\n    x: spacing.right,\n    y: spacing.bottom\n  }];\n};\nvar noSpacing = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n};\n\nvar scroll = function scroll(target, frame) {\n  if (!frame) {\n    return target;\n  }\n\n  return offsetByPosition(target, frame.scroll.diff.displacement);\n};\n\nvar increase = function increase(target, axis, withPlaceholder) {\n  if (withPlaceholder && withPlaceholder.increasedBy) {\n    var _extends2;\n\n    return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));\n  }\n\n  return target;\n};\n\nvar clip = function clip(target, frame) {\n  if (frame && frame.shouldClipSubject) {\n    return executeClip(frame.pageMarginBox, target);\n  }\n\n  return getRect(target);\n};\n\nvar getSubject = (function (_ref) {\n  var page = _ref.page,\n      withPlaceholder = _ref.withPlaceholder,\n      axis = _ref.axis,\n      frame = _ref.frame;\n  var scrolled = scroll(page.marginBox, frame);\n  var increased = increase(scrolled, axis, withPlaceholder);\n  var clipped = clip(increased, frame);\n  return {\n    page: page,\n    withPlaceholder: withPlaceholder,\n    active: clipped\n  };\n});\n\nvar scrollDroppable = (function (droppable, newScroll) {\n  !droppable.frame ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var scrollable = droppable.frame;\n  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n  var scrollDisplacement = negate(scrollDiff);\n\n  var frame = _extends({}, scrollable, {\n    scroll: {\n      initial: scrollable.scroll.initial,\n      current: newScroll,\n      diff: {\n        value: scrollDiff,\n        displacement: scrollDisplacement\n      },\n      max: scrollable.scroll.max\n    }\n  });\n\n  var subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: droppable.subject.withPlaceholder,\n    axis: droppable.axis,\n    frame: frame\n  });\n\n  var result = _extends({}, droppable, {\n    frame: frame,\n    subject: subject\n  });\n\n  return result;\n});\n\nvar records = {};\nvar isEnabled = false;\n\nvar isTimingsEnabled = function isTimingsEnabled() {\n  return isEnabled;\n};\nvar start = function start(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isTimingsEnabled()) {\n      return;\n    }\n\n    var now = performance.now();\n    records[key] = now;\n  }\n};\nvar finish = function finish(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isTimingsEnabled()) {\n      return;\n    }\n\n    var now = performance.now();\n    var previous = records[key];\n\n    if (!previous) {\n      console.warn('cannot finish timing as no previous time found', key);\n      return;\n    }\n\n    var result = now - previous;\n    var rounded = result.toFixed(2);\n\n    var style = function () {\n      if (result < 12) {\n        return {\n          textColor: 'green',\n          symbol: '✅'\n        };\n      }\n\n      if (result < 40) {\n        return {\n          textColor: 'orange',\n          symbol: '⚠️'\n        };\n      }\n\n      return {\n        textColor: 'red',\n        symbol: '❌'\n      };\n    }();\n\n    console.log(style.symbol + \" %cTiming %c\" + rounded + \" %cms %c\" + key, 'color: blue; font-weight: bold;', \"color: \" + style.textColor + \"; font-size: 1.1em;\", 'color: grey;', 'color: purple; font-weight: bold;');\n  }\n};\n\nvar whatIsDraggedOver = (function (impact) {\n  var merge = impact.merge,\n      destination = impact.destination;\n\n  if (destination) {\n    return destination.droppableId;\n  }\n\n  if (merge) {\n    return merge.combine.droppableId;\n  }\n\n  return null;\n});\n\nfunction values(map) {\n  return _Object$values(map);\n}\nfunction findIndex(list, predicate) {\n  if (list.findIndex) {\n    return list.findIndex(predicate);\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (predicate(list[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n}\nfunction find(list, predicate) {\n  if (list.find) {\n    return list.find(predicate);\n  }\n\n  var index = findIndex(list, predicate);\n\n  if (index !== -1) {\n    return list[index];\n  }\n\n  return undefined;\n}\n\nvar toDroppableMap = memoizeOne(function (droppables) {\n  return droppables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDraggableMap = memoizeOne(function (draggables) {\n  return draggables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDroppableList = memoizeOne(function (droppables) {\n  return values(droppables);\n});\nvar toDraggableList = memoizeOne(function (draggables) {\n  return values(draggables);\n});\n\nvar isWithin = (function (lowerBound, upperBound) {\n  return function (value) {\n    return lowerBound <= value && value <= upperBound;\n  };\n});\n\nvar isPositionInFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (point) {\n    return isWithinVertical(point.y) && isWithinVertical(point.y) && isWithinHorizontal(point.x) && isWithinHorizontal(point.x);\n  };\n});\n\nvar getDroppableOver = (function (_ref) {\n  var target = _ref.target,\n      droppables = _ref.droppables;\n  var maybe = find(toDroppableList(droppables), function (droppable) {\n    if (!droppable.isEnabled) {\n      return false;\n    }\n\n    var active = droppable.subject.active;\n\n    if (!active) {\n      return false;\n    }\n\n    return isPositionInFrame(active)(target);\n  });\n  return maybe ? maybe.descriptor.id : null;\n});\n\nvar getDraggablesInsideDroppable = memoizeOne(function (droppableId, draggables) {\n  var result = toDraggableList(draggables).filter(function (draggable) {\n    return droppableId === draggable.descriptor.droppableId;\n  }).sort(function (a, b) {\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return result;\n});\n\nvar withDroppableScroll = (function (droppable, point) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return point;\n  }\n\n  return add(point, frame.scroll.diff.value);\n});\n\nvar vertical = {\n  direction: 'vertical',\n  line: 'y',\n  crossAxisLine: 'x',\n  start: 'top',\n  end: 'bottom',\n  size: 'height',\n  crossAxisStart: 'left',\n  crossAxisEnd: 'right',\n  crossAxisSize: 'width'\n};\nvar horizontal = {\n  direction: 'horizontal',\n  line: 'x',\n  crossAxisLine: 'y',\n  start: 'left',\n  end: 'right',\n  size: 'width',\n  crossAxisStart: 'top',\n  crossAxisEnd: 'bottom',\n  crossAxisSize: 'height'\n};\n\nvar isUserMovingForward = (function (axis, direction) {\n  return axis === vertical ? direction.vertical === 'down' : direction.horizontal === 'right';\n});\n\nvar didStartDisplaced = (function (draggableId, onLift) {\n  return Boolean(onLift.wasDisplaced[draggableId]);\n});\n\nvar getCombinedItemDisplacement = (function (_ref) {\n  var displaced = _ref.displaced,\n      onLift = _ref.onLift,\n      combineWith = _ref.combineWith,\n      displacedBy = _ref.displacedBy;\n  var isDisplaced = Boolean(displaced[combineWith]);\n\n  if (didStartDisplaced(combineWith, onLift)) {\n    return isDisplaced ? origin : negate(displacedBy.point);\n  }\n\n  return isDisplaced ? displacedBy.point : origin;\n});\n\nvar getWhenEntered = function getWhenEntered(id, current, oldMerge) {\n  if (!oldMerge) {\n    return current;\n  }\n\n  if (id !== oldMerge.combine.draggableId) {\n    return current;\n  }\n\n  return oldMerge.whenEntered;\n};\n\nvar isCombiningWith = function isCombiningWith(_ref) {\n  var id = _ref.id,\n      currentCenter = _ref.currentCenter,\n      axis = _ref.axis,\n      borderBox = _ref.borderBox,\n      displaceBy = _ref.displaceBy,\n      currentUserDirection = _ref.currentUserDirection,\n      oldMerge = _ref.oldMerge;\n  var start = borderBox[axis.start] + displaceBy[axis.line];\n  var end = borderBox[axis.end] + displaceBy[axis.line];\n  var size = borderBox[axis.size];\n  var twoThirdsOfSize = size * 0.666;\n  var whenEntered = getWhenEntered(id, currentUserDirection, oldMerge);\n  var isMovingForward = isUserMovingForward(axis, whenEntered);\n  var targetCenter = currentCenter[axis.line];\n\n  if (isMovingForward) {\n    return isWithin(start, start + twoThirdsOfSize)(targetCenter);\n  }\n\n  return isWithin(end - twoThirdsOfSize, end)(targetCenter);\n};\n\nvar getCombineImpact = (function (_ref2) {\n  var currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\n      previousImpact = _ref2.previousImpact,\n      destination = _ref2.destination,\n      insideDestinationWithoutDraggable = _ref2.insideDestinationWithoutDraggable,\n      userDirection = _ref2.userDirection,\n      onLift = _ref2.onLift;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var axis = destination.axis;\n  var map = previousImpact.movement.map;\n  var canBeDisplacedBy = previousImpact.movement.displacedBy;\n  var oldMerge = previousImpact.merge;\n  var target = find(insideDestinationWithoutDraggable, function (child) {\n    var id = child.descriptor.id;\n    var displaceBy = getCombinedItemDisplacement({\n      displaced: map,\n      onLift: onLift,\n      combineWith: id,\n      displacedBy: canBeDisplacedBy\n    });\n    return isCombiningWith({\n      id: id,\n      currentCenter: currentCenter,\n      axis: axis,\n      borderBox: child.page.borderBox,\n      displaceBy: displaceBy,\n      currentUserDirection: userDirection,\n      oldMerge: oldMerge\n    });\n  });\n\n  if (!target) {\n    return null;\n  }\n\n  var merge = {\n    whenEntered: getWhenEntered(target.descriptor.id, userDirection, oldMerge),\n    combine: {\n      draggableId: target.descriptor.id,\n      droppableId: destination.descriptor.id\n    }\n  };\n\n  var withMerge = _extends({}, previousImpact, {\n    destination: null,\n    merge: merge\n  });\n\n  return withMerge;\n});\n\nvar isPartiallyVisibleThroughFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n\n    if (isContained) {\n      return true;\n    }\n\n    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n\n    if (isPartiallyContained) {\n      return true;\n    }\n\n    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n\n    if (isTargetBiggerThanFrame) {\n      return true;\n    }\n\n    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n    return isTargetBiggerOnOneAxis;\n  };\n});\n\nvar isTotallyVisibleThroughFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    return isContained;\n  };\n});\n\nvar isTotallyVisibleThroughFrameOnAxis = (function (axis) {\n  return function (frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function (subject) {\n      if (axis === vertical) {\n        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n      }\n\n      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    };\n  };\n});\n\nvar getDroppableDisplaced = function getDroppableDisplaced(target, destination) {\n  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n  return offsetByPosition(target, displacement);\n};\n\nvar isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {\n  if (!destination.subject.active) {\n    return false;\n  }\n\n  return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\n\nvar isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {\n  return isVisibleThroughFrameFn(viewport)(target);\n};\n\nvar isVisible = function isVisible(_ref) {\n  var toBeDisplaced = _ref.target,\n      destination = _ref.destination,\n      viewport = _ref.viewport,\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\n      isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\n  var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\n\nvar isPartiallyVisible = function isPartiallyVisible(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n  }));\n};\nvar isTotallyVisible = function isTotallyVisible(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n  }));\n};\nvar isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n  }));\n};\n\nvar getShouldAnimate = function getShouldAnimate(forceShouldAnimate, isVisible, previous) {\n  if (typeof forceShouldAnimate === 'boolean') {\n    return forceShouldAnimate;\n  }\n\n  if (!isVisible) {\n    return false;\n  }\n\n  if (!previous) {\n    return true;\n  }\n\n  return previous.shouldAnimate;\n};\n\nvar getTarget = function getTarget(draggable, onLift) {\n  var marginBox = draggable.page.marginBox;\n\n  if (!didStartDisplaced(draggable.descriptor.id, onLift)) {\n    return marginBox;\n  }\n\n  var expandBy = {\n    top: onLift.displacedBy.point.y,\n    right: onLift.displacedBy.point.x,\n    bottom: 0,\n    left: 0\n  };\n  return getRect(expand(marginBox, expandBy));\n};\n\nvar getDisplacement = (function (_ref) {\n  var draggable = _ref.draggable,\n      destination = _ref.destination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      onLift = _ref.onLift,\n      forceShouldAnimate = _ref.forceShouldAnimate;\n  var id = draggable.descriptor.id;\n  var map = previousImpact.movement.map;\n  var target = getTarget(draggable, onLift);\n  var isVisible = isPartiallyVisible({\n    target: target,\n    destination: destination,\n    viewport: viewport,\n    withDroppableDisplacement: true\n  });\n  var shouldAnimate = getShouldAnimate(forceShouldAnimate, isVisible, map[id]);\n  var displacement = {\n    draggableId: id,\n    isVisible: isVisible,\n    shouldAnimate: shouldAnimate\n  };\n  return displacement;\n});\n\nvar getDisplacementMap = memoizeOne(function (displaced) {\n  return displaced.reduce(function (map, displacement) {\n    map[displacement.draggableId] = displacement;\n    return map;\n  }, {});\n});\n\nvar getDisplacedBy = memoizeOne(function (axis, displaceBy) {\n  var displacement = displaceBy[axis.line];\n  return {\n    value: displacement,\n    point: patch(axis.line, displacement)\n  };\n});\n\nvar getReorderImpact = (function (_ref) {\n  var currentCenter = _ref.pageBorderBoxCenterWithDroppableScrollChange,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      insideDestinationWithoutDraggable = _ref.insideDestinationWithoutDraggable,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      userDirection = _ref.userDirection,\n      onLift = _ref.onLift;\n  var axis = destination.axis;\n  var isMovingForward = isUserMovingForward(destination.axis, userDirection);\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  var targetCenter = currentCenter[axis.line];\n  var displacement = displacedBy.value;\n  var displaced = insideDestinationWithoutDraggable.filter(function (child) {\n    var borderBox = child.page.borderBox;\n    var start = borderBox[axis.start];\n    var end = borderBox[axis.end];\n    var didStartDisplaced$1 = didStartDisplaced(child.descriptor.id, onLift);\n\n    if (isMovingForward) {\n      if (didStartDisplaced$1) {\n        return targetCenter < start;\n      }\n\n      return targetCenter < start + displacement;\n    }\n\n    if (didStartDisplaced$1) {\n      return targetCenter <= end - displacement;\n    }\n\n    return targetCenter <= end;\n  }).map(function (dimension) {\n    return getDisplacement({\n      draggable: dimension,\n      destination: destination,\n      previousImpact: previousImpact,\n      viewport: viewport.frame,\n      onLift: onLift\n    });\n  });\n  var newIndex = insideDestinationWithoutDraggable.length - displaced.length;\n  var movement = {\n    displacedBy: displacedBy,\n    displaced: displaced,\n    map: getDisplacementMap(displaced)\n  };\n  var impact = {\n    movement: movement,\n    destination: {\n      droppableId: destination.descriptor.id,\n      index: newIndex\n    },\n    merge: null\n  };\n  return impact;\n});\n\nvar noDisplacedBy = {\n  point: origin,\n  value: 0\n};\nvar noMovement = {\n  displaced: [],\n  map: {},\n  displacedBy: noDisplacedBy\n};\nvar noImpact = {\n  movement: noMovement,\n  destination: null,\n  merge: null\n};\n\nvar removeDraggableFromList = memoizeOne(function (remove, list) {\n  return list.filter(function (item) {\n    return item.descriptor.id !== remove.descriptor.id;\n  });\n});\n\nvar getDragImpact = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      userDirection = _ref.userDirection,\n      onLift = _ref.onLift;\n  var destinationId = getDroppableOver({\n    target: pageBorderBoxCenter,\n    droppables: droppables\n  });\n\n  if (!destinationId) {\n    return noImpact;\n  }\n\n  var destination = droppables[destinationId];\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var insideDestinationWithoutDraggable = removeDraggableFromList(draggable, insideDestination);\n  var pageBorderBoxCenterWithDroppableScrollChange = withDroppableScroll(destination, pageBorderBoxCenter);\n  var withMerge = getCombineImpact({\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\n    previousImpact: previousImpact,\n    destination: destination,\n    insideDestinationWithoutDraggable: insideDestinationWithoutDraggable,\n    userDirection: userDirection,\n    onLift: onLift\n  });\n\n  if (withMerge) {\n    return withMerge;\n  }\n\n  return getReorderImpact({\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\n    destination: destination,\n    draggable: draggable,\n    insideDestinationWithoutDraggable: insideDestinationWithoutDraggable,\n    previousImpact: previousImpact,\n    viewport: viewport,\n    userDirection: userDirection,\n    onLift: onLift\n  });\n});\n\nvar getHomeLocation = (function (descriptor) {\n  return {\n    index: descriptor.index,\n    droppableId: descriptor.droppableId\n  };\n});\n\nvar getHomeOnLift = (function (_ref) {\n  var draggable = _ref.draggable,\n      home = _ref.home,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport;\n  var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n  var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n  var originallyDisplaced = insideHome.slice(draggable.descriptor.index + 1);\n  var wasDisplaced = originallyDisplaced.reduce(function (previous, item) {\n    previous[item.descriptor.id] = true;\n    return previous;\n  }, {});\n  var onLift = {\n    displacedBy: displacedBy,\n    wasDisplaced: wasDisplaced\n  };\n  var displaced = originallyDisplaced.map(function (dimension) {\n    return getDisplacement({\n      draggable: dimension,\n      destination: home,\n      previousImpact: noImpact,\n      viewport: viewport.frame,\n      forceShouldAnimate: false,\n      onLift: onLift\n    });\n  });\n  var movement = {\n    displaced: displaced,\n    map: getDisplacementMap(displaced),\n    displacedBy: displacedBy\n  };\n  var impact = {\n    movement: movement,\n    destination: getHomeLocation(draggable.descriptor),\n    merge: null\n  };\n  return {\n    impact: impact,\n    onLift: onLift\n  };\n});\n\nvar getDragPositions = (function (_ref) {\n  var oldInitial = _ref.initial,\n      oldCurrent = _ref.current,\n      oldClientBorderBoxCenter = _ref.oldClientBorderBoxCenter,\n      newClientBorderBoxCenter = _ref.newClientBorderBoxCenter,\n      viewport = _ref.viewport;\n  var shift = subtract(newClientBorderBoxCenter, oldClientBorderBoxCenter);\n\n  var initial = function () {\n    var client = {\n      selection: add(oldInitial.client.selection, shift),\n      borderBoxCenter: newClientBorderBoxCenter,\n      offset: origin\n    };\n    var page = {\n      selection: add(client.selection, viewport.scroll.initial),\n      borderBoxCenter: add(client.selection, viewport.scroll.initial)\n    };\n    return {\n      client: client,\n      page: page\n    };\n  }();\n\n  var current = function () {\n    var reverse = negate(shift);\n    var offset = add(oldCurrent.client.offset, reverse);\n    var client = {\n      selection: add(initial.client.selection, offset),\n      borderBoxCenter: add(initial.client.borderBoxCenter, offset),\n      offset: offset\n    };\n    var page = {\n      selection: add(client.selection, viewport.scroll.current),\n      borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current)\n    };\n    !isEqual(oldCurrent.client.borderBoxCenter, client.borderBoxCenter) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"\\n        Incorrect new client center position.\\n        Expected (\" + oldCurrent.client.borderBoxCenter.x + \", \" + oldCurrent.client.borderBoxCenter.y + \")\\n        to equal (\" + client.borderBoxCenter.x + \", \" + client.borderBoxCenter.y + \")\\n      \") : invariant(false) : void 0;\n    return {\n      client: client,\n      page: page\n    };\n  }();\n\n  return {\n    current: current,\n    initial: initial\n  };\n});\n\nvar offsetDraggable = (function (_ref) {\n  var draggable = _ref.draggable,\n      offset$1 = _ref.offset,\n      initialWindowScroll = _ref.initialWindowScroll;\n  var client = offset(draggable.client, offset$1);\n  var page = withScroll(client, initialWindowScroll);\n\n  var moved = _extends({}, draggable, {\n    placeholder: _extends({}, draggable.placeholder, {\n      client: client\n    }),\n    client: client,\n    page: page\n  });\n\n  return moved;\n});\n\nvar adjustExistingForAdditionsAndRemovals = (function (_ref) {\n  var existing = _ref.existing,\n      droppables = _ref.droppables,\n      addedDraggables = _ref.additions,\n      removedDraggables = _ref.removals,\n      viewport = _ref.viewport;\n  var shifted = {};\n  toDroppableList(droppables).forEach(function (droppable) {\n    var axis = droppable.axis;\n    var original = getDraggablesInsideDroppable(droppable.descriptor.id, existing);\n    var toShift = {};\n\n    var addShift = function addShift(id, shift) {\n      var previous = toShift[id];\n\n      if (!previous) {\n        toShift[id] = shift;\n        return;\n      }\n\n      toShift[id] = {\n        indexChange: previous.indexChange + shift.indexChange,\n        offset: add(previous.offset, shift.offset)\n      };\n    };\n\n    var removals = toDraggableMap(removedDraggables.map(function (id) {\n      var item = existing[id];\n      !item ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Could not find removed draggable \\\"\" + id + \"\\\"\") : invariant(false) : void 0;\n      return item;\n    }).filter(function (draggable) {\n      return draggable.descriptor.droppableId === droppable.descriptor.id;\n    }));\n    var withRemovals = original.filter(function (item, index) {\n      var isBeingRemoved = Boolean(removals[item.descriptor.id]);\n\n      if (!isBeingRemoved) {\n        return true;\n      }\n\n      var offset = negate(patch(axis.line, item.displaceBy[axis.line]));\n      original.slice(index).forEach(function (sibling) {\n        if (removals[sibling.descriptor.id]) {\n          return;\n        }\n\n        addShift(sibling.descriptor.id, {\n          indexChange: -1,\n          offset: offset\n        });\n      });\n      return false;\n    });\n    var additions = addedDraggables.filter(function (draggable) {\n      return draggable.descriptor.droppableId === droppable.descriptor.id;\n    });\n    var withAdditions = withRemovals.slice(0);\n    additions.forEach(function (item) {\n      withAdditions.splice(item.descriptor.index, 0, item);\n    });\n    var additionMap = toDraggableMap(additions);\n    withAdditions.forEach(function (item, index) {\n      var wasAdded = Boolean(additionMap[item.descriptor.id]);\n\n      if (!wasAdded) {\n        return;\n      }\n\n      var offset = patch(axis.line, item.client.marginBox[axis.size]);\n      withAdditions.slice(index).forEach(function (sibling) {\n        if (additionMap[sibling.descriptor.id]) {\n          return;\n        }\n\n        addShift(sibling.descriptor.id, {\n          indexChange: 1,\n          offset: offset\n        });\n      });\n    });\n    withAdditions.forEach(function (item) {\n      if (additionMap[item.descriptor.id]) {\n        return;\n      }\n\n      var shift = toShift[item.descriptor.id];\n\n      if (!shift) {\n        return;\n      }\n\n      var moved = offsetDraggable({\n        draggable: item,\n        offset: shift.offset,\n        initialWindowScroll: viewport.scroll.initial\n      });\n      var index = item.descriptor.index + shift.indexChange;\n\n      var updated = _extends({}, moved, {\n        descriptor: _extends({}, item.descriptor, {\n          index: index\n        })\n      });\n\n      shifted[moved.descriptor.id] = updated;\n    });\n  });\n\n  var map = _extends({}, existing, shifted);\n\n  return map;\n});\n\nvar adjustAdditionsForScrollChanges = (function (_ref) {\n  var additions = _ref.additions,\n      updatedDroppables = _ref.updatedDroppables,\n      viewport = _ref.viewport;\n  var windowScrollChange = viewport.scroll.diff.value;\n  return additions.map(function (draggable) {\n    var droppableId = draggable.descriptor.droppableId;\n    var modified = updatedDroppables[droppableId];\n    var frame = modified.frame;\n    !frame ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n    var droppableScrollChange = frame.scroll.diff.value;\n    var totalChange = add(windowScrollChange, droppableScrollChange);\n    var moved = offsetDraggable({\n      draggable: draggable,\n      offset: totalChange,\n      initialWindowScroll: viewport.scroll.initial\n    });\n    return moved;\n  });\n});\n\nvar adjustAdditionsForCollapsedHome = (function (_ref) {\n  var additions = _ref.additions,\n      dragging = _ref.dragging,\n      home = _ref.home,\n      viewport = _ref.viewport;\n  var displacedBy = getDisplacedBy(home.axis, dragging.displaceBy);\n  return additions.map(function (draggable) {\n    if (draggable.descriptor.droppableId !== home.descriptor.id) {\n      return draggable;\n    }\n\n    if (draggable.descriptor.index < dragging.descriptor.index) {\n      return draggable;\n    }\n\n    return offsetDraggable({\n      draggable: draggable,\n      offset: displacedBy.point,\n      initialWindowScroll: viewport.scroll.initial\n    });\n  });\n});\n\nvar updateDraggables = (function (_ref) {\n  var updatedDroppables = _ref.updatedDroppables,\n      criticalId = _ref.criticalId,\n      unmodifiedExisting = _ref.existing,\n      unmodifiedAdditions = _ref.additions,\n      removals = _ref.removals,\n      viewport = _ref.viewport;\n  var existing = adjustExistingForAdditionsAndRemovals({\n    droppables: updatedDroppables,\n    existing: unmodifiedExisting,\n    additions: unmodifiedAdditions,\n    removals: removals,\n    viewport: viewport\n  });\n  var dragging = existing[criticalId];\n  var home = updatedDroppables[dragging.descriptor.droppableId];\n  var scrolledAdditions = adjustAdditionsForScrollChanges({\n    additions: unmodifiedAdditions,\n    updatedDroppables: updatedDroppables,\n    viewport: viewport\n  });\n  var additions = adjustAdditionsForCollapsedHome({\n    additions: scrolledAdditions,\n    dragging: dragging,\n    home: home,\n    viewport: viewport\n  });\n\n  var map = _extends({}, existing, toDraggableMap(additions));\n\n  removals.forEach(function (id) {\n    delete map[id];\n  });\n  return map;\n});\n\nvar getMaxScroll = (function (_ref) {\n  var scrollHeight = _ref.scrollHeight,\n      scrollWidth = _ref.scrollWidth,\n      height = _ref.height,\n      width = _ref.width;\n  var maxScroll = subtract({\n    x: scrollWidth,\n    y: scrollHeight\n  }, {\n    x: width,\n    y: height\n  });\n  var adjustedMaxScroll = {\n    x: Math.max(0, maxScroll.x),\n    y: Math.max(0, maxScroll.y)\n  };\n  return adjustedMaxScroll;\n});\n\nvar getDroppableDimension = (function (_ref) {\n  var descriptor = _ref.descriptor,\n      isEnabled = _ref.isEnabled,\n      isCombineEnabled = _ref.isCombineEnabled,\n      isFixedOnPage = _ref.isFixedOnPage,\n      direction = _ref.direction,\n      client = _ref.client,\n      page = _ref.page,\n      closest = _ref.closest;\n\n  var frame = function () {\n    if (!closest) {\n      return null;\n    }\n\n    var scrollSize = closest.scrollSize,\n        frameClient = closest.client;\n    var maxScroll = getMaxScroll({\n      scrollHeight: scrollSize.scrollHeight,\n      scrollWidth: scrollSize.scrollWidth,\n      height: frameClient.paddingBox.height,\n      width: frameClient.paddingBox.width\n    });\n    return {\n      pageMarginBox: closest.page.marginBox,\n      frameClient: frameClient,\n      scrollSize: scrollSize,\n      shouldClipSubject: closest.shouldClipSubject,\n      scroll: {\n        initial: closest.scroll,\n        current: closest.scroll,\n        max: maxScroll,\n        diff: {\n          value: origin,\n          displacement: origin\n        }\n      }\n    };\n  }();\n\n  var axis = direction === 'vertical' ? vertical : horizontal;\n  var subject = getSubject({\n    page: page,\n    withPlaceholder: null,\n    axis: axis,\n    frame: frame\n  });\n  var dimension = {\n    descriptor: descriptor,\n    isCombineEnabled: isCombineEnabled,\n    isFixedOnPage: isFixedOnPage,\n    axis: axis,\n    isEnabled: isEnabled,\n    client: client,\n    page: page,\n    frame: frame,\n    subject: subject\n  };\n  return dimension;\n});\n\nvar isHomeOf = (function (draggable, destination) {\n  return draggable.descriptor.droppableId === destination.descriptor.id;\n});\n\nvar getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {\n  var axis = droppable.axis;\n  var availableSpace = droppable.subject.page.contentBox[axis.size];\n  var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  var spaceUsed = insideDroppable.reduce(function (sum, dimension) {\n    return sum + dimension.client.marginBox[axis.size];\n  }, 0);\n  var requiredSpace = spaceUsed + placeholderSize[axis.line];\n  var needsToGrowBy = requiredSpace - availableSpace;\n\n  if (needsToGrowBy <= 0) {\n    return null;\n  }\n\n  return patch(axis.line, needsToGrowBy);\n};\n\nvar withMaxScroll = function withMaxScroll(frame, max) {\n  return _extends({}, frame, {\n    scroll: _extends({}, frame.scroll, {\n      max: max\n    })\n  });\n};\n\nvar addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {\n  var frame = droppable.frame;\n  !!isHomeOf(draggable, droppable) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not add placeholder space to home list') : invariant(false) : void 0;\n  !!droppable.subject.withPlaceholder ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : invariant(false) : void 0;\n  var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n  var added = {\n    placeholderSize: placeholderSize,\n    increasedBy: requiredGrowth,\n    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n  };\n\n  if (!frame) {\n    var _subject = getSubject({\n      page: droppable.subject.page,\n      withPlaceholder: added,\n      axis: droppable.axis,\n      frame: droppable.frame\n    });\n\n    return _extends({}, droppable, {\n      subject: _subject\n    });\n  }\n\n  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n  var newFrame = withMaxScroll(frame, maxScroll);\n  var subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: added,\n    axis: droppable.axis,\n    frame: newFrame\n  });\n  return _extends({}, droppable, {\n    subject: subject,\n    frame: newFrame\n  });\n};\nvar removePlaceholder = function removePlaceholder(droppable) {\n  var added = droppable.subject.withPlaceholder;\n  !added ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot remove placeholder form subject when there was none') : invariant(false) : void 0;\n  var frame = droppable.frame;\n\n  if (!frame) {\n    var _subject2 = getSubject({\n      page: droppable.subject.page,\n      axis: droppable.axis,\n      frame: null,\n      withPlaceholder: null\n    });\n\n    return _extends({}, droppable, {\n      subject: _subject2\n    });\n  }\n\n  var oldMaxScroll = added.oldFrameMaxScroll;\n  !oldMaxScroll ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : invariant(false) : void 0;\n  var newFrame = withMaxScroll(frame, oldMaxScroll);\n  var subject = getSubject({\n    page: droppable.subject.page,\n    axis: droppable.axis,\n    frame: newFrame,\n    withPlaceholder: null\n  });\n  return _extends({}, droppable, {\n    subject: subject,\n    frame: newFrame\n  });\n};\n\nvar getFrame = (function (droppable) {\n  var frame = droppable.frame;\n  !frame ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected Droppable to have a frame') : invariant(false) : void 0;\n  return frame;\n});\n\nvar throwIfSpacingChange = function throwIfSpacingChange(old, fresh) {\n  if (process.env.NODE_ENV !== 'production') {\n    var getMessage = function getMessage(spacingType) {\n      return \"Cannot change the \" + spacingType + \" of a Droppable during a drag\";\n    };\n\n    !isEqual$1(old.margin, fresh.margin) ? process.env.NODE_ENV !== \"production\" ? invariant(false, getMessage('margin')) : invariant(false) : void 0;\n    !isEqual$1(old.border, fresh.border) ? process.env.NODE_ENV !== \"production\" ? invariant(false, getMessage('border')) : invariant(false) : void 0;\n    !isEqual$1(old.padding, fresh.padding) ? process.env.NODE_ENV !== \"production\" ? invariant(false, getMessage('padding')) : invariant(false) : void 0;\n  }\n};\n\nvar adjustBorderBoxSize = function adjustBorderBoxSize(axis, old, fresh) {\n  return {\n    top: old.top,\n    left: old.left,\n    right: old.left + fresh.width,\n    bottom: old.top + fresh.height\n  };\n};\n\nvar updateDroppables = (function (_ref) {\n  var modified = _ref.modified,\n      existing = _ref.existing,\n      viewport = _ref.viewport;\n\n  if (!modified.length) {\n    return existing;\n  }\n\n  var adjusted = modified.map(function (provided) {\n    var raw = existing[provided.descriptor.id];\n    !raw ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not locate droppable in existing droppables') : invariant(false) : void 0;\n    var hasPlaceholder = Boolean(raw.subject.withPlaceholder);\n    var dimension = hasPlaceholder ? removePlaceholder(raw) : raw;\n    var oldClient = dimension.client;\n    var newClient = provided.client;\n    var oldScrollable = getFrame(dimension);\n    var newScrollable = getFrame(provided);\n\n    if (process.env.NODE_ENV !== 'production') {\n      throwIfSpacingChange(dimension.client, provided.client);\n      throwIfSpacingChange(oldScrollable.frameClient, newScrollable.frameClient);\n      var isFrameEqual = oldScrollable.frameClient.borderBox.height === newScrollable.frameClient.borderBox.height && oldScrollable.frameClient.borderBox.width === newScrollable.frameClient.borderBox.width;\n      !isFrameEqual ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'The width and height of your Droppable scroll container cannot change when adding or removing Draggables during a drag') : invariant(false) : void 0;\n    }\n\n    var client = createBox({\n      borderBox: adjustBorderBoxSize(dimension.axis, oldClient.borderBox, newClient.borderBox),\n      margin: oldClient.margin,\n      border: oldClient.border,\n      padding: oldClient.padding\n    });\n    var closest = {\n      client: oldScrollable.frameClient,\n      page: withScroll(oldScrollable.frameClient, viewport.scroll.initial),\n      shouldClipSubject: oldScrollable.shouldClipSubject,\n      scrollSize: newScrollable.scrollSize,\n      scroll: oldScrollable.scroll.initial\n    };\n    var withSizeChanged = getDroppableDimension({\n      descriptor: provided.descriptor,\n      isEnabled: provided.isEnabled,\n      isCombineEnabled: provided.isCombineEnabled,\n      isFixedOnPage: provided.isFixedOnPage,\n      direction: provided.axis.direction,\n      client: client,\n      page: withScroll(client, viewport.scroll.initial),\n      closest: closest\n    });\n    var scrolled = scrollDroppable(withSizeChanged, newScrollable.scroll.current);\n    return scrolled;\n  });\n\n  var result = _extends({}, existing, toDroppableMap(adjusted));\n\n  return result;\n});\n\nvar withNoAnimatedDisplacement = (function (impact) {\n  var displaced = impact.movement.displaced;\n\n  if (!displaced.length) {\n    return impact;\n  }\n\n  var withoutAnimation = displaced.map(function (displacement) {\n    if (!displacement.isVisible) {\n      return displacement;\n    }\n\n    if (!displacement.shouldAnimate) {\n      return displacement;\n    }\n\n    return _extends({}, displacement, {\n      shouldAnimate: false\n    });\n  });\n\n  var result = _extends({}, impact, {\n    movement: _extends({}, impact.movement, {\n      displaced: withoutAnimation,\n      map: getDisplacementMap(withoutAnimation)\n    })\n  });\n\n  return result;\n});\n\nvar patchDroppableMap = (function (droppables, updated) {\n  var _extends2;\n\n  return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));\n});\n\nvar clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {\n  var previousImpact = _ref.previousImpact,\n      impact = _ref.impact,\n      droppables = _ref.droppables;\n  var last = whatIsDraggedOver(previousImpact);\n  var now = whatIsDraggedOver(impact);\n\n  if (!last) {\n    return droppables;\n  }\n\n  if (last === now) {\n    return droppables;\n  }\n\n  var lastDroppable = droppables[last];\n\n  if (!lastDroppable.subject.withPlaceholder) {\n    return droppables;\n  }\n\n  var updated = removePlaceholder(lastDroppable);\n  return patchDroppableMap(droppables, updated);\n};\n\nvar recomputePlaceholders = (function (_ref2) {\n  var draggable = _ref2.draggable,\n      draggables = _ref2.draggables,\n      droppables = _ref2.droppables,\n      previousImpact = _ref2.previousImpact,\n      impact = _ref2.impact;\n  var cleaned = clearUnusedPlaceholder({\n    previousImpact: previousImpact,\n    impact: impact,\n    droppables: droppables\n  });\n  var isOver = whatIsDraggedOver(impact);\n\n  if (!isOver) {\n    return cleaned;\n  }\n\n  var droppable = droppables[isOver];\n\n  if (isHomeOf(draggable, droppable)) {\n    return cleaned;\n  }\n\n  if (droppable.subject.withPlaceholder) {\n    return cleaned;\n  }\n\n  var patched = addPlaceholder(droppable, draggable, draggables);\n  return patchDroppableMap(cleaned, patched);\n});\n\nvar timingsKey = 'Processing dynamic changes';\nvar publishWhileDragging = (function (_ref) {\n  var _extends2, _extends3;\n\n  var state = _ref.state,\n      published = _ref.published;\n  start(timingsKey);\n  var updatedDroppables = updateDroppables({\n    modified: published.modified,\n    existing: state.dimensions.droppables,\n    viewport: state.viewport\n  });\n  var draggables = updateDraggables({\n    updatedDroppables: updatedDroppables,\n    criticalId: state.critical.draggable.id,\n    existing: state.dimensions.draggables,\n    additions: published.additions,\n    removals: published.removals,\n    viewport: state.viewport\n  });\n  var critical = {\n    draggable: draggables[state.critical.draggable.id].descriptor,\n    droppable: updatedDroppables[state.critical.droppable.id].descriptor\n  };\n  var original = state.dimensions.draggables[critical.draggable.id];\n  var updated = draggables[critical.draggable.id];\n  var droppables = recomputePlaceholders({\n    draggable: updated,\n    draggables: draggables,\n    droppables: updatedDroppables,\n    previousImpact: state.impact,\n    impact: state.impact\n  });\n  var dimensions = {\n    draggables: draggables,\n    droppables: droppables\n  };\n\n  var _getDragPositions = getDragPositions({\n    initial: state.initial,\n    current: state.current,\n    oldClientBorderBoxCenter: original.client.borderBox.center,\n    newClientBorderBoxCenter: updated.client.borderBox.center,\n    viewport: state.viewport\n  }),\n      initial = _getDragPositions.initial,\n      current = _getDragPositions.current;\n\n  var _getHomeOnLift = getHomeOnLift({\n    draggable: updated,\n    home: dimensions.droppables[critical.droppable.id],\n    draggables: dimensions.draggables,\n    viewport: state.viewport\n  }),\n      homeImpact = _getHomeOnLift.impact,\n      onLift = _getHomeOnLift.onLift;\n\n  var impact = withNoAnimatedDisplacement(getDragImpact({\n    pageBorderBoxCenter: current.page.borderBoxCenter,\n    draggable: updated,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: homeImpact,\n    viewport: state.viewport,\n    userDirection: state.userDirection,\n    onLift: onLift\n  }));\n  var isOrphaned = Boolean(state.movementMode === 'SNAP' && !whatIsDraggedOver(impact));\n  !!isOrphaned ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dragging item no longer has a valid merge/destination after a dynamic update. This is not supported') : invariant(false) : void 0;\n  finish(timingsKey);\n\n  var draggingState = _extends({\n    phase: 'DRAGGING'\n  }, state, (_extends2 = {}, _extends2[\"phase\"] = 'DRAGGING', _extends2.critical = critical, _extends2.current = current, _extends2.initial = initial, _extends2.impact = impact, _extends2.dimensions = dimensions, _extends2.onLift = onLift, _extends2.onLiftImpact = homeImpact, _extends2.forceShouldAnimate = false, _extends2));\n\n  if (state.phase === 'COLLECTING') {\n    return draggingState;\n  }\n\n  var dropPending = _extends({\n    phase: 'DROP_PENDING'\n  }, draggingState, (_extends3 = {}, _extends3[\"phase\"] = 'DROP_PENDING', _extends3.reason = state.reason, _extends3.isWaiting = false, _extends3));\n\n  return dropPending;\n});\n\nvar forward = {\n  vertical: 'down',\n  horizontal: 'right'\n};\nvar backward = {\n  vertical: 'up',\n  horizontal: 'left'\n};\n\nvar moveToNextCombine = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      originalInsideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  if (previousImpact.merge) {\n    return null;\n  }\n\n  var location = previousImpact.destination;\n  !location ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Need a previous location to move from into a combine') : invariant(false) : void 0;\n  var currentIndex = location.index;\n\n  var currentInsideDestination = function () {\n    var shallow = originalInsideDestination.slice();\n\n    if (isInHomeList) {\n      shallow.splice(draggable.descriptor.index, 1);\n    }\n\n    shallow.splice(location.index, 0, draggable);\n    return shallow;\n  }();\n\n  var targetIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n\n  if (targetIndex < 0) {\n    return null;\n  }\n\n  if (targetIndex > currentInsideDestination.length - 1) {\n    return null;\n  }\n\n  var target = currentInsideDestination[targetIndex];\n  !(target !== draggable) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot combine with self') : invariant(false) : void 0;\n  var merge = {\n    whenEntered: isMovingForward ? forward : backward,\n    combine: {\n      draggableId: target.descriptor.id,\n      droppableId: destination.descriptor.id\n    }\n  };\n  var impact = {\n    movement: previousImpact.movement,\n    destination: null,\n    merge: merge\n  };\n  return impact;\n});\n\nvar addClosest = function addClosest(add, displaced) {\n  var added = {\n    draggableId: add.descriptor.id,\n    isVisible: true,\n    shouldAnimate: true\n  };\n  return [added].concat(displaced);\n};\nvar removeClosest = function removeClosest(displaced) {\n  return displaced.slice(1);\n};\n\nvar fromReorder = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      draggable = _ref.draggable,\n      initialInside = _ref.insideDestination,\n      location = _ref.location;\n  var insideDestination = initialInside.slice();\n  var currentIndex = location.index;\n  var isInForeignList = !isInHomeList;\n\n  if (isInForeignList) {\n    insideDestination.splice(location.index, 0, draggable);\n  }\n\n  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n\n  if (proposedIndex < 0) {\n    return null;\n  }\n\n  if (proposedIndex > insideDestination.length - 1) {\n    return null;\n  }\n\n  return {\n    proposedIndex: proposedIndex,\n    modifyDisplacement: true\n  };\n});\n\nvar fromCombine = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      destination = _ref.destination,\n      previousImpact = _ref.previousImpact,\n      draggables = _ref.draggables,\n      merge = _ref.merge,\n      onLift = _ref.onLift;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var movement = previousImpact.movement;\n  var combineId = merge.combine.draggableId;\n  var combine = draggables[combineId];\n  var combineIndex = combine.descriptor.index;\n  var wasDisplacedAtStart = didStartDisplaced(combineId, onLift);\n\n  if (wasDisplacedAtStart) {\n    var hasDisplacedFromStart = !movement.map[combineId];\n\n    if (hasDisplacedFromStart) {\n      if (isMovingForward) {\n        return {\n          proposedIndex: combineIndex,\n          modifyDisplacement: false\n        };\n      }\n\n      return {\n        proposedIndex: combineIndex - 1,\n        modifyDisplacement: true\n      };\n    }\n\n    if (isMovingForward) {\n      return {\n        proposedIndex: combineIndex,\n        modifyDisplacement: true\n      };\n    }\n\n    return {\n      proposedIndex: combineIndex - 1,\n      modifyDisplacement: false\n    };\n  }\n\n  var isDisplaced = Boolean(movement.map[combineId]);\n\n  if (isDisplaced) {\n    if (isMovingForward) {\n      return {\n        proposedIndex: combineIndex + 1,\n        modifyDisplacement: true\n      };\n    }\n\n    return {\n      proposedIndex: combineIndex,\n      modifyDisplacement: false\n    };\n  }\n\n  if (isMovingForward) {\n    return {\n      proposedIndex: combineIndex + 1,\n      modifyDisplacement: false\n    };\n  }\n\n  return {\n    proposedIndex: combineIndex,\n    modifyDisplacement: true\n  };\n});\n\nvar moveToNextIndex = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact,\n      onLift = _ref.onLift;\n\n  var instruction = function () {\n    if (previousImpact.destination) {\n      return fromReorder({\n        isMovingForward: isMovingForward,\n        isInHomeList: isInHomeList,\n        draggable: draggable,\n        location: previousImpact.destination,\n        insideDestination: insideDestination\n      });\n    }\n\n    if (previousImpact.merge) {\n      return fromCombine({\n        isMovingForward: isMovingForward,\n        destination: destination,\n        previousImpact: previousImpact,\n        draggables: draggables,\n        merge: previousImpact.merge,\n        onLift: onLift\n      });\n    }\n    return null;\n  }();\n\n  if (instruction == null) {\n    return null;\n  }\n\n  var proposedIndex = instruction.proposedIndex,\n      modifyDisplacement = instruction.modifyDisplacement;\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n\n  var displaced = function () {\n    var lastDisplaced = previousImpact.movement.displaced;\n\n    if (!modifyDisplacement) {\n      return lastDisplaced;\n    }\n\n    if (isMovingForward) {\n      return removeClosest(lastDisplaced);\n    }\n\n    var withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    var atProposedIndex = withoutDraggable[proposedIndex];\n    return addClosest(atProposedIndex, lastDisplaced);\n  }();\n\n  return {\n    movement: {\n      displacedBy: displacedBy,\n      displaced: displaced,\n      map: getDisplacementMap(displaced)\n    },\n    destination: {\n      droppableId: destination.descriptor.id,\n      index: proposedIndex\n    },\n    merge: null\n  };\n});\n\nvar whenCombining = (function (_ref) {\n  var combine = _ref.combine,\n      onLift = _ref.onLift,\n      movement = _ref.movement,\n      draggables = _ref.draggables;\n  var combineWith = combine.draggableId;\n  var center = draggables[combineWith].page.borderBox.center;\n  var displaceBy = getCombinedItemDisplacement({\n    displaced: movement.map,\n    onLift: onLift,\n    combineWith: combineWith,\n    displacedBy: movement.displacedBy\n  });\n  return add(center, displaceBy);\n});\n\nvar distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {\n  return box.margin[axis.start] + box.borderBox[axis.size] / 2;\n};\n\nvar distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {\n  return box.margin[axis.end] + box.borderBox[axis.size] / 2;\n};\n\nvar getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {\n  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\n};\n\nvar goAfter = function goAfter(_ref) {\n  var axis = _ref.axis,\n      moveRelativeTo = _ref.moveRelativeTo,\n      isMoving = _ref.isMoving;\n  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goBefore = function goBefore(_ref2) {\n  var axis = _ref2.axis,\n      moveRelativeTo = _ref2.moveRelativeTo,\n      isMoving = _ref2.isMoving;\n  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goIntoStart = function goIntoStart(_ref3) {\n  var axis = _ref3.axis,\n      moveInto = _ref3.moveInto,\n      isMoving = _ref3.isMoving;\n  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n};\n\nvar whenReordering = (function (_ref) {\n  var movement = _ref.movement,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppable = _ref.droppable,\n      onLift = _ref.onLift;\n  var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  var draggablePage = draggable.page;\n  var axis = droppable.axis;\n\n  if (!insideDestination.length) {\n    return goIntoStart({\n      axis: axis,\n      moveInto: droppable.page,\n      isMoving: draggablePage\n    });\n  }\n\n  var displaced = movement.displaced,\n      displacedBy = movement.displacedBy;\n\n  if (displaced.length) {\n    var closestAfter = draggables[displaced[0].draggableId];\n\n    if (didStartDisplaced(closestAfter.descriptor.id, onLift)) {\n      return goBefore({\n        axis: axis,\n        moveRelativeTo: closestAfter.page,\n        isMoving: draggablePage\n      });\n    }\n\n    var withDisplacement = offset(closestAfter.page, displacedBy.point);\n    return goBefore({\n      axis: axis,\n      moveRelativeTo: withDisplacement,\n      isMoving: draggablePage\n    });\n  }\n\n  var last = insideDestination[insideDestination.length - 1];\n\n  if (last.descriptor.id === draggable.descriptor.id) {\n    return draggablePage.borderBox.center;\n  }\n\n  if (didStartDisplaced(last.descriptor.id, onLift)) {\n    var page = offset(last.page, negate(onLift.displacedBy.point));\n    return goAfter({\n      axis: axis,\n      moveRelativeTo: page,\n      isMoving: draggablePage\n    });\n  }\n\n  return goAfter({\n    axis: axis,\n    moveRelativeTo: last.page,\n    isMoving: draggablePage\n  });\n});\n\nvar withDroppableDisplacement = (function (droppable, point) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return point;\n  }\n\n  return add(point, frame.scroll.diff.displacement);\n});\n\nvar getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      onLift = _ref.onLift;\n  var merge = impact.merge;\n  var destination = impact.destination;\n  var original = draggable.page.borderBox.center;\n\n  if (!droppable) {\n    return original;\n  }\n\n  if (destination) {\n    return whenReordering({\n      movement: impact.movement,\n      draggable: draggable,\n      draggables: draggables,\n      droppable: droppable,\n      onLift: onLift\n    });\n  }\n\n  if (merge) {\n    return whenCombining({\n      movement: impact.movement,\n      combine: merge.combine,\n      draggables: draggables,\n      onLift: onLift\n    });\n  }\n\n  return original;\n};\n\nvar getPageBorderBoxCenterFromImpact = (function (args) {\n  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n  var droppable = args.droppable;\n  var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n  return withDisplacement;\n});\n\nvar scrollViewport = (function (viewport, newScroll) {\n  var diff = subtract(newScroll, viewport.scroll.initial);\n  var displacement = negate(diff);\n  var frame = getRect({\n    top: newScroll.y,\n    bottom: newScroll.y + viewport.frame.height,\n    left: newScroll.x,\n    right: newScroll.x + viewport.frame.width\n  });\n  var updated = {\n    frame: frame,\n    scroll: {\n      initial: viewport.scroll.initial,\n      max: viewport.scroll.max,\n      current: newScroll,\n      diff: {\n        value: diff,\n        displacement: displacement\n      }\n    }\n  };\n  return updated;\n});\n\nvar withNewDisplacement = (function (impact, displaced) {\n  return _extends({}, impact, {\n    movement: _extends({}, impact.movement, {\n      displaced: displaced,\n      map: getDisplacementMap(displaced)\n    })\n  });\n});\n\nvar speculativelyIncrease = (function (_ref) {\n  var impact = _ref.impact,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      maxScrollChange = _ref.maxScrollChange,\n      onLift = _ref.onLift;\n  var displaced = impact.movement.displaced;\n  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n  var updated = displaced.map(function (entry) {\n    if (entry.isVisible) {\n      return entry;\n    }\n\n    var draggable = draggables[entry.draggableId];\n    var withScrolledViewport = getDisplacement({\n      draggable: draggable,\n      destination: destination,\n      previousImpact: impact,\n      viewport: scrolledViewport.frame,\n      onLift: onLift,\n      forceShouldAnimate: false\n    });\n\n    if (withScrolledViewport.isVisible) {\n      return withScrolledViewport;\n    }\n\n    var withScrolledDroppable = getDisplacement({\n      draggable: draggable,\n      destination: scrolledDroppable,\n      previousImpact: impact,\n      viewport: viewport.frame,\n      onLift: onLift,\n      forceShouldAnimate: false\n    });\n\n    if (withScrolledDroppable.isVisible) {\n      return withScrolledDroppable;\n    }\n\n    return entry;\n  });\n  return withNewDisplacement(impact, updated);\n});\n\nvar withViewportDisplacement = (function (viewport, point) {\n  return add(viewport.scroll.diff.displacement, point);\n});\n\nvar getClientFromPageBorderBoxCenter = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      viewport = _ref.viewport;\n  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n  var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n  return add(draggable.client.borderBox.center, offset);\n});\n\nvar isTotallyVisibleInNewLocation = (function (_ref) {\n  var draggable = _ref.draggable,\n      destination = _ref.destination,\n      newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,\n      viewport = _ref.viewport,\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\n      _ref$onlyOnMainAxis = _ref.onlyOnMainAxis,\n      onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;\n  var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n  var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n  var args = {\n    target: shifted,\n    destination: destination,\n    withDroppableDisplacement: withDroppableDisplacement,\n    viewport: viewport\n  };\n  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n});\n\nvar moveToNextPlace = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      previousClientSelection = _ref.previousClientSelection,\n      onLift = _ref.onLift;\n\n  if (!destination.isEnabled) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var isInHomeList = isHomeOf(draggable, destination);\n  var impact = moveToNextCombine({\n    isInHomeList: isInHomeList,\n    isMovingForward: isMovingForward,\n    draggable: draggable,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact\n  }) || moveToNextIndex({\n    isMovingForward: isMovingForward,\n    isInHomeList: isInHomeList,\n    draggable: draggable,\n    draggables: draggables,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact,\n    onLift: onLift\n  });\n\n  if (!impact) {\n    return null;\n  }\n\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    onLift: onLift\n  });\n  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n    draggable: draggable,\n    destination: destination,\n    newPageBorderBoxCenter: pageBorderBoxCenter,\n    viewport: viewport.frame,\n    withDroppableDisplacement: false,\n    onlyOnMainAxis: true\n  });\n\n  if (isVisibleInNewLocation) {\n    var clientSelection = getClientFromPageBorderBoxCenter({\n      pageBorderBoxCenter: pageBorderBoxCenter,\n      draggable: draggable,\n      viewport: viewport\n    });\n    return {\n      clientSelection: clientSelection,\n      impact: impact,\n      scrollJumpRequest: null\n    };\n  }\n\n  var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n  var cautious = speculativelyIncrease({\n    impact: impact,\n    viewport: viewport,\n    destination: destination,\n    draggables: draggables,\n    maxScrollChange: distance,\n    onLift: onLift\n  });\n  return {\n    clientSelection: previousClientSelection,\n    impact: cautious,\n    scrollJumpRequest: distance\n  };\n});\n\nvar getKnownActive = function getKnownActive(droppable) {\n  var rect = droppable.subject.active;\n  !rect ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get clipped area from droppable') : invariant(false) : void 0;\n  return rect;\n};\n\nvar getBestCrossAxisDroppable = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      source = _ref.source,\n      droppables = _ref.droppables,\n      viewport = _ref.viewport;\n  var active = source.subject.active;\n\n  if (!active) {\n    return null;\n  }\n\n  var axis = source.axis;\n  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n  var candidates = toDroppableList(droppables).filter(function (droppable) {\n    return droppable !== source;\n  }).filter(function (droppable) {\n    return droppable.isEnabled;\n  }).filter(function (droppable) {\n    return Boolean(droppable.subject.active);\n  }).filter(function (droppable) {\n    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));\n  }).filter(function (droppable) {\n    var activeOfTarget = getKnownActive(droppable);\n\n    if (isMovingForward) {\n      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n    }\n\n    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n  }).filter(function (droppable) {\n    var activeOfTarget = getKnownActive(droppable);\n    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n  }).sort(function (a, b) {\n    var first = getKnownActive(a)[axis.crossAxisStart];\n    var second = getKnownActive(b)[axis.crossAxisStart];\n\n    if (isMovingForward) {\n      return first - second;\n    }\n\n    return second - first;\n  }).filter(function (droppable, index, array) {\n    return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];\n  });\n\n  if (!candidates.length) {\n    return null;\n  }\n\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n\n  var contains = candidates.filter(function (droppable) {\n    var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n  });\n\n  if (contains.length === 1) {\n    return contains[0];\n  }\n\n  if (contains.length > 1) {\n    return contains.sort(function (a, b) {\n      return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n  }\n\n  return candidates.sort(function (a, b) {\n    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n\n    if (first !== second) {\n      return first - second;\n    }\n\n    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n  })[0];\n});\n\nvar getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, onLift) {\n  var original = draggable.page.borderBox.center;\n  return didStartDisplaced(draggable.descriptor.id, onLift) ? subtract(original, onLift.displacedBy.point) : original;\n};\nvar getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, onLift) {\n  var original = draggable.page.borderBox;\n  return didStartDisplaced(draggable.descriptor.id, onLift) ? offsetByPosition(original, negate(onLift.displacedBy.point)) : original;\n};\n\nvar getClosestDraggable = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      onLift = _ref.onLift;\n  var sorted = insideDestination.filter(function (draggable) {\n    return isTotallyVisible({\n      target: getCurrentPageBorderBox(draggable, onLift),\n      destination: destination,\n      viewport: viewport.frame,\n      withDroppableDisplacement: true\n    });\n  }).sort(function (a, b) {\n    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, onLift)));\n    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, onLift)));\n\n    if (distanceToA < distanceToB) {\n      return -1;\n    }\n\n    if (distanceToB < distanceToA) {\n      return 1;\n    }\n\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return sorted[0] || null;\n});\n\nvar moveToNewDroppable = (function (_ref) {\n  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      moveRelativeTo = _ref.moveRelativeTo,\n      insideDestination = _ref.insideDestination,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      onLift = _ref.onLift;\n\n  if (!moveRelativeTo) {\n    if (insideDestination.length) {\n      return null;\n    }\n\n    var proposed = {\n      movement: noMovement,\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: 0\n      },\n      merge: null\n    };\n    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n      impact: proposed,\n      draggable: draggable,\n      droppable: destination,\n      draggables: draggables,\n      onLift: onLift\n    });\n    var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n      draggable: draggable,\n      destination: withPlaceholder,\n      newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n      viewport: viewport.frame,\n      withDroppableDisplacement: false,\n      onlyOnMainAxis: true\n    });\n    return isVisibleInNewLocation ? proposed : null;\n  }\n\n  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] < moveRelativeTo.page.borderBox.center[destination.axis.line]);\n  var targetIndex = insideDestination.indexOf(moveRelativeTo);\n  !(targetIndex !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find target in list') : invariant(false) : void 0;\n\n  var proposedIndex = function () {\n    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n      return targetIndex;\n    }\n\n    if (isGoingBeforeTarget) {\n      return targetIndex;\n    }\n\n    return targetIndex + 1;\n  }();\n\n  var displaced = removeDraggableFromList(draggable, insideDestination).slice(proposedIndex).map(function (dimension) {\n    return getDisplacement({\n      draggable: dimension,\n      destination: destination,\n      viewport: viewport.frame,\n      previousImpact: previousImpact,\n      onLift: onLift\n    });\n  });\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  var impact = {\n    movement: {\n      displacedBy: displacedBy,\n      displaced: displaced,\n      map: getDisplacementMap(displaced)\n    },\n    destination: {\n      droppableId: destination.descriptor.id,\n      index: proposedIndex\n    },\n    merge: null\n  };\n  return impact;\n});\n\nvar moveCrossAxis = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      draggable = _ref.draggable,\n      isOver = _ref.isOver,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      onLift = _ref.onLift;\n  var destination = getBestCrossAxisDroppable({\n    isMovingForward: isMovingForward,\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    source: isOver,\n    droppables: droppables,\n    viewport: viewport\n  });\n\n  if (!destination) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var moveRelativeTo = getClosestDraggable({\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    viewport: viewport,\n    destination: destination,\n    insideDestination: insideDestination,\n    onLift: onLift\n  });\n  var impact = moveToNewDroppable({\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    destination: destination,\n    draggable: draggable,\n    draggables: draggables,\n    moveRelativeTo: moveRelativeTo,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact,\n    viewport: viewport,\n    onLift: onLift\n  });\n\n  if (!impact) {\n    return null;\n  }\n\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    onLift: onLift\n  });\n  var clientSelection = getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    viewport: viewport\n  });\n  return {\n    clientSelection: clientSelection,\n    impact: impact,\n    scrollJumpRequest: null\n  };\n});\n\nvar getDroppableOver$1 = function getDroppableOver(impact, droppables) {\n  var id = whatIsDraggedOver(impact);\n  return id ? droppables[id] : null;\n};\n\nvar moveInDirection = (function (_ref) {\n  var state = _ref.state,\n      type = _ref.type;\n  var isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n  var isMainAxisMovementAllowed = Boolean(isActuallyOver);\n  var home = state.dimensions.droppables[state.critical.droppable.id];\n  var isOver = isActuallyOver || home;\n  var direction = isOver.axis.direction;\n  var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\n\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n    return null;\n  }\n\n  var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\n  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n  var _state$dimensions = state.dimensions,\n      draggables = _state$dimensions.draggables,\n      droppables = _state$dimensions.droppables;\n  return isMovingOnMainAxis ? moveToNextPlace({\n    isMovingForward: isMovingForward,\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    draggable: draggable,\n    destination: isOver,\n    draggables: draggables,\n    viewport: state.viewport,\n    previousClientSelection: state.current.client.selection,\n    previousImpact: state.impact,\n    onLift: state.onLift\n  }) : moveCrossAxis({\n    isMovingForward: isMovingForward,\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    draggable: draggable,\n    isOver: isOver,\n    draggables: draggables,\n    droppables: droppables,\n    previousImpact: state.impact,\n    viewport: state.viewport,\n    onLift: state.onLift\n  });\n});\n\nfunction isMovementAllowed(state) {\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\n}\n\nvar getVertical = function getVertical(previous, diff) {\n  if (diff === 0) {\n    return previous;\n  }\n\n  return diff > 0 ? 'down' : 'up';\n};\n\nvar getHorizontal = function getHorizontal(previous, diff) {\n  if (diff === 0) {\n    return previous;\n  }\n\n  return diff > 0 ? 'right' : 'left';\n};\n\nvar getUserDirection = (function (previous, oldPageBorderBoxCenter, newPageBorderBoxCenter) {\n  var diff = subtract(newPageBorderBoxCenter, oldPageBorderBoxCenter);\n  return {\n    horizontal: getHorizontal(previous.horizontal, diff.x),\n    vertical: getVertical(previous.vertical, diff.y)\n  };\n});\n\nvar update = (function (_ref) {\n  var state = _ref.state,\n      forcedClientSelection = _ref.clientSelection,\n      forcedDimensions = _ref.dimensions,\n      forcedViewport = _ref.viewport,\n      forcedImpact = _ref.impact,\n      scrollJumpRequest = _ref.scrollJumpRequest;\n  var viewport = forcedViewport || state.viewport;\n  var currentWindowScroll = viewport.scroll.current;\n  var dimensions = forcedDimensions || state.dimensions;\n  var clientSelection = forcedClientSelection || state.current.client.selection;\n  var offset = subtract(clientSelection, state.initial.client.selection);\n  var client = {\n    offset: offset,\n    selection: clientSelection,\n    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n  };\n  var page = {\n    selection: add(client.selection, currentWindowScroll),\n    borderBoxCenter: add(client.borderBoxCenter, currentWindowScroll)\n  };\n  var current = {\n    client: client,\n    page: page\n  };\n  var userDirection = getUserDirection(state.userDirection, state.current.page.borderBoxCenter, current.page.borderBoxCenter);\n\n  if (state.phase === 'COLLECTING') {\n    return _extends({\n      phase: 'COLLECTING'\n    }, state, {\n      dimensions: dimensions,\n      viewport: viewport,\n      current: current,\n      userDirection: userDirection\n    });\n  }\n\n  var draggable = dimensions.draggables[state.critical.draggable.id];\n  var newImpact = forcedImpact || getDragImpact({\n    pageBorderBoxCenter: page.borderBoxCenter,\n    draggable: draggable,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: state.impact,\n    viewport: viewport,\n    userDirection: userDirection,\n    onLift: state.onLift\n  });\n  var withUpdatedPlaceholders = recomputePlaceholders({\n    draggable: draggable,\n    impact: newImpact,\n    previousImpact: state.impact,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables\n  });\n\n  var result = _extends({}, state, {\n    current: current,\n    userDirection: userDirection,\n    dimensions: {\n      draggables: dimensions.draggables,\n      droppables: withUpdatedPlaceholders\n    },\n    impact: newImpact,\n    viewport: viewport,\n    scrollJumpRequest: scrollJumpRequest || null,\n    forceShouldAnimate: scrollJumpRequest ? false : null\n  });\n\n  return result;\n});\n\nvar recompute = (function (_ref) {\n  var impact = _ref.impact,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      onLift = _ref.onLift,\n      forceShouldAnimate = _ref.forceShouldAnimate;\n  var updated = impact.movement.displaced.map(function (entry) {\n    return getDisplacement({\n      draggable: draggables[entry.draggableId],\n      destination: destination,\n      previousImpact: impact,\n      viewport: viewport.frame,\n      onLift: onLift,\n      forceShouldAnimate: forceShouldAnimate\n    });\n  });\n  return withNewDisplacement(impact, updated);\n});\n\nvar getClientBorderBoxCenter = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport,\n      onLift = _ref.onLift;\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    draggables: draggables,\n    droppable: droppable,\n    onLift: onLift\n  });\n  return getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    viewport: viewport\n  });\n});\n\nvar refreshSnap = (function (_ref) {\n  var state = _ref.state,\n      forcedDimensions = _ref.dimensions,\n      forcedViewport = _ref.viewport;\n  !(state.movementMode === 'SNAP') ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var needsVisibilityCheck = state.impact;\n  var viewport = forcedViewport || state.viewport;\n  var dimensions = forcedDimensions || state.dimensions;\n  var draggables = dimensions.draggables,\n      droppables = dimensions.droppables;\n  var draggable = draggables[state.critical.draggable.id];\n  var isOver = whatIsDraggedOver(needsVisibilityCheck);\n  !isOver ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Must be over a destination in SNAP movement mode') : invariant(false) : void 0;\n  var destination = droppables[isOver];\n  var impact = recompute({\n    impact: needsVisibilityCheck,\n    viewport: viewport,\n    destination: destination,\n    draggables: draggables,\n    onLift: state.onLift\n  });\n  var clientSelection = getClientBorderBoxCenter({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    viewport: viewport,\n    onLift: state.onLift\n  });\n  return update({\n    impact: impact,\n    clientSelection: clientSelection,\n    state: state,\n    dimensions: dimensions,\n    viewport: viewport\n  });\n});\n\nvar patchDimensionMap = (function (dimensions, updated) {\n  return {\n    draggables: dimensions.draggables,\n    droppables: patchDroppableMap(dimensions.droppables, updated)\n  };\n});\n\nvar isSnapping = function isSnapping(state) {\n  return state.movementMode === 'SNAP';\n};\n\nvar postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {\n  var dimensions = patchDimensionMap(state.dimensions, updated);\n\n  if (!isSnapping(state) || isEnabledChanging) {\n    return update({\n      state: state,\n      dimensions: dimensions\n    });\n  }\n\n  return refreshSnap({\n    state: state,\n    dimensions: dimensions\n  });\n};\n\nvar idle = {\n  phase: 'IDLE',\n  completed: null,\n  shouldFlush: false\n};\nvar reducer = (function (state, action) {\n  if (state === void 0) {\n    state = idle;\n  }\n\n  if (action.type === 'CLEAN') {\n    return _extends({}, idle, {\n      shouldFlush: action.payload.shouldFlush\n    });\n  }\n\n  if (action.type === 'INITIAL_PUBLISH') {\n    !(state.phase === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : invariant(false) : void 0;\n    var _action$payload = action.payload,\n        critical = _action$payload.critical,\n        clientSelection = _action$payload.clientSelection,\n        viewport = _action$payload.viewport,\n        dimensions = _action$payload.dimensions,\n        movementMode = _action$payload.movementMode;\n    var draggable = dimensions.draggables[critical.draggable.id];\n    var home = dimensions.droppables[critical.droppable.id];\n    var client = {\n      selection: clientSelection,\n      borderBoxCenter: draggable.client.borderBox.center,\n      offset: origin\n    };\n    var initial = {\n      client: client,\n      page: {\n        selection: add(client.selection, viewport.scroll.initial),\n        borderBoxCenter: add(client.selection, viewport.scroll.initial)\n      }\n    };\n    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function (item) {\n      return !item.isFixedOnPage;\n    });\n\n    var _getHomeOnLift = getHomeOnLift({\n      draggable: draggable,\n      home: home,\n      draggables: dimensions.draggables,\n      viewport: viewport\n    }),\n        impact = _getHomeOnLift.impact,\n        onLift = _getHomeOnLift.onLift;\n\n    var result = {\n      phase: 'DRAGGING',\n      isDragging: true,\n      critical: critical,\n      movementMode: movementMode,\n      dimensions: dimensions,\n      initial: initial,\n      current: initial,\n      isWindowScrollAllowed: isWindowScrollAllowed,\n      impact: impact,\n      onLift: onLift,\n      onLiftImpact: impact,\n      viewport: viewport,\n      userDirection: forward,\n      scrollJumpRequest: null,\n      forceShouldAnimate: null\n    };\n    return result;\n  }\n\n  if (action.type === 'COLLECTION_STARTING') {\n    var _extends2;\n\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Collection cannot start from phase \" + state.phase) : invariant(false) : void 0;\n\n    var _result = _extends({\n      phase: 'COLLECTING'\n    }, state, (_extends2 = {}, _extends2[\"phase\"] = 'COLLECTING', _extends2));\n\n    return _result;\n  }\n\n  if (action.type === 'PUBLISH_WHILE_DRAGGING') {\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Unexpected \" + action.type + \" received in phase \" + state.phase) : invariant(false) : void 0;\n    return publishWhileDragging({\n      state: state,\n      published: action.payload\n    });\n  }\n\n  if (action.type === 'MOVE') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : invariant(false) : void 0;\n    var _clientSelection = action.payload.client;\n\n    if (isEqual(_clientSelection, state.current.client.selection)) {\n      return state;\n    }\n\n    return update({\n      state: state,\n      clientSelection: _clientSelection,\n      impact: isSnapping(state) ? state.impact : null\n    });\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    if (state.phase === 'COLLECTING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload2 = action.payload,\n        id = _action$payload2.id,\n        offset = _action$payload2.offset;\n    var target = state.dimensions.droppables[id];\n\n    if (!target) {\n      return state;\n    }\n\n    var scrolled = scrollDroppable(target, offset);\n    return postDroppableChange(state, scrolled, false);\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload3 = action.payload,\n        _id = _action$payload3.id,\n        isEnabled = _action$payload3.isEnabled;\n    var _target = state.dimensions.droppables[_id];\n    !_target ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find Droppable[id: \" + _id + \"] to toggle its enabled state\") : invariant(false) : void 0;\n    !(_target.isEnabled !== isEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Trying to set droppable isEnabled to \" + String(isEnabled) + \"\\n      but it is already \" + String(_target.isEnabled)) : invariant(false) : void 0;\n\n    var updated = _extends({}, _target, {\n      isEnabled: isEnabled\n    });\n\n    return postDroppableChange(state, updated, true);\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload4 = action.payload,\n        _id2 = _action$payload4.id,\n        isCombineEnabled = _action$payload4.isCombineEnabled;\n    var _target2 = state.dimensions.droppables[_id2];\n    !_target2 ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find Droppable[id: \" + _id2 + \"] to toggle its isCombineEnabled state\") : invariant(false) : void 0;\n    !(_target2.isCombineEnabled !== isCombineEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Trying to set droppable isCombineEnabled to \" + String(isCombineEnabled) + \"\\n      but it is already \" + String(_target2.isCombineEnabled)) : invariant(false) : void 0;\n\n    var _updated = _extends({}, _target2, {\n      isCombineEnabled: isCombineEnabled\n    });\n\n    return postDroppableChange(state, _updated, true);\n  }\n\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot move by window in phase \" + state.phase) : invariant(false) : void 0;\n    !state.isWindowScrollAllowed ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Window scrolling is currently not supported for fixed lists. Aborting drag') : invariant(false) : void 0;\n    var newScroll = action.payload.newScroll;\n\n    if (isEqual(state.viewport.scroll.current, newScroll)) {\n      return state;\n    }\n\n    var _viewport = scrollViewport(state.viewport, newScroll);\n\n    if (isSnapping(state)) {\n      return refreshSnap({\n        state: state,\n        viewport: _viewport\n      });\n    }\n\n    return update({\n      state: state,\n      viewport: _viewport\n    });\n  }\n\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\n    if (!isMovementAllowed(state)) {\n      return state;\n    }\n\n    var maxScroll = action.payload.maxScroll;\n\n    if (isEqual(maxScroll, state.viewport.scroll.max)) {\n      return state;\n    }\n\n    var withMaxScroll = _extends({}, state.viewport, {\n      scroll: _extends({}, state.viewport.scroll, {\n        max: maxScroll\n      })\n    });\n\n    return _extends({\n      phase: 'DRAGGING'\n    }, state, {\n      viewport: withMaxScroll\n    });\n  }\n\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" received while not in DRAGGING phase\") : invariant(false) : void 0;\n\n    var _result2 = moveInDirection({\n      state: state,\n      type: action.type\n    });\n\n    if (!_result2) {\n      return state;\n    }\n\n    return update({\n      state: state,\n      impact: _result2.impact,\n      clientSelection: _result2.clientSelection,\n      scrollJumpRequest: _result2.scrollJumpRequest\n    });\n  }\n\n  if (action.type === 'DROP_PENDING') {\n    var _extends3;\n\n    var reason = action.payload.reason;\n    !(state.phase === 'COLLECTING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : invariant(false) : void 0;\n\n    var newState = _extends({\n      phase: 'DROP_PENDING'\n    }, state, (_extends3 = {}, _extends3[\"phase\"] = 'DROP_PENDING', _extends3.isWaiting = true, _extends3.reason = reason, _extends3));\n\n    return newState;\n  }\n\n  if (action.type === 'DROP_ANIMATE') {\n    var _action$payload5 = action.payload,\n        completed = _action$payload5.completed,\n        dropDuration = _action$payload5.dropDuration,\n        newHomeClientOffset = _action$payload5.newHomeClientOffset;\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot animate drop from phase \" + state.phase) : invariant(false) : void 0;\n    var _result3 = {\n      phase: 'DROP_ANIMATING',\n      dimensions: state.dimensions,\n      completed: completed,\n      dropDuration: dropDuration,\n      newHomeClientOffset: newHomeClientOffset\n    };\n    return _result3;\n  }\n\n  if (action.type === 'DROP_COMPLETE') {\n    var _action$payload6 = action.payload,\n        _completed = _action$payload6.completed,\n        shouldFlush = _action$payload6.shouldFlush;\n    return {\n      phase: 'IDLE',\n      completed: _completed,\n      shouldFlush: shouldFlush\n    };\n  }\n\n  return state;\n});\n\nvar lift = function lift(args) {\n  return {\n    type: 'LIFT',\n    payload: args\n  };\n};\nvar initialPublish = function initialPublish(args) {\n  return {\n    type: 'INITIAL_PUBLISH',\n    payload: args\n  };\n};\nvar publishWhileDragging$1 = function publishWhileDragging(args) {\n  return {\n    type: 'PUBLISH_WHILE_DRAGGING',\n    payload: args\n  };\n};\nvar collectionStarting = function collectionStarting() {\n  return {\n    type: 'COLLECTION_STARTING',\n    payload: null\n  };\n};\nvar updateDroppableScroll = function updateDroppableScroll(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_SCROLL',\n    payload: args\n  };\n};\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_ENABLED',\n    payload: args\n  };\n};\nvar updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',\n    payload: args\n  };\n};\nvar move = function move(args) {\n  return {\n    type: 'MOVE',\n    payload: args\n  };\n};\nvar moveByWindowScroll = function moveByWindowScroll(args) {\n  return {\n    type: 'MOVE_BY_WINDOW_SCROLL',\n    payload: args\n  };\n};\nvar updateViewportMaxScroll = function updateViewportMaxScroll(args) {\n  return {\n    type: 'UPDATE_VIEWPORT_MAX_SCROLL',\n    payload: args\n  };\n};\nvar moveUp = function moveUp() {\n  return {\n    type: 'MOVE_UP',\n    payload: null\n  };\n};\nvar moveDown = function moveDown() {\n  return {\n    type: 'MOVE_DOWN',\n    payload: null\n  };\n};\nvar moveRight = function moveRight() {\n  return {\n    type: 'MOVE_RIGHT',\n    payload: null\n  };\n};\nvar moveLeft = function moveLeft() {\n  return {\n    type: 'MOVE_LEFT',\n    payload: null\n  };\n};\nvar clean$1 = function clean(args) {\n  if (args === void 0) {\n    args = {\n      shouldFlush: false\n    };\n  }\n\n  return {\n    type: 'CLEAN',\n    payload: args\n  };\n};\nvar animateDrop = function animateDrop(args) {\n  return {\n    type: 'DROP_ANIMATE',\n    payload: args\n  };\n};\nvar completeDrop = function completeDrop(args) {\n  return {\n    type: 'DROP_COMPLETE',\n    payload: args\n  };\n};\nvar drop = function drop(args) {\n  return {\n    type: 'DROP',\n    payload: args\n  };\n};\nvar dropPending = function dropPending(args) {\n  return {\n    type: 'DROP_PENDING',\n    payload: args\n  };\n};\nvar dropAnimationFinished = function dropAnimationFinished() {\n  return {\n    type: 'DROP_ANIMATION_FINISHED',\n    payload: null\n  };\n};\n\nvar lift$1 = (function (marshal) {\n  return function (_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n    return function (next) {\n      return function (action) {\n        if (action.type !== 'LIFT') {\n          next(action);\n          return;\n        }\n\n        var _action$payload = action.payload,\n            id = _action$payload.id,\n            clientSelection = _action$payload.clientSelection,\n            movementMode = _action$payload.movementMode;\n        var initial = getState();\n\n        if (initial.phase === 'DROP_ANIMATING') {\n          dispatch(completeDrop({\n            completed: initial.completed,\n            shouldFlush: true\n          }));\n        }\n\n        !(getState().phase === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Incorrect phase to start a drag') : invariant(false) : void 0;\n        var scrollOptions = {\n          shouldPublishImmediately: movementMode === 'SNAP'\n        };\n        var request = {\n          draggableId: id,\n          scrollOptions: scrollOptions\n        };\n\n        var _marshal$startPublish = marshal.startPublishing(request),\n            critical = _marshal$startPublish.critical,\n            dimensions = _marshal$startPublish.dimensions,\n            viewport = _marshal$startPublish.viewport;\n\n        dispatch(initialPublish({\n          critical: critical,\n          dimensions: dimensions,\n          clientSelection: clientSelection,\n          movementMode: movementMode,\n          viewport: viewport\n        }));\n      };\n    };\n  };\n});\n\nvar style = (function (marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          marshal.dragging();\n        }\n\n        if (action.type === 'DROP_ANIMATE') {\n          marshal.dropping(action.payload.completed.result.reason);\n        }\n\n        if (action.type === 'CLEAN' || action.type === 'DROP_COMPLETE') {\n          marshal.resting();\n        }\n\n        next(action);\n      };\n    };\n  };\n});\n\nvar curves = {\n  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',\n  drop: 'cubic-bezier(.2,1,.1,1)'\n};\nvar combine = {\n  opacity: {\n    drop: 0,\n    combining: 0.7\n  },\n  scale: {\n    drop: 0.75\n  }\n};\nvar timings = {\n  outOfTheWay: 0.2,\n  minDropTime: 0.33,\n  maxDropTime: 0.55\n};\nvar outOfTheWayTiming = timings.outOfTheWay + \"s \" + curves.outOfTheWay;\nvar transitions = {\n  fluid: \"opacity \" + outOfTheWayTiming,\n  snap: \"transform \" + outOfTheWayTiming + \", opacity \" + outOfTheWayTiming,\n  drop: function drop(duration) {\n    var timing = duration + \"s \" + curves.drop;\n    return \"transform \" + timing + \", opacity \" + timing;\n  },\n  outOfTheWay: \"transform \" + outOfTheWayTiming,\n  placeholder: \"height \" + outOfTheWayTiming + \", width \" + outOfTheWayTiming + \", margin \" + outOfTheWayTiming\n};\n\nvar moveTo = function moveTo(offset) {\n  return isEqual(offset, origin) ? null : \"translate(\" + offset.x + \"px, \" + offset.y + \"px)\";\n};\n\nvar transforms = {\n  moveTo: moveTo,\n  drop: function drop(offset, isCombining) {\n    var translate = moveTo(offset);\n\n    if (!translate) {\n      return null;\n    }\n\n    if (!isCombining) {\n      return translate;\n    }\n\n    return translate + \" scale(\" + combine.scale.drop + \")\";\n  }\n};\n\nvar minDropTime = timings.minDropTime,\n    maxDropTime = timings.maxDropTime;\nvar dropTimeRange = maxDropTime - minDropTime;\nvar maxDropTimeAtDistance = 1500;\nvar cancelDropModifier = 0.6;\nvar getDropDuration = (function (_ref) {\n  var current = _ref.current,\n      destination = _ref.destination,\n      reason = _ref.reason;\n  var distance$1 = distance(current, destination);\n\n  if (distance$1 <= 0) {\n    return minDropTime;\n  }\n\n  if (distance$1 >= maxDropTimeAtDistance) {\n    return maxDropTime;\n  }\n\n  var percentage = distance$1 / maxDropTimeAtDistance;\n  var duration = minDropTime + dropTimeRange * percentage;\n  var withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;\n  return Number(withDuration.toFixed(2));\n});\n\nvar getNewHomeClientOffset = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      dimensions = _ref.dimensions,\n      viewport = _ref.viewport,\n      onLift = _ref.onLift;\n  var draggables = dimensions.draggables,\n      droppables = dimensions.droppables;\n  var droppableId = whatIsDraggedOver(impact);\n  var destination = droppableId ? droppables[droppableId] : null;\n  var home = droppables[draggable.descriptor.droppableId];\n  var newClientCenter = getClientBorderBoxCenter({\n    impact: impact,\n    draggable: draggable,\n    draggables: draggables,\n    onLift: onLift,\n    droppable: destination || home,\n    viewport: viewport\n  });\n  var offset = subtract(newClientCenter, draggable.client.borderBox.center);\n  var merge = impact.merge;\n\n  if (merge && didStartDisplaced(merge.combine.draggableId, onLift)) {\n    return subtract(offset, onLift.displacedBy.point);\n  }\n\n  return offset;\n});\n\nvar getDropImpact = (function (_ref) {\n  var reason = _ref.reason,\n      lastImpact = _ref.lastImpact,\n      home = _ref.home,\n      viewport = _ref.viewport,\n      draggables = _ref.draggables,\n      onLiftImpact = _ref.onLiftImpact,\n      onLift = _ref.onLift;\n  var didDropInsideDroppable = reason === 'DROP' && Boolean(whatIsDraggedOver(lastImpact));\n\n  if (!didDropInsideDroppable) {\n    var impact = recompute({\n      impact: onLiftImpact,\n      destination: home,\n      viewport: viewport,\n      draggables: draggables,\n      onLift: onLift,\n      forceShouldAnimate: true\n    });\n    return {\n      impact: impact,\n      didDropInsideDroppable: didDropInsideDroppable\n    };\n  }\n\n  if (lastImpact.destination) {\n    return {\n      impact: lastImpact,\n      didDropInsideDroppable: didDropInsideDroppable\n    };\n  }\n\n  var withoutMovement = _extends({}, lastImpact, {\n    movement: noMovement\n  });\n\n  return {\n    impact: withoutMovement,\n    didDropInsideDroppable: didDropInsideDroppable\n  };\n});\n\nvar drop$1 = (function (_ref) {\n  var getState = _ref.getState,\n      dispatch = _ref.dispatch;\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP') {\n        next(action);\n        return;\n      }\n\n      var state = getState();\n      var reason = action.payload.reason;\n\n      if (state.phase === 'COLLECTING') {\n        dispatch(dropPending({\n          reason: reason\n        }));\n        return;\n      }\n\n      if (state.phase === 'IDLE') {\n        return;\n      }\n\n      var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\n      !!isWaitingForDrop ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : invariant(false) : void 0;\n      !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot drop in phase: \" + state.phase) : invariant(false) : void 0;\n      var critical = state.critical;\n      var dimensions = state.dimensions;\n\n      var _getDropImpact = getDropImpact({\n        reason: reason,\n        lastImpact: state.impact,\n        onLift: state.onLift,\n        onLiftImpact: state.onLiftImpact,\n        home: state.dimensions.droppables[state.critical.droppable.id],\n        viewport: state.viewport,\n        draggables: state.dimensions.draggables\n      }),\n          impact = _getDropImpact.impact,\n          didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;\n\n      var draggable = dimensions.draggables[state.critical.draggable.id];\n      var destination = didDropInsideDroppable ? impact.destination : null;\n      var combine = didDropInsideDroppable && impact.merge ? impact.merge.combine : null;\n      var source = {\n        index: critical.draggable.index,\n        droppableId: critical.droppable.id\n      };\n      var result = {\n        draggableId: draggable.descriptor.id,\n        type: draggable.descriptor.type,\n        source: source,\n        reason: reason,\n        mode: state.movementMode,\n        destination: destination,\n        combine: combine\n      };\n      var newHomeClientOffset = getNewHomeClientOffset({\n        impact: impact,\n        draggable: draggable,\n        dimensions: dimensions,\n        viewport: state.viewport,\n        onLift: state.onLift\n      });\n      var completed = {\n        critical: state.critical,\n        result: result,\n        impact: impact\n      };\n      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n\n      if (!isAnimationRequired) {\n        dispatch(completeDrop({\n          completed: completed,\n          shouldFlush: false\n        }));\n        return;\n      }\n\n      var dropDuration = getDropDuration({\n        current: state.current.client.offset,\n        destination: newHomeClientOffset,\n        reason: reason\n      });\n      var args = {\n        newHomeClientOffset: newHomeClientOffset,\n        dropDuration: dropDuration,\n        completed: completed\n      };\n      dispatch(animateDrop(args));\n    };\n  };\n});\n\nvar position = function position(index) {\n  return index + 1;\n};\n\nvar onDragStart = function onDragStart(start) {\n  return \"\\n  You have lifted an item in position \" + position(start.source.index) + \".\\n  Use the arrow keys to move, space bar to drop, and escape to cancel.\\n\";\n};\n\nvar withLocation = function withLocation(source, destination) {\n  var isInHomeList = source.droppableId === destination.droppableId;\n  var startPosition = position(source.index);\n  var endPosition = position(destination.index);\n\n  if (isInHomeList) {\n    return \"\\n      You have moved the item from position \" + startPosition + \"\\n      to position \" + endPosition + \"\\n    \";\n  }\n\n  return \"\\n    You have moved the item from position \" + startPosition + \"\\n    in list \" + source.droppableId + \"\\n    to list \" + destination.droppableId + \"\\n    in position \" + endPosition + \"\\n  \";\n};\n\nvar withCombine = function withCombine(id, source, combine) {\n  var inHomeList = source.droppableId === combine.droppableId;\n\n  if (inHomeList) {\n    return \"\\n      The item \" + id + \"\\n      has been combined with \" + combine.draggableId;\n  }\n\n  return \"\\n      The item \" + id + \"\\n      in list \" + source.droppableId + \"\\n      has been combined with \" + combine.draggableId + \"\\n      in list \" + combine.droppableId + \"\\n    \";\n};\n\nvar onDragUpdate = function onDragUpdate(update) {\n  var location = update.destination;\n\n  if (location) {\n    return withLocation(update.source, location);\n  }\n\n  var combine = update.combine;\n\n  if (combine) {\n    return withCombine(update.draggableId, update.source, combine);\n  }\n\n  return 'You are over an area that cannot be dropped on';\n};\n\nvar returnedToStart = function returnedToStart(source) {\n  return \"\\n  The item has returned to its starting position\\n  of \" + position(source.index) + \"\\n\";\n};\n\nvar onDragEnd = function onDragEnd(result) {\n  if (result.reason === 'CANCEL') {\n    return \"\\n      Movement cancelled.\\n      \" + returnedToStart(result.source) + \"\\n    \";\n  }\n\n  var location = result.destination;\n  var combine = result.combine;\n\n  if (location) {\n    return \"\\n      You have dropped the item.\\n      \" + withLocation(result.source, location) + \"\\n    \";\n  }\n\n  if (combine) {\n    return \"\\n      You have dropped the item.\\n      \" + withCombine(result.draggableId, result.source, combine) + \"\\n    \";\n  }\n\n  return \"\\n    The item has been dropped while not over a drop area.\\n    \" + returnedToStart(result.source) + \"\\n  \";\n};\n\nvar preset = {\n  onDragStart: onDragStart,\n  onDragUpdate: onDragUpdate,\n  onDragEnd: onDragEnd\n};\n\nvar getExpiringAnnounce = (function (announce) {\n  var wasCalled = false;\n  var isExpired = false;\n  var timeoutId = setTimeout(function () {\n    isExpired = true;\n  });\n\n  var result = function result(message) {\n    if (wasCalled) {\n      process.env.NODE_ENV !== \"production\" ? warning('Announcement already made. Not making a second announcement') : void 0;\n      return;\n    }\n\n    if (isExpired) {\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Announcements cannot be made asynchronously.\\n        Default message has already been announced.\\n      \") : void 0;\n      return;\n    }\n\n    wasCalled = true;\n    announce(message);\n    clearTimeout(timeoutId);\n  };\n\n  result.wasCalled = function () {\n    return wasCalled;\n  };\n\n  return result;\n});\n\nvar getAsyncMarshal = (function () {\n  var entries = [];\n\n  var execute = function execute(timerId) {\n    var index = findIndex(entries, function (item) {\n      return item.timerId === timerId;\n    });\n    !(index !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find timer') : invariant(false) : void 0;\n\n    var _entries$splice = entries.splice(index, 1),\n        entry = _entries$splice[0];\n\n    entry.callback();\n  };\n\n  var add = function add(fn) {\n    var timerId = setTimeout(function () {\n      return execute(timerId);\n    });\n    var entry = {\n      timerId: timerId,\n      callback: fn\n    };\n    entries.push(entry);\n  };\n\n  var flush = function flush() {\n    if (!entries.length) {\n      return;\n    }\n\n    var shallow = [].concat(entries);\n    entries.length = 0;\n    shallow.forEach(function (entry) {\n      clearTimeout(entry.timerId);\n      entry.callback();\n    });\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n});\n\nvar areLocationsEqual = function areLocationsEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.droppableId === second.droppableId && first.index === second.index;\n};\nvar isCombineEqual = function isCombineEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nvar isCriticalEqual = function isCriticalEqual(first, second) {\n  if (first === second) {\n    return true;\n  }\n\n  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n  return isDraggableEqual && isDroppableEqual;\n};\n\nvar withTimings = function withTimings(key, fn) {\n  start(key);\n  fn();\n  finish(key);\n};\n\nvar getDragStart = function getDragStart(critical, mode) {\n  return {\n    draggableId: critical.draggable.id,\n    type: critical.droppable.type,\n    source: {\n      droppableId: critical.droppable.id,\n      index: critical.draggable.index\n    },\n    mode: mode\n  };\n};\n\nvar execute = function execute(responder, data, announce, getDefaultMessage) {\n  if (!responder) {\n    announce(getDefaultMessage(data));\n    return;\n  }\n\n  var willExpire = getExpiringAnnounce(announce);\n  var provided = {\n    announce: willExpire\n  };\n  responder(data, provided);\n\n  if (!willExpire.wasCalled()) {\n    announce(getDefaultMessage(data));\n  }\n};\n\nvar getPublisher = (function (getResponders, announce) {\n  var asyncMarshal = getAsyncMarshal();\n  var dragging = null;\n\n  var beforeStart = function beforeStart(critical, mode) {\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\n    withTimings('onBeforeDragStart', function () {\n      var fn = getResponders().onBeforeDragStart;\n\n      if (fn) {\n        fn(getDragStart(critical, mode));\n      }\n    });\n  };\n\n  var start = function start(critical, mode) {\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\n    var data = getDragStart(critical, mode);\n    dragging = {\n      mode: mode,\n      lastCritical: critical,\n      lastLocation: data.source,\n      lastCombine: null\n    };\n    asyncMarshal.add(function () {\n      withTimings('onDragStart', function () {\n        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);\n      });\n    });\n  };\n\n  var update = function update(critical, impact) {\n    var location = impact.destination;\n    var combine = impact.merge ? impact.merge.combine : null;\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : invariant(false) : void 0;\n    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n\n    if (hasCriticalChanged) {\n      dragging.lastCritical = critical;\n    }\n\n    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n\n    if (hasLocationChanged) {\n      dragging.lastLocation = location;\n    }\n\n    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n\n    if (hasGroupingChanged) {\n      dragging.lastCombine = combine;\n    }\n\n    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n      return;\n    }\n\n    var data = _extends({}, getDragStart(critical, dragging.mode), {\n      combine: combine,\n      destination: location\n    });\n\n    asyncMarshal.add(function () {\n      withTimings('onDragUpdate', function () {\n        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);\n      });\n    });\n  };\n\n  var flush = function flush() {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only flush responders while dragging') : invariant(false) : void 0;\n    asyncMarshal.flush();\n  };\n\n  var drop = function drop(result) {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : invariant(false) : void 0;\n    dragging = null;\n    withTimings('onDragEnd', function () {\n      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);\n    });\n  };\n\n  var abort = function abort() {\n    if (!dragging) {\n      return;\n    }\n\n    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {\n      combine: null,\n      destination: null,\n      reason: 'CANCEL'\n    });\n\n    drop(result);\n  };\n\n  return {\n    beforeStart: beforeStart,\n    start: start,\n    update: update,\n    flush: flush,\n    drop: drop,\n    abort: abort\n  };\n});\n\nvar responders = (function (getResponders, announce) {\n  var publisher = getPublisher(getResponders, announce);\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          var critical = action.payload.critical;\n          publisher.beforeStart(critical, action.payload.movementMode);\n          next(action);\n          publisher.start(critical, action.payload.movementMode);\n          return;\n        }\n\n        if (action.type === 'DROP_COMPLETE') {\n          var result = action.payload.completed.result;\n          publisher.flush();\n          next(action);\n          publisher.drop(result);\n          return;\n        }\n\n        next(action);\n\n        if (action.type === 'CLEAN') {\n          publisher.abort();\n          return;\n        }\n\n        var state = store.getState();\n\n        if (state.phase === 'DRAGGING') {\n          publisher.update(state.critical, state.impact);\n        }\n      };\n    };\n  };\n});\n\nvar dropAnimationFinish = (function (store) {\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP_ANIMATION_FINISHED') {\n        next(action);\n        return;\n      }\n\n      var state = store.getState();\n      !(state.phase === 'DROP_ANIMATING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : invariant(false) : void 0;\n      store.dispatch(completeDrop({\n        completed: state.completed,\n        shouldFlush: false\n      }));\n    };\n  };\n});\n\nvar dimensionMarshalStopper = (function (marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'DROP_COMPLETE' || action.type === 'CLEAN' || action.type === 'DROP_ANIMATE') {\n          marshal.stopPublishing();\n        }\n\n        next(action);\n      };\n    };\n  };\n});\n\nvar shouldEnd = function shouldEnd(action) {\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'CLEAN';\n};\n\nvar shouldCancelPending = function shouldCancelPending(action) {\n  return action.type === 'COLLECTION_STARTING';\n};\n\nvar autoScroll = (function (autoScroller) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (shouldEnd(action)) {\n          autoScroller.stop();\n          next(action);\n          return;\n        }\n\n        if (shouldCancelPending(action)) {\n          autoScroller.cancelPending();\n          next(action);\n          return;\n        }\n\n        if (action.type === 'INITIAL_PUBLISH') {\n          next(action);\n          var state = store.getState();\n          !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : invariant(false) : void 0;\n          autoScroller.start(state);\n          return;\n        }\n\n        next(action);\n        autoScroller.scroll(store.getState());\n      };\n    };\n  };\n});\n\nvar pendingDrop = (function (store) {\n  return function (next) {\n    return function (action) {\n      next(action);\n\n      if (action.type !== 'PUBLISH_WHILE_DRAGGING') {\n        return;\n      }\n\n      var postActionState = store.getState();\n\n      if (postActionState.phase !== 'DROP_PENDING') {\n        return;\n      }\n\n      if (postActionState.isWaiting) {\n        return;\n      }\n\n      store.dispatch(drop({\n        reason: postActionState.reason\n      }));\n    };\n  };\n});\n\nvar composeEnhancers = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\nvar createStore = (function (_ref) {\n  var dimensionMarshal = _ref.dimensionMarshal,\n      styleMarshal = _ref.styleMarshal,\n      getResponders = _ref.getResponders,\n      announce = _ref.announce,\n      autoScroller = _ref.autoScroller;\n  return createStore$1(reducer, composeEnhancers(applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, pendingDrop, autoScroll(autoScroller), responders(getResponders, announce))));\n});\n\nvar clean$2 = function clean() {\n  return {\n    additions: {},\n    removals: {},\n    modified: {}\n  };\n};\n\nvar timingKey = 'Publish collection from DOM';\nvar createPublisher = (function (_ref) {\n  var getEntries = _ref.getEntries,\n      callbacks = _ref.callbacks;\n\n  var advancedUsageWarning = function () {\n    if (process.env.NODE_ENV === 'production') {\n      return function () {};\n    }\n\n    var hasAnnounced = false;\n    return function () {\n      if (hasAnnounced) {\n        return;\n      }\n\n      hasAnnounced = true;\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Advanced usage warning: you are adding or removing a dimension during a drag\\n        This an advanced feature.\\n\\n        More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/changes-while-dragging.md\\n      \") : void 0;\n    };\n  }();\n\n  var staging = clean$2();\n  var frameId = null;\n\n  var collect = function collect() {\n    advancedUsageWarning();\n\n    if (frameId) {\n      return;\n    }\n\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      callbacks.collectionStarting();\n      var critical = callbacks.getCritical();\n      start(timingKey);\n      var entries = getEntries();\n      var _staging = staging,\n          additions = _staging.additions,\n          removals = _staging.removals,\n          modified = _staging.modified;\n\n      var added = _Object$keys(additions).map(function (id) {\n        return entries.draggables[id].getDimension(origin);\n      }).sort(function (a, b) {\n        return a.descriptor.index - b.descriptor.index;\n      });\n\n      var updated = _Object$keys(modified).map(function (id) {\n        var entry = entries.droppables[id];\n        !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find dynamically added droppable in cache') : invariant(false) : void 0;\n        var isHome = entry.descriptor.id === critical.droppable.id;\n        var options = {\n          withoutPlaceholder: !isHome\n        };\n        return entry.callbacks.recollect(options);\n      });\n\n      var result = {\n        additions: added,\n        removals: _Object$keys(removals),\n        modified: updated\n      };\n      staging = clean$2();\n      finish(timingKey);\n      callbacks.publish(result);\n    });\n  };\n\n  var add = function add(descriptor) {\n    staging.additions[descriptor.id] = descriptor;\n    staging.modified[descriptor.droppableId] = true;\n\n    if (staging.removals[descriptor.id]) {\n      delete staging.removals[descriptor.id];\n    }\n\n    collect();\n  };\n\n  var remove = function remove(descriptor) {\n    staging.removals[descriptor.id] = descriptor;\n    staging.modified[descriptor.droppableId] = true;\n\n    if (staging.additions[descriptor.id]) {\n      delete staging.additions[descriptor.id];\n    }\n\n    collect();\n  };\n\n  var stop = function stop() {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n    staging = clean$2();\n  };\n\n  return {\n    add: add,\n    remove: remove,\n    stop: stop\n  };\n});\n\nvar getWindowScroll = (function () {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  };\n});\n\nvar getDocumentElement = (function () {\n  var doc = document.documentElement;\n  !doc ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find document.documentElement') : invariant(false) : void 0;\n  return doc;\n});\n\nvar getMaxWindowScroll = (function () {\n  var doc = getDocumentElement();\n  var maxScroll = getMaxScroll({\n    scrollHeight: doc.scrollHeight,\n    scrollWidth: doc.scrollWidth,\n    width: doc.clientWidth,\n    height: doc.clientHeight\n  });\n  return maxScroll;\n});\n\nvar getViewport = (function () {\n  var scroll = getWindowScroll();\n  var maxScroll = getMaxWindowScroll();\n  var top = scroll.y;\n  var left = scroll.x;\n  var doc = getDocumentElement();\n  var width = doc.clientWidth;\n  var height = doc.clientHeight;\n  var right = left + width;\n  var bottom = top + height;\n  var frame = getRect({\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom\n  });\n  var viewport = {\n    frame: frame,\n    scroll: {\n      initial: scroll,\n      current: scroll,\n      max: maxScroll,\n      diff: {\n        value: origin,\n        displacement: origin\n      }\n    }\n  };\n  return viewport;\n});\n\nvar getInitialPublish = (function (_ref) {\n  var critical = _ref.critical,\n      scrollOptions = _ref.scrollOptions,\n      entries = _ref.entries;\n  var timingKey = 'Initial collection from DOM';\n  start(timingKey);\n  var viewport = getViewport();\n  var windowScroll = viewport.scroll.current;\n  var home = critical.droppable;\n  var droppables = values(entries.droppables).filter(function (entry) {\n    return entry.descriptor.type === home.type;\n  }).map(function (entry) {\n    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\n  });\n  var draggables = values(entries.draggables).filter(function (entry) {\n    return entry.descriptor.type === critical.draggable.type;\n  }).map(function (entry) {\n    return entry.getDimension(windowScroll);\n  });\n  var dimensions = {\n    draggables: toDraggableMap(draggables),\n    droppables: toDroppableMap(droppables)\n  };\n  finish(timingKey);\n  var result = {\n    dimensions: dimensions,\n    critical: critical,\n    viewport: viewport\n  };\n  return result;\n});\n\nvar throwIfAddOrRemoveOfWrongType = function throwIfAddOrRemoveOfWrongType(collection, descriptor) {\n  !(collection.critical.draggable.type === descriptor.type) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"We have detected that you have added a Draggable during a drag.\\n      This is not of the same type as the dragging item\\n\\n      Dragging type: \" + collection.critical.draggable.type + \".\\n      Added type: \" + descriptor.type + \"\\n\\n      We are not allowing this as you can run into problems if your change\\n      has shifted the positioning of other Droppables, or has changed the size of the page\") : invariant(false) : void 0;\n};\n\nvar createDimensionMarshal = (function (callbacks) {\n  var entries = {\n    droppables: {},\n    draggables: {}\n  };\n  var collection = null;\n  var publisher = createPublisher({\n    callbacks: {\n      publish: callbacks.publishWhileDragging,\n      collectionStarting: callbacks.collectionStarting,\n      getCritical: function getCritical() {\n        !collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get critical when there is no collection') : invariant(false) : void 0;\n        return collection.critical;\n      }\n    },\n    getEntries: function getEntries() {\n      return entries;\n    }\n  });\n\n  var registerDraggable = function registerDraggable(descriptor, getDimension) {\n    var entry = {\n      descriptor: descriptor,\n      getDimension: getDimension\n    };\n    entries.draggables[descriptor.id] = entry;\n\n    if (!collection) {\n      return;\n    }\n\n    throwIfAddOrRemoveOfWrongType(collection, descriptor);\n    publisher.add(descriptor);\n  };\n\n  var updateDraggable = function updateDraggable(published, descriptor, getDimension) {\n    var existing = entries.draggables[published.id];\n    !existing ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot update draggable registration as no published registration was found') : invariant(false) : void 0;\n\n    if (existing.descriptor === published) {\n      delete entries.draggables[published.id];\n    } else {\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Detected incorrect usage of 'key' on '<Draggable draggableId=\\\"\" + published.id + \"\\\"$ />\\n\\n        Your 'key' should be:\\n        - Unique for each Draggable in a list\\n        - Not be based on the index of the Draggable\\n\\n        Usually you want your 'key' to just be the 'draggableId'\\n\\n        More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/draggable.md#keys-for-a-list-of-draggable-\\n      \") : void 0;\n    }\n\n    var entry = {\n      descriptor: descriptor,\n      getDimension: getDimension\n    };\n    entries.draggables[descriptor.id] = entry;\n  };\n\n  var unregisterDraggable = function unregisterDraggable(descriptor) {\n    var entry = entries.draggables[descriptor.id];\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot unregister Draggable with id:\\n      \" + descriptor.id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (entry.descriptor !== descriptor) {\n      return;\n    }\n\n    delete entries.draggables[descriptor.id];\n\n    if (!collection) {\n      return;\n    }\n\n    !(collection.critical.draggable.id !== descriptor.id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot remove the dragging item during a drag') : invariant(false) : void 0;\n    throwIfAddOrRemoveOfWrongType(collection, descriptor);\n    publisher.remove(descriptor);\n  };\n\n  var registerDroppable = function registerDroppable(descriptor, droppableCallbacks) {\n    var id = descriptor.id;\n    entries.droppables[id] = {\n      descriptor: descriptor,\n      callbacks: droppableCallbacks\n    };\n    !!collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot add a Droppable during a drag') : invariant(false) : void 0;\n  };\n\n  var unregisterDroppable = function unregisterDroppable(descriptor) {\n    var entry = entries.droppables[descriptor.id];\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot unregister Droppable with id \" + descriptor.id + \" as as it is not registered\") : invariant(false) : void 0;\n\n    if (entry.descriptor !== descriptor) {\n      return;\n    }\n\n    delete entries.droppables[descriptor.id];\n    !!collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot add a Droppable during a drag') : invariant(false) : void 0;\n  };\n\n  var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\n    !entries.droppables[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update is enabled flag of Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    callbacks.updateDroppableIsEnabled({\n      id: id,\n      isEnabled: isEnabled\n    });\n  };\n\n  var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {\n    !entries.droppables[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update isCombineEnabled flag of Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    callbacks.updateDroppableIsCombineEnabled({\n      id: id,\n      isCombineEnabled: isCombineEnabled\n    });\n  };\n\n  var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\n    !entries.droppables[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update the scroll on Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    callbacks.updateDroppableScroll({\n      id: id,\n      offset: newScroll\n    });\n  };\n\n  var scrollDroppable = function scrollDroppable(id, change) {\n    var entry = entries.droppables[id];\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot scroll Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    entry.callbacks.scroll(change);\n  };\n\n  var stopPublishing = function stopPublishing() {\n    if (!collection) {\n      return;\n    }\n\n    publisher.stop();\n    var home = collection.critical.droppable;\n    values(entries.droppables).filter(function (entry) {\n      return entry.descriptor.type === home.type;\n    }).forEach(function (entry) {\n      return entry.callbacks.dragStopped();\n    });\n    collection = null;\n  };\n\n  var startPublishing = function startPublishing(request) {\n    !!collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : invariant(false) : void 0;\n    var entry = entries.draggables[request.draggableId];\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find critical draggable entry') : invariant(false) : void 0;\n    var home = entries.droppables[entry.descriptor.droppableId];\n    !home ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find critical droppable entry') : invariant(false) : void 0;\n    var critical = {\n      draggable: entry.descriptor,\n      droppable: home.descriptor\n    };\n    collection = {\n      critical: critical\n    };\n    return getInitialPublish({\n      critical: critical,\n      entries: entries,\n      scrollOptions: request.scrollOptions\n    });\n  };\n\n  var marshal = {\n    registerDraggable: registerDraggable,\n    updateDraggable: updateDraggable,\n    unregisterDraggable: unregisterDraggable,\n    registerDroppable: registerDroppable,\n    unregisterDroppable: unregisterDroppable,\n    updateDroppableIsEnabled: updateDroppableIsEnabled,\n    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n    scrollDroppable: scrollDroppable,\n    updateDroppableScroll: updateDroppableScroll,\n    startPublishing: startPublishing,\n    stopPublishing: stopPublishing\n  };\n  return marshal;\n});\n\nvar canStartDrag = (function (state, id) {\n  if (state.phase === 'IDLE') {\n    return true;\n  }\n\n  if (state.phase !== 'DROP_ANIMATING') {\n    return false;\n  }\n\n  if (state.completed.result.draggableId === id) {\n    return false;\n  }\n\n  return state.completed.result.reason === 'DROP';\n});\n\nvar scrollWindow = (function (change) {\n  window.scrollBy(change.x, change.y);\n});\n\nvar getScrollableDroppables = memoizeOne(function (droppables) {\n  return toDroppableList(droppables).filter(function (droppable) {\n    if (!droppable.isEnabled) {\n      return false;\n    }\n\n    if (!droppable.frame) {\n      return false;\n    }\n\n    return true;\n  });\n});\n\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\n  var maybe = find(getScrollableDroppables(droppables), function (droppable) {\n    !droppable.frame ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid result') : invariant(false) : void 0;\n    return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n  });\n  return maybe;\n};\n\nvar getBestScrollableDroppable = (function (_ref) {\n  var center = _ref.center,\n      destination = _ref.destination,\n      droppables = _ref.droppables;\n\n  if (destination) {\n    var _dimension = droppables[destination];\n\n    if (!_dimension.frame) {\n      return null;\n    }\n\n    return _dimension;\n  }\n\n  var dimension = getScrollableDroppableOver(center, droppables);\n  return dimension;\n});\n\nvar config = {\n  startFromPercentage: 0.25,\n  maxScrollAtPercentage: 0.05,\n  maxPixelScroll: 28,\n  ease: function ease(percentage) {\n    return Math.pow(percentage, 2);\n  },\n  durationDampening: {\n    stopDampeningAt: 1200,\n    accelerateAt: 360\n  }\n};\n\nvar getDistanceThresholds = (function (container, axis) {\n  var startScrollingFrom = container[axis.size] * config.startFromPercentage;\n  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;\n  var thresholds = {\n    startScrollingFrom: startScrollingFrom,\n    maxScrollValueAt: maxScrollValueAt\n  };\n  return thresholds;\n});\n\nvar getPercentage = (function (_ref) {\n  var startOfRange = _ref.startOfRange,\n      endOfRange = _ref.endOfRange,\n      current = _ref.current;\n  var range = endOfRange - startOfRange;\n\n  if (range === 0) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Detected distance range of 0 in the fluid auto scroller\\n      This is unexpected and would cause a divide by 0 issue.\\n      Not allowing an auto scroll\\n    \") : void 0;\n    return 0;\n  }\n\n  var currentInRange = current - startOfRange;\n  var percentage = currentInRange / range;\n  return percentage;\n});\n\nvar minScroll = 1;\n\nvar getValueFromDistance = (function (distanceToEdge, thresholds) {\n  if (distanceToEdge > thresholds.startScrollingFrom) {\n    return 0;\n  }\n\n  if (distanceToEdge <= thresholds.maxScrollValueAt) {\n    return config.maxPixelScroll;\n  }\n\n  if (distanceToEdge === thresholds.startScrollingFrom) {\n    return minScroll;\n  }\n\n  var percentageFromMaxScrollValueAt = getPercentage({\n    startOfRange: thresholds.maxScrollValueAt,\n    endOfRange: thresholds.startScrollingFrom,\n    current: distanceToEdge\n  });\n  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n  var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);\n  return Math.ceil(scroll);\n});\n\nvar accelerateAt = config.durationDampening.accelerateAt;\nvar stopAt = config.durationDampening.stopDampeningAt;\nvar dampenValueByTime = (function (proposedScroll, dragStartTime) {\n  var startOfRange = dragStartTime;\n  var endOfRange = stopAt;\n\n  var now = _Date$now();\n\n  var runTime = now - startOfRange;\n\n  if (runTime >= stopAt) {\n    return proposedScroll;\n  }\n\n  if (runTime < accelerateAt) {\n    return minScroll;\n  }\n\n  var betweenAccelerateAtAndStopAtPercentage = getPercentage({\n    startOfRange: accelerateAt,\n    endOfRange: endOfRange,\n    current: runTime\n  });\n  var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);\n  return Math.ceil(scroll);\n});\n\nvar getValue = (function (_ref) {\n  var distanceToEdge = _ref.distanceToEdge,\n      thresholds = _ref.thresholds,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var scroll = getValueFromDistance(distanceToEdge, thresholds);\n\n  if (scroll === 0) {\n    return 0;\n  }\n\n  if (!shouldUseTimeDampening) {\n    return scroll;\n  }\n\n  return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);\n});\n\nvar getScrollOnAxis = (function (_ref) {\n  var container = _ref.container,\n      distanceToEdges = _ref.distanceToEdges,\n      dragStartTime = _ref.dragStartTime,\n      axis = _ref.axis,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var thresholds = getDistanceThresholds(container, axis);\n  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n\n  if (isCloserToEnd) {\n    return getValue({\n      distanceToEdge: distanceToEdges[axis.end],\n      thresholds: thresholds,\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n  }\n\n  return -1 * getValue({\n    distanceToEdge: distanceToEdges[axis.start],\n    thresholds: thresholds,\n    dragStartTime: dragStartTime,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n});\n\nvar adjustForSizeLimits = (function (_ref) {\n  var container = _ref.container,\n      subject = _ref.subject,\n      proposedScroll = _ref.proposedScroll;\n  var isTooBigVertically = subject.height > container.height;\n  var isTooBigHorizontally = subject.width > container.width;\n\n  if (!isTooBigHorizontally && !isTooBigVertically) {\n    return proposedScroll;\n  }\n\n  if (isTooBigHorizontally && isTooBigVertically) {\n    return null;\n  }\n\n  return {\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\n    y: isTooBigVertically ? 0 : proposedScroll.y\n  };\n});\n\nvar clean$3 = apply(function (value) {\n  return value === 0 ? 0 : value;\n});\nvar getScroll = (function (_ref) {\n  var dragStartTime = _ref.dragStartTime,\n      container = _ref.container,\n      subject = _ref.subject,\n      center = _ref.center,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var distanceToEdges = {\n    top: center.y - container.top,\n    right: container.right - center.x,\n    bottom: container.bottom - center.y,\n    left: center.x - container.left\n  };\n  var y = getScrollOnAxis({\n    container: container,\n    distanceToEdges: distanceToEdges,\n    dragStartTime: dragStartTime,\n    axis: vertical,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  var x = getScrollOnAxis({\n    container: container,\n    distanceToEdges: distanceToEdges,\n    dragStartTime: dragStartTime,\n    axis: horizontal,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  var required = clean$3({\n    x: x,\n    y: y\n  });\n\n  if (isEqual(required, origin)) {\n    return null;\n  }\n\n  var limited = adjustForSizeLimits({\n    container: container,\n    subject: subject,\n    proposedScroll: required\n  });\n\n  if (!limited) {\n    return null;\n  }\n\n  return isEqual(limited, origin) ? null : limited;\n});\n\nvar smallestSigned = apply(function (value) {\n  if (value === 0) {\n    return 0;\n  }\n\n  return value > 0 ? 1 : -1;\n});\nvar getOverlap = function () {\n  var getRemainder = function getRemainder(target, max) {\n    if (target < 0) {\n      return target;\n    }\n\n    if (target > max) {\n      return target - max;\n    }\n\n    return 0;\n  };\n\n  return function (_ref) {\n    var current = _ref.current,\n        max = _ref.max,\n        change = _ref.change;\n    var targetScroll = add(current, change);\n    var overlap = {\n      x: getRemainder(targetScroll.x, max.x),\n      y: getRemainder(targetScroll.y, max.y)\n    };\n\n    if (isEqual(overlap, origin)) {\n      return null;\n    }\n\n    return overlap;\n  };\n}();\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\n  var rawMax = _ref2.max,\n      current = _ref2.current,\n      change = _ref2.change;\n  var max = {\n    x: Math.max(current.x, rawMax.x),\n    y: Math.max(current.y, rawMax.y)\n  };\n  var smallestChange = smallestSigned(change);\n  var overlap = getOverlap({\n    max: max,\n    current: current,\n    change: smallestChange\n  });\n\n  if (!overlap) {\n    return true;\n  }\n\n  if (smallestChange.x !== 0 && overlap.x === 0) {\n    return true;\n  }\n\n  if (smallestChange.y !== 0 && overlap.y === 0) {\n    return true;\n  }\n\n  return false;\n};\nvar canScrollWindow = function canScrollWindow(viewport, change) {\n  return canPartiallyScroll({\n    current: viewport.scroll.current,\n    max: viewport.scroll.max,\n    change: change\n  });\n};\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\n  if (!canScrollWindow(viewport, change)) {\n    return null;\n  }\n\n  var max = viewport.scroll.max;\n  var current = viewport.scroll.current;\n  return getOverlap({\n    current: current,\n    max: max,\n    change: change\n  });\n};\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return false;\n  }\n\n  return canPartiallyScroll({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change: change\n  });\n};\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return null;\n  }\n\n  if (!canScrollDroppable(droppable, change)) {\n    return null;\n  }\n\n  return getOverlap({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change: change\n  });\n};\n\nvar getWindowScrollChange = (function (_ref) {\n  var viewport = _ref.viewport,\n      subject = _ref.subject,\n      center = _ref.center,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var scroll = getScroll({\n    dragStartTime: dragStartTime,\n    container: viewport.frame,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n});\n\nvar getDroppableScrollChange = (function (_ref) {\n  var droppable = _ref.droppable,\n      subject = _ref.subject,\n      center = _ref.center,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return null;\n  }\n\n  var scroll = getScroll({\n    dragStartTime: dragStartTime,\n    container: frame.pageMarginBox,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n});\n\nvar scroll$1 = (function (_ref) {\n  var state = _ref.state,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening,\n      scrollWindow = _ref.scrollWindow,\n      scrollDroppable = _ref.scrollDroppable;\n  var center = state.current.page.borderBoxCenter;\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\n  var subject = draggable.page.marginBox;\n\n  if (state.isWindowScrollAllowed) {\n    var viewport = state.viewport;\n\n    var _change = getWindowScrollChange({\n      dragStartTime: dragStartTime,\n      viewport: viewport,\n      subject: subject,\n      center: center,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n\n    if (_change) {\n      scrollWindow(_change);\n      return;\n    }\n  }\n\n  var droppable = getBestScrollableDroppable({\n    center: center,\n    destination: whatIsDraggedOver(state.impact),\n    droppables: state.dimensions.droppables\n  });\n\n  if (!droppable) {\n    return;\n  }\n\n  var change = getDroppableScrollChange({\n    dragStartTime: dragStartTime,\n    droppable: droppable,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n\n  if (change) {\n    scrollDroppable(droppable.descriptor.id, change);\n  }\n});\n\nvar createFluidScroller = (function (_ref) {\n  var scrollWindow = _ref.scrollWindow,\n      scrollDroppable = _ref.scrollDroppable;\n  var scheduleWindowScroll = rafSchd(scrollWindow);\n  var scheduleDroppableScroll = rafSchd(scrollDroppable);\n  var dragging = null;\n\n  var tryScroll = function tryScroll(state) {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fluid scroll if not dragging') : invariant(false) : void 0;\n    var _dragging = dragging,\n        shouldUseTimeDampening = _dragging.shouldUseTimeDampening,\n        dragStartTime = _dragging.dragStartTime;\n    scroll$1({\n      state: state,\n      scrollWindow: scheduleWindowScroll,\n      scrollDroppable: scheduleDroppableScroll,\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n  };\n\n  var cancelPending = function cancelPending() {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot cancel pending fluid scroll when not started') : invariant(false) : void 0;\n    scheduleWindowScroll.cancel();\n    scheduleDroppableScroll.cancel();\n  };\n\n  var start$1 = function start$1(state) {\n    start('starting fluid scroller');\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start auto scrolling when already started') : invariant(false) : void 0;\n\n    var dragStartTime = _Date$now();\n\n    var wasScrollNeeded = false;\n\n    var fakeScrollCallback = function fakeScrollCallback() {\n      wasScrollNeeded = true;\n    };\n\n    scroll$1({\n      state: state,\n      dragStartTime: 0,\n      shouldUseTimeDampening: false,\n      scrollWindow: fakeScrollCallback,\n      scrollDroppable: fakeScrollCallback\n    });\n    dragging = {\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: wasScrollNeeded\n    };\n    finish('starting fluid scroller');\n\n    if (wasScrollNeeded) {\n      tryScroll(state);\n    }\n  };\n\n  var stop = function stop() {\n    if (!dragging) {\n      return;\n    }\n\n    cancelPending();\n    dragging = null;\n  };\n\n  return {\n    start: start$1,\n    stop: stop,\n    cancelPending: cancelPending,\n    scroll: tryScroll\n  };\n});\n\nvar createJumpScroller = (function (_ref) {\n  var move = _ref.move,\n      scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow;\n\n  var moveByOffset = function moveByOffset(state, offset) {\n    var client = add(state.current.client.selection, offset);\n    move({\n      client: client\n    });\n  };\n\n  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\n    if (!canScrollDroppable(droppable, change)) {\n      return change;\n    }\n\n    var overlap = getDroppableOverlap(droppable, change);\n\n    if (!overlap) {\n      scrollDroppable(droppable.descriptor.id, change);\n      return null;\n    }\n\n    var whatTheDroppableCanScroll = subtract(change, overlap);\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n    var remainder = subtract(change, whatTheDroppableCanScroll);\n    return remainder;\n  };\n\n  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {\n    if (!isWindowScrollAllowed) {\n      return change;\n    }\n\n    if (!canScrollWindow(viewport, change)) {\n      return change;\n    }\n\n    var overlap = getWindowOverlap(viewport, change);\n\n    if (!overlap) {\n      scrollWindow(change);\n      return null;\n    }\n\n    var whatTheWindowCanScroll = subtract(change, overlap);\n    scrollWindow(whatTheWindowCanScroll);\n    var remainder = subtract(change, whatTheWindowCanScroll);\n    return remainder;\n  };\n\n  var jumpScroller = function jumpScroller(state) {\n    var request = state.scrollJumpRequest;\n\n    if (!request) {\n      return;\n    }\n\n    var destination = whatIsDraggedOver(state.impact);\n    !destination ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : invariant(false) : void 0;\n    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n\n    if (!droppableRemainder) {\n      return;\n    }\n\n    var viewport = state.viewport;\n    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n\n    if (!windowRemainder) {\n      return;\n    }\n\n    moveByOffset(state, windowRemainder);\n  };\n\n  return jumpScroller;\n});\n\nvar createAutoScroller = (function (_ref) {\n  var scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow,\n      move = _ref.move;\n  var fluidScroller = createFluidScroller({\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n  var jumpScroll = createJumpScroller({\n    move: move,\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n\n  var scroll = function scroll(state) {\n    if (state.phase !== 'DRAGGING') {\n      return;\n    }\n\n    if (state.movementMode === 'FLUID') {\n      fluidScroller.scroll(state);\n      return;\n    }\n\n    if (!state.scrollJumpRequest) {\n      return;\n    }\n\n    jumpScroll(state);\n  };\n\n  var scroller = {\n    scroll: scroll,\n    cancelPending: fluidScroller.cancelPending,\n    start: fluidScroller.start,\n    stop: fluidScroller.stop\n  };\n  return scroller;\n});\n\nvar prefix = 'data-react-beautiful-dnd';\nvar dragHandle = prefix + \"-drag-handle\";\nvar draggable = prefix + \"-draggable\";\nvar droppable = prefix + \"-droppable\";\n\nvar makeGetSelector = function makeGetSelector(context) {\n  return function (attribute) {\n    return \"[\" + attribute + \"=\\\"\" + context + \"\\\"]\";\n  };\n};\n\nvar getStyles = function getStyles(rules, property) {\n  return rules.map(function (rule) {\n    var value = rule.styles[property];\n\n    if (!value) {\n      return '';\n    }\n\n    return rule.selector + \" { \" + value + \" }\";\n  }).join(' ');\n};\n\nvar noPointerEvents = 'pointer-events: none;';\nvar getStyles$1 = (function (uniqueContext) {\n  var getSelector = makeGetSelector(uniqueContext);\n\n  var dragHandle$1 = function () {\n    var grabCursor = \"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \";\n    return {\n      selector: getSelector(dragHandle),\n      styles: {\n        always: \"\\n          -webkit-touch-callout: none;\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\n          touch-action: manipulation;\\n        \",\n        resting: grabCursor,\n        dragging: noPointerEvents,\n        dropAnimating: grabCursor\n      }\n    };\n  }();\n\n  var draggable$1 = function () {\n    var transition = \"\\n      transition: \" + transitions.outOfTheWay + \";\\n    \";\n    return {\n      selector: getSelector(draggable),\n      styles: {\n        dragging: transition,\n        dropAnimating: transition,\n        userCancel: transition\n      }\n    };\n  }();\n\n  var droppable$1 = {\n    selector: getSelector(droppable),\n    styles: {\n      always: \"overflow-anchor: none;\"\n    }\n  };\n  var body = {\n    selector: 'body',\n    styles: {\n      dragging: \"\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        overflow-anchor: none;\\n      \"\n    }\n  };\n  var rules = [draggable$1, dragHandle$1, droppable$1, body];\n  return {\n    always: getStyles(rules, 'always'),\n    resting: getStyles(rules, 'resting'),\n    dragging: getStyles(rules, 'dragging'),\n    dropAnimating: getStyles(rules, 'dropAnimating'),\n    userCancel: getStyles(rules, 'userCancel')\n  };\n});\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nvar getHead = function getHead() {\n  var head = document.querySelector('head');\n  !head ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find the head to append a style to') : invariant(false) : void 0;\n  return head;\n};\n\nvar createStyleEl = function createStyleEl() {\n  var el = document.createElement('style');\n  el.type = 'text/css';\n  return el;\n};\n\nfunction useStyleMarshal(uniqueId) {\n  var uniqueContext = useMemo(function () {\n    return \"\" + uniqueId;\n  }, [uniqueId]);\n  var styles = useMemo(function () {\n    return getStyles$1(uniqueContext);\n  }, [uniqueContext]);\n  var alwaysRef = useRef(null);\n  var dynamicRef = useRef(null);\n  var setDynamicStyle = useCallback(memoizeOne(function (proposed) {\n    var el = dynamicRef.current;\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\n    el.textContent = proposed;\n  }), []);\n  var setAlwaysStyle = useCallback(function (proposed) {\n    var el = alwaysRef.current;\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\n    el.textContent = proposed;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    !(!alwaysRef.current && !dynamicRef.current) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'style elements already mounted') : invariant(false) : void 0;\n    var always = createStyleEl();\n    var dynamic = createStyleEl();\n    alwaysRef.current = always;\n    dynamicRef.current = dynamic;\n    always.setAttribute(prefix + \"-always\", uniqueContext);\n    dynamic.setAttribute(prefix + \"-dynamic\", uniqueContext);\n    getHead().appendChild(always);\n    getHead().appendChild(dynamic);\n    setAlwaysStyle(styles.always);\n    setDynamicStyle(styles.resting);\n    return function () {\n      var remove = function remove(ref) {\n        var current = ref.current;\n        !current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unmount ref as it is not set') : invariant(false) : void 0;\n        getHead().removeChild(current);\n        ref.current = null;\n      };\n\n      remove(alwaysRef);\n      remove(dynamicRef);\n    };\n  }, [setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, uniqueContext]);\n  var dragging = useCallback(function () {\n    return setDynamicStyle(styles.dragging);\n  }, [setDynamicStyle, styles.dragging]);\n  var dropping = useCallback(function (reason) {\n    if (reason === 'DROP') {\n      setDynamicStyle(styles.dropAnimating);\n      return;\n    }\n\n    setDynamicStyle(styles.userCancel);\n  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);\n  var resting = useCallback(function () {\n    if (!dynamicRef.current) {\n      return;\n    }\n\n    setDynamicStyle(styles.resting);\n  }, [setDynamicStyle, styles.resting]);\n  var marshal = useMemo(function () {\n    return {\n      dragging: dragging,\n      dropping: dropping,\n      resting: resting,\n      styleContext: uniqueContext\n    };\n  }, [dragging, dropping, resting, uniqueContext]);\n  return marshal;\n}\n\nvar StoreContext = React.createContext(null);\n\nvar getBodyElement = (function () {\n  var body = document.body;\n  !body ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find document.body') : invariant(false) : void 0;\n  return body;\n});\n\nvar visuallyHidden = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  margin: '-1px',\n  border: '0',\n  padding: '0',\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  'clip-path': 'inset(100%)'\n};\nvar getId = function getId(uniqueId) {\n  return \"react-beautiful-dnd-announcement-\" + uniqueId;\n};\nfunction useAnnouncer(uniqueId) {\n  var id = useMemo(function () {\n    return getId(uniqueId);\n  }, [uniqueId]);\n  var ref = useRef(null);\n  useEffect(function () {\n    !!ref.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Announcement node already mounted') : invariant(false) : void 0;\n    var el = document.createElement('div');\n    ref.current = el;\n    el.id = id;\n    el.setAttribute('aria-live', 'assertive');\n    el.setAttribute('role', 'log');\n    el.setAttribute('aria-atomic', 'true');\n\n    _Object$assign(el.style, visuallyHidden);\n\n    getBodyElement().appendChild(el);\n    return function () {\n      var toBeRemoved = ref.current;\n      !toBeRemoved ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unmount announcement node') : invariant(false) : void 0;\n      getBodyElement().removeChild(toBeRemoved);\n      ref.current = null;\n    };\n  }, [id]);\n  var announce = useCallback(function (message) {\n    var el = ref.current;\n\n    if (el) {\n      el.textContent = message;\n      return;\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      A screen reader message was trying to be announced but it was unable to do so.\\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\\n      Consider calling provided.announce() before the unmount so that the instruction will\\n      not be lost for users relying on a screen reader.\\n\\n      Message not passed to screen reader:\\n\\n      \\\"\" + message + \"\\\"\\n    \") : void 0;\n  }, []);\n  return announce;\n}\n\nvar AppContext = React.createContext(null);\n\nvar peerDependencies = {\n\treact: \"^16.8.5\"\n};\n\nvar semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\n\nvar getVersion = function getVersion(value) {\n  var result = semver.exec(value);\n  !(result != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Unable to parse React version \" + value) : invariant(false) : void 0;\n  var major = Number(result[1]);\n  var minor = Number(result[2]);\n  var patch = Number(result[3]);\n  return {\n    major: major,\n    minor: minor,\n    patch: patch,\n    raw: value\n  };\n};\n\nvar isSatisfied = function isSatisfied(expected, actual) {\n  if (actual.major > expected.major) {\n    return true;\n  }\n\n  if (actual.major < expected.major) {\n    return false;\n  }\n\n  if (actual.minor > expected.minor) {\n    return true;\n  }\n\n  if (actual.minor < expected.minor) {\n    return false;\n  }\n\n  return actual.patch >= expected.patch;\n};\n\nvar checkReactVersion = (function (peerDepValue, actualValue) {\n  var peerDep = getVersion(peerDepValue);\n  var actual = getVersion(actualValue);\n\n  if (isSatisfied(peerDep, actual)) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    React version: [\" + actual.raw + \"]\\n    does not satisfy expected peer dependency version: [\" + peerDep.raw + \"]\\n\\n    This can result in run time bugs, and even fatal crashes\\n  \") : void 0;\n});\n\nvar suffix = \"\\n  We expect a html5 doctype: <!doctype html>\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\";\nvar checkDoctype = (function (doc) {\n  var doctype = doc.doctype;\n\n  if (!doctype) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      No <!doctype html> found.\\n\\n      \" + suffix + \"\\n    \") : void 0;\n    return;\n  }\n\n  if (doctype.name.toLowerCase() !== 'html') {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Unexpected <!doctype> found: (\" + doctype.name + \")\\n\\n      \" + suffix + \"\\n    \") : void 0;\n  }\n\n  if (doctype.publicId !== '') {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Unexpected <!doctype> publicId found: (\" + doctype.publicId + \")\\n      A html5 doctype does not have a publicId\\n\\n      \" + suffix + \"\\n    \") : void 0;\n  }\n});\n\nfunction useStartupValidation() {\n  useEffect(function () {\n    if (process.env.NODE_ENV === 'production') {\n      return;\n    }\n\n    checkReactVersion(peerDependencies.react, React.version);\n    checkDoctype(document);\n  }, []);\n}\n\nfunction usePrevious(current) {\n  var ref = useRef(current);\n  useEffect(function () {\n    ref.current = current;\n  });\n  return ref;\n}\n\nvar createResponders = function createResponders(props) {\n  return {\n    onBeforeDragStart: props.onBeforeDragStart,\n    onDragStart: props.onDragStart,\n    onDragEnd: props.onDragEnd,\n    onDragUpdate: props.onDragUpdate\n  };\n};\n\nfunction getStore(lazyRef) {\n  !lazyRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find store from lazy ref') : invariant(false) : void 0;\n  return lazyRef.current;\n}\n\nfunction App(props) {\n  var uniqueId = props.uniqueId,\n      setOnError = props.setOnError;\n  var lazyStoreRef = useRef(null);\n  useStartupValidation();\n  var lastPropsRef = usePrevious(props);\n  var getResponders = useCallback(function () {\n    return createResponders(lastPropsRef.current);\n  }, [lastPropsRef]);\n  var announce = useAnnouncer(uniqueId);\n  var styleMarshal = useStyleMarshal(uniqueId);\n  var lazyDispatch = useCallback(function (action) {\n    getStore(lazyStoreRef).dispatch(action);\n  }, []);\n  var callbacks = useMemo(function () {\n    return bindActionCreators({\n      publishWhileDragging: publishWhileDragging$1,\n      updateDroppableScroll: updateDroppableScroll,\n      updateDroppableIsEnabled: updateDroppableIsEnabled,\n      updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n      collectionStarting: collectionStarting\n    }, lazyDispatch);\n  }, [lazyDispatch]);\n  var dimensionMarshal = useMemo(function () {\n    return createDimensionMarshal(callbacks);\n  }, [callbacks]);\n  var autoScroller = useMemo(function () {\n    return createAutoScroller(_extends({\n      scrollWindow: scrollWindow,\n      scrollDroppable: dimensionMarshal.scrollDroppable\n    }, bindActionCreators({\n      move: move\n    }, lazyDispatch)));\n  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);\n  var store = useMemo(function () {\n    return createStore({\n      dimensionMarshal: dimensionMarshal,\n      styleMarshal: styleMarshal,\n      announce: announce,\n      autoScroller: autoScroller,\n      getResponders: getResponders\n    });\n  }, [announce, autoScroller, dimensionMarshal, getResponders, styleMarshal]);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n      process.env.NODE_ENV !== \"production\" ? warning('unexpected store change') : void 0;\n    }\n  }\n\n  lazyStoreRef.current = store;\n  var tryResetStore = useCallback(function () {\n    var current = getStore(lazyStoreRef);\n    var state = current.getState();\n\n    if (state.phase !== 'IDLE') {\n      current.dispatch(clean$1({\n        shouldFlush: true\n      }));\n    }\n  }, []);\n  setOnError(tryResetStore);\n  var getCanLift = useCallback(function (id) {\n    return canStartDrag(getStore(lazyStoreRef).getState(), id);\n  }, []);\n  var getIsMovementAllowed = useCallback(function () {\n    return isMovementAllowed(getStore(lazyStoreRef).getState());\n  }, []);\n  var appContext = useMemo(function () {\n    return {\n      marshal: dimensionMarshal,\n      style: styleMarshal.styleContext,\n      canLift: getCanLift,\n      isMovementAllowed: getIsMovementAllowed\n    };\n  }, [dimensionMarshal, getCanLift, getIsMovementAllowed, styleMarshal.styleContext]);\n  useEffect(function () {\n    return tryResetStore;\n  }, [tryResetStore]);\n  return React.createElement(AppContext.Provider, {\n    value: appContext\n  }, React.createElement(Provider, {\n    context: StoreContext,\n    store: store\n  }, props.children));\n}\n\nvar instanceCount = 0;\nfunction resetServerContext() {\n  instanceCount = 0;\n}\nfunction DragDropContext(props) {\n  var uniqueId = useMemo(function () {\n    return instanceCount++;\n  }, []);\n  return React.createElement(ErrorBoundary, null, function (setOnError) {\n    return React.createElement(App, _extends({\n      setOnError: setOnError,\n      uniqueId: uniqueId\n    }, props), props.children);\n  });\n}\n\nvar isEqual$2 = function isEqual(base) {\n  return function (value) {\n    return base === value;\n  };\n};\n\nvar isScroll = isEqual$2('scroll');\nvar isAuto = isEqual$2('auto');\nvar isVisible$1 = isEqual$2('visible');\n\nvar isEither = function isEither(overflow, fn) {\n  return fn(overflow.overflowX) || fn(overflow.overflowY);\n};\n\nvar isBoth = function isBoth(overflow, fn) {\n  return fn(overflow.overflowX) && fn(overflow.overflowY);\n};\n\nvar isElementScrollable = function isElementScrollable(el) {\n  var style = window.getComputedStyle(el);\n  var overflow = {\n    overflowX: style.overflowX,\n    overflowY: style.overflowY\n  };\n  return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\n\nvar isBodyScrollable = function isBodyScrollable() {\n  if (process.env.NODE_ENV === 'production') {\n    return false;\n  }\n\n  var body = getBodyElement();\n  var html = document.documentElement;\n  !html ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n\n  if (!isElementScrollable(body)) {\n    return false;\n  }\n\n  var htmlStyle = window.getComputedStyle(html);\n  var htmlOverflow = {\n    overflowX: htmlStyle.overflowX,\n    overflowY: htmlStyle.overflowY\n  };\n\n  if (isBoth(htmlOverflow, isVisible$1)) {\n    return false;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    We have detected that your <body> element might be a scroll container.\\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\\n\\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\\n    we will be treating the <body> as *not* a scroll container\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\n  \") : void 0;\n  return false;\n};\n\nvar getClosestScrollable = function getClosestScrollable(el) {\n  if (el == null) {\n    return null;\n  }\n\n  if (el === document.body) {\n    return isBodyScrollable() ? el : null;\n  }\n\n  if (el === document.documentElement) {\n    return null;\n  }\n\n  if (!isElementScrollable(el)) {\n    return getClosestScrollable(el.parentElement);\n  }\n\n  return el;\n};\n\nvar checkForNestedScrollContainers = (function (scrollable) {\n  if (!scrollable) {\n    return;\n  }\n\n  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n\n  if (!anotherScrollParent) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    Droppable: unsupported nested scroll container detected.\\n    A Droppable can only have one scroll parent (which can be itself)\\n    Nested scroll containers are currently not supported.\\n\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\n  \") : void 0;\n});\n\nvar getScroll$1 = (function (el) {\n  return {\n    x: el.scrollLeft,\n    y: el.scrollTop\n  };\n});\n\nvar getIsFixed = function getIsFixed(el) {\n  if (!el) {\n    return false;\n  }\n\n  var style = window.getComputedStyle(el);\n\n  if (style.position === 'fixed') {\n    return true;\n  }\n\n  return getIsFixed(el.parentElement);\n};\n\nvar getEnv = (function (start) {\n  var closestScrollable = getClosestScrollable(start);\n  var isFixedOnPage = getIsFixed(start);\n  return {\n    closestScrollable: closestScrollable,\n    isFixedOnPage: isFixedOnPage\n  };\n});\n\nvar getClient = function getClient(targetRef, closestScrollable) {\n  var base = getBox(targetRef);\n\n  if (!closestScrollable) {\n    return base;\n  }\n\n  if (targetRef !== closestScrollable) {\n    return base;\n  }\n\n  var top = base.paddingBox.top - closestScrollable.scrollTop;\n  var left = base.paddingBox.left - closestScrollable.scrollLeft;\n  var bottom = top + closestScrollable.scrollHeight;\n  var right = left + closestScrollable.scrollWidth;\n  var paddingBox = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n  var borderBox = expand(paddingBox, base.border);\n  var client = createBox({\n    borderBox: borderBox,\n    margin: base.margin,\n    border: base.border,\n    padding: base.padding\n  });\n  return client;\n};\n\nvar getDimension = (function (_ref) {\n  var ref = _ref.ref,\n      descriptor = _ref.descriptor,\n      env = _ref.env,\n      windowScroll = _ref.windowScroll,\n      direction = _ref.direction,\n      isDropDisabled = _ref.isDropDisabled,\n      isCombineEnabled = _ref.isCombineEnabled,\n      shouldClipSubject = _ref.shouldClipSubject;\n  var closestScrollable = env.closestScrollable;\n  var client = getClient(ref, closestScrollable);\n  var page = withScroll(client, windowScroll);\n\n  var closest = function () {\n    if (!closestScrollable) {\n      return null;\n    }\n\n    var frameClient = getBox(closestScrollable);\n    var scrollSize = {\n      scrollHeight: closestScrollable.scrollHeight,\n      scrollWidth: closestScrollable.scrollWidth\n    };\n    return {\n      client: frameClient,\n      page: withScroll(frameClient, windowScroll),\n      scroll: getScroll$1(closestScrollable),\n      scrollSize: scrollSize,\n      shouldClipSubject: shouldClipSubject\n    };\n  }();\n\n  var dimension = getDroppableDimension({\n    descriptor: descriptor,\n    isEnabled: !isDropDisabled,\n    isCombineEnabled: isCombineEnabled,\n    isFixedOnPage: env.isFixedOnPage,\n    direction: direction,\n    client: client,\n    page: page,\n    closest: closest\n  });\n  return dimension;\n});\n\nfunction withoutPlaceholder(placeholder, fn) {\n  if (!placeholder) {\n    return fn();\n  }\n\n  var last = placeholder.style.display;\n  placeholder.style.display = 'none';\n  var result = fn();\n  placeholder.style.display = last;\n  return result;\n}\n\nvar immediate = {\n  passive: false\n};\nvar delayed = {\n  passive: true\n};\nvar getListenerOptions = (function (options) {\n  return options.shouldPublishImmediately ? immediate : delayed;\n});\n\nfunction useRequiredContext(Context) {\n  var result = useContext(Context);\n  !result ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find required context') : invariant(false) : void 0;\n  return result;\n}\n\nvar getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {\n  return dragging && dragging.env.closestScrollable || null;\n};\n\nfunction useDroppableDimensionPublisher(args) {\n  var whileDraggingRef = useRef(null);\n  var appContext = useRequiredContext(AppContext);\n  var marshal = appContext.marshal;\n  var previousRef = usePrevious(args);\n  var descriptor = useMemo(function () {\n    return {\n      id: args.droppableId,\n      type: args.type\n    };\n  }, [args.droppableId, args.type]);\n  var publishedDescriptorRef = useRef(descriptor);\n  var memoizedUpdateScroll = useMemo(function () {\n    return memoizeOne(function (x, y) {\n      !whileDraggingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only update scroll when dragging') : invariant(false) : void 0;\n      var scroll = {\n        x: x,\n        y: y\n      };\n      marshal.updateDroppableScroll(descriptor.id, scroll);\n    });\n  }, [descriptor.id, marshal]);\n  var getClosestScroll = useCallback(function () {\n    var dragging = whileDraggingRef.current;\n\n    if (!dragging || !dragging.env.closestScrollable) {\n      return origin;\n    }\n\n    return getScroll$1(dragging.env.closestScrollable);\n  }, []);\n  var updateScroll = useCallback(function () {\n    var scroll = getClosestScroll();\n    memoizedUpdateScroll(scroll.x, scroll.y);\n  }, [getClosestScroll, memoizedUpdateScroll]);\n  var scheduleScrollUpdate = useMemo(function () {\n    return rafSchd(updateScroll);\n  }, [updateScroll]);\n  var onClosestScroll = useCallback(function () {\n    var dragging = whileDraggingRef.current;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find scroll options while scrolling') : invariant(false) : void 0;\n    var options = dragging.scrollOptions;\n\n    if (options.shouldPublishImmediately) {\n      updateScroll();\n      return;\n    }\n\n    scheduleScrollUpdate();\n  }, [scheduleScrollUpdate, updateScroll]);\n  var getDimensionAndWatchScroll = useCallback(function (windowScroll, options) {\n    !!whileDraggingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : invariant(false) : void 0;\n    var previous = previousRef.current;\n    var ref = previous.getDroppableRef();\n    !ref ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot collect without a droppable ref') : invariant(false) : void 0;\n    var env = getEnv(ref);\n    var dragging = {\n      ref: ref,\n      descriptor: descriptor,\n      env: env,\n      scrollOptions: options\n    };\n    whileDraggingRef.current = dragging;\n    var dimension = getDimension({\n      ref: ref,\n      descriptor: descriptor,\n      env: env,\n      windowScroll: windowScroll,\n      direction: previous.direction,\n      isDropDisabled: previous.isDropDisabled,\n      isCombineEnabled: previous.isCombineEnabled,\n      shouldClipSubject: !previous.ignoreContainerClipping\n    });\n\n    if (env.closestScrollable) {\n      env.closestScrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkForNestedScrollContainers(env.closestScrollable);\n      }\n    }\n\n    return dimension;\n  }, [descriptor, onClosestScroll, previousRef]);\n  var recollect = useCallback(function (options) {\n    var dragging = whileDraggingRef.current;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : invariant(false) : void 0;\n    var previous = previousRef.current;\n\n    var execute = function execute() {\n      return getDimension({\n        ref: dragging.ref,\n        descriptor: dragging.descriptor,\n        env: dragging.env,\n        windowScroll: origin,\n        direction: previous.direction,\n        isDropDisabled: previous.isDropDisabled,\n        isCombineEnabled: previous.isCombineEnabled,\n        shouldClipSubject: !previous.ignoreContainerClipping\n      });\n    };\n\n    if (!options.withoutPlaceholder) {\n      return execute();\n    }\n\n    return withoutPlaceholder(previous.getPlaceholderRef(), execute);\n  }, [previousRef]);\n  var dragStopped = useCallback(function () {\n    var dragging = whileDraggingRef.current;\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot stop drag when no active drag') : invariant(false) : void 0;\n    var closest = getClosestScrollableFromDrag(dragging);\n    whileDraggingRef.current = null;\n\n    if (!closest) {\n      return;\n    }\n\n    scheduleScrollUpdate.cancel();\n    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n  }, [onClosestScroll, scheduleScrollUpdate]);\n  var scroll = useCallback(function (change) {\n    var dragging = whileDraggingRef.current;\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot scroll when there is no drag') : invariant(false) : void 0;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !closest ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : invariant(false) : void 0;\n    closest.scrollTop += change.y;\n    closest.scrollLeft += change.x;\n  }, []);\n  var callbacks = useMemo(function () {\n    return {\n      getDimensionAndWatchScroll: getDimensionAndWatchScroll,\n      recollect: recollect,\n      dragStopped: dragStopped,\n      scroll: scroll\n    };\n  }, [dragStopped, getDimensionAndWatchScroll, recollect, scroll]);\n  useIsomorphicLayoutEffect(function () {\n    publishedDescriptorRef.current = descriptor;\n    marshal.registerDroppable(descriptor, callbacks);\n    return function () {\n      if (whileDraggingRef.current) {\n        process.env.NODE_ENV !== \"production\" ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : void 0;\n        dragStopped();\n      }\n\n      marshal.unregisterDroppable(descriptor);\n    };\n  }, [callbacks, descriptor, dragStopped, marshal]);\n  useIsomorphicLayoutEffect(function () {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n\n    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n  }, [args.isDropDisabled, marshal]);\n  useIsomorphicLayoutEffect(function () {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n\n    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n  }, [args.isCombineEnabled, marshal]);\n}\n\nfunction noop() {}\n\nvar empty = {\n  width: 0,\n  height: 0,\n  margin: noSpacing\n};\n\nvar getSize = function getSize(_ref) {\n  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount,\n      placeholder = _ref.placeholder,\n      animate = _ref.animate;\n\n  if (isAnimatingOpenOnMount) {\n    return empty;\n  }\n\n  if (animate === 'close') {\n    return empty;\n  }\n\n  return {\n    height: placeholder.client.borderBox.height,\n    width: placeholder.client.borderBox.width,\n    margin: placeholder.client.margin\n  };\n};\n\nvar getStyle = function getStyle(_ref2) {\n  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount,\n      placeholder = _ref2.placeholder,\n      animate = _ref2.animate;\n  var size = getSize({\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n    placeholder: placeholder,\n    animate: animate\n  });\n  return {\n    display: placeholder.display,\n    boxSizing: 'border-box',\n    width: size.width,\n    height: size.height,\n    marginTop: size.margin.top,\n    marginRight: size.margin.right,\n    marginBottom: size.margin.bottom,\n    marginLeft: size.margin.left,\n    flexShrink: '0',\n    flexGrow: '0',\n    pointerEvents: 'none',\n    transition: transitions.placeholder\n  };\n};\n\nfunction Placeholder(props) {\n  var animateOpenTimerRef = useRef(null);\n  var tryClearAnimateOpenTimer = useCallback(function () {\n    if (!animateOpenTimerRef.current) {\n      return;\n    }\n\n    clearTimeout(animateOpenTimerRef.current);\n    animateOpenTimerRef.current = null;\n  }, []);\n  var animate = props.animate,\n      onTransitionEnd = props.onTransitionEnd,\n      onClose = props.onClose,\n      styleContext = props.styleContext;\n\n  var _useState = useState(props.animate === 'open'),\n      isAnimatingOpenOnMount = _useState[0],\n      setIsAnimatingOpenOnMount = _useState[1];\n\n  useEffect(function () {\n    if (!isAnimatingOpenOnMount) {\n      return noop;\n    }\n\n    if (animate !== 'open') {\n      tryClearAnimateOpenTimer();\n      setIsAnimatingOpenOnMount(false);\n      return noop;\n    }\n\n    if (animateOpenTimerRef.current) {\n      return noop;\n    }\n\n    animateOpenTimerRef.current = setTimeout(function () {\n      animateOpenTimerRef.current = null;\n      setIsAnimatingOpenOnMount(false);\n    });\n    return tryClearAnimateOpenTimer;\n  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);\n  var onSizeChangeEnd = useCallback(function (event) {\n    if (event.propertyName !== 'height') {\n      return;\n    }\n\n    onTransitionEnd();\n\n    if (animate === 'close') {\n      onClose();\n    }\n  }, [animate, onClose, onTransitionEnd]);\n  var style = getStyle({\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n    animate: props.animate,\n    placeholder: props.placeholder\n  });\n  return React.createElement(props.placeholder.tagName, {\n    style: style,\n    'data-react-beautiful-dnd-placeholder': styleContext,\n    onTransitionEnd: onSizeChangeEnd,\n    ref: props.innerRef\n  });\n}\n\nvar Placeholder$1 = React.memo(Placeholder);\n\nvar DroppableContext = React.createContext(null);\n\nvar getWindowFromEl = (function (el) {\n  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;\n});\n\nfunction isHtmlElement(el) {\n  return el instanceof getWindowFromEl(el).HTMLElement;\n}\n\nfunction checkIsValidInnerRef(el) {\n  !(el && isHtmlElement(el)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"\\n    provided.innerRef has not been provided with a HTMLElement.\\n\\n    You can find a guide on using the innerRef callback functions at:\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\n  \") : invariant(false) : void 0;\n}\n\nfunction checkOwnProps(props) {\n  !props.droppableId ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A Droppable requires a droppableId prop') : invariant(false) : void 0;\n  !(typeof props.isDropDisabled === 'boolean') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isDropDisabled must be a boolean') : invariant(false) : void 0;\n  !(typeof props.isCombineEnabled === 'boolean') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isCombineEnabled must be a boolean') : invariant(false) : void 0;\n  !(typeof props.ignoreContainerClipping === 'boolean') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ignoreContainerClipping must be a boolean') : invariant(false) : void 0;\n}\n\nfunction checkPlaceholderRef(props, placeholderEl) {\n  if (!props.placeholder) {\n    return;\n  }\n\n  if (placeholderEl) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    Droppable setup issue [droppableId: \\\"\" + props.droppableId + \"\\\"]:\\n    DroppableProvided > placeholder could not be found.\\n\\n    Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\n  \") : void 0;\n}\n\nfunction useValidation(_ref) {\n  var props = _ref.props,\n      getDroppableRef = _ref.getDroppableRef,\n      getPlaceholderRef = _ref.getPlaceholderRef;\n  useEffect(function () {\n    if (process.env.NODE_ENV !== 'production') {\n      checkOwnProps(props);\n      checkIsValidInnerRef(getDroppableRef());\n      checkPlaceholderRef(props, getPlaceholderRef());\n    }\n  });\n}\n\nvar AnimateInOut = function (_React$PureComponent) {\n  _inheritsLoose(AnimateInOut, _React$PureComponent);\n\n  function AnimateInOut() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n    _this.state = {\n      isVisible: Boolean(_this.props.on),\n      data: _this.props.on,\n      animate: _this.props.shouldAnimate && _this.props.on ? 'open' : 'none'\n    };\n\n    _this.onClose = function () {\n      if (_this.state.animate !== 'close') {\n        return;\n      }\n\n      _this.setState({\n        isVisible: false\n      });\n    };\n\n    return _this;\n  }\n\n  AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    if (!props.shouldAnimate) {\n      return {\n        isVisible: Boolean(props.on),\n        data: props.on,\n        animate: 'none'\n      };\n    }\n\n    if (props.on) {\n      return {\n        isVisible: true,\n        data: props.on,\n        animate: 'open'\n      };\n    }\n\n    if (state.isVisible) {\n      return {\n        isVisible: true,\n        data: state.data,\n        animate: 'close'\n      };\n    }\n\n    return {\n      isVisible: false,\n      animate: 'close',\n      data: null\n    };\n  };\n\n  var _proto = AnimateInOut.prototype;\n\n  _proto.render = function render() {\n    if (!this.state.isVisible) {\n      return null;\n    }\n\n    var provided = {\n      onClose: this.onClose,\n      data: this.state.data,\n      animate: this.state.animate\n    };\n    return this.props.children(provided);\n  };\n\n  return AnimateInOut;\n}(React.PureComponent);\n\nfunction Droppable(props) {\n  var appContext = useContext(AppContext);\n  !appContext ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find app context') : invariant(false) : void 0;\n  var styleContext = appContext.style,\n      isMovementAllowed = appContext.isMovementAllowed;\n  var droppableRef = useRef(null);\n  var placeholderRef = useRef(null);\n  var children = props.children,\n      droppableId = props.droppableId,\n      type = props.type,\n      direction = props.direction,\n      ignoreContainerClipping = props.ignoreContainerClipping,\n      isDropDisabled = props.isDropDisabled,\n      isCombineEnabled = props.isCombineEnabled,\n      snapshot = props.snapshot,\n      updateViewportMaxScroll = props.updateViewportMaxScroll;\n  var getDroppableRef = useCallback(function () {\n    return droppableRef.current;\n  }, []);\n  var getPlaceholderRef = useCallback(function () {\n    return placeholderRef.current;\n  }, []);\n  var setDroppableRef = useCallback(function (value) {\n    droppableRef.current = value;\n  }, []);\n  var setPlaceholderRef = useCallback(function (value) {\n    placeholderRef.current = value;\n  }, []);\n  var onPlaceholderTransitionEnd = useCallback(function () {\n    if (isMovementAllowed()) {\n      updateViewportMaxScroll({\n        maxScroll: getMaxWindowScroll()\n      });\n    }\n  }, [isMovementAllowed, updateViewportMaxScroll]);\n  useDroppableDimensionPublisher({\n    droppableId: droppableId,\n    type: type,\n    direction: direction,\n    isDropDisabled: isDropDisabled,\n    isCombineEnabled: isCombineEnabled,\n    ignoreContainerClipping: ignoreContainerClipping,\n    getDroppableRef: getDroppableRef,\n    getPlaceholderRef: getPlaceholderRef\n  });\n  var placeholder = React.createElement(AnimateInOut, {\n    on: props.placeholder,\n    shouldAnimate: props.shouldAnimatePlaceholder\n  }, function (_ref) {\n    var onClose = _ref.onClose,\n        data = _ref.data,\n        animate = _ref.animate;\n    return React.createElement(Placeholder$1, {\n      placeholder: data,\n      onClose: onClose,\n      innerRef: setPlaceholderRef,\n      animate: animate,\n      styleContext: styleContext,\n      onTransitionEnd: onPlaceholderTransitionEnd\n    });\n  });\n  var provided = useMemo(function () {\n    return {\n      innerRef: setDroppableRef,\n      placeholder: placeholder,\n      droppableProps: {\n        'data-react-beautiful-dnd-droppable': styleContext\n      }\n    };\n  }, [placeholder, setDroppableRef, styleContext]);\n  var droppableContext = useMemo(function () {\n    return {\n      droppableId: droppableId,\n      type: type\n    };\n  }, [droppableId, type]);\n  useValidation({\n    props: props,\n    getDroppableRef: function getDroppableRef() {\n      return droppableRef.current;\n    },\n    getPlaceholderRef: function getPlaceholderRef() {\n      return placeholderRef.current;\n    }\n  });\n  return React.createElement(DroppableContext.Provider, {\n    value: droppableContext\n  }, children(provided, snapshot));\n}\n\nvar isStrictEqual = (function (a, b) {\n  return a === b;\n});\n\nvar whatIsDraggedOverFromResult = (function (result) {\n  var combine = result.combine,\n      destination = result.destination;\n\n  if (destination) {\n    return destination.droppableId;\n  }\n\n  if (combine) {\n    return combine.droppableId;\n  }\n\n  return null;\n});\n\nvar isMatchingType = function isMatchingType(type, critical) {\n  return type === critical.droppable.type;\n};\n\nvar getDraggable = function getDraggable(critical, dimensions) {\n  return dimensions.draggables[critical.draggable.id];\n};\n\nvar makeMapStateToProps = function makeMapStateToProps() {\n  var idle = {\n    placeholder: null,\n    shouldAnimatePlaceholder: true,\n    snapshot: {\n      isDraggingOver: false,\n      draggingOverWith: null,\n      draggingFromThisWith: null\n    }\n  };\n\n  var idleWithoutAnimation = _extends({}, idle, {\n    shouldAnimatePlaceholder: false\n  });\n\n  var getMapProps = memoizeOne(function (id, isDraggingOver, dragging, snapshot) {\n    var isHome = dragging.descriptor.droppableId === id;\n\n    if (isHome) {\n      return {\n        placeholder: dragging.placeholder,\n        shouldAnimatePlaceholder: false,\n        snapshot: snapshot\n      };\n    }\n\n    if (!isDraggingOver) {\n      return idle;\n    }\n\n    return {\n      placeholder: dragging.placeholder,\n      shouldAnimatePlaceholder: true,\n      snapshot: snapshot\n    };\n  });\n  var getSnapshot = memoizeOne(function (id, isDraggingOver, dragging) {\n    var draggableId = dragging.descriptor.id;\n    var isHome = dragging.descriptor.droppableId === id;\n    var draggingOverWith = isDraggingOver ? draggableId : null;\n    var draggingFromThisWith = isHome ? draggableId : null;\n    return {\n      isDraggingOver: isDraggingOver,\n      draggingOverWith: draggingOverWith,\n      draggingFromThisWith: draggingFromThisWith\n    };\n  });\n\n  var selector = function selector(state, ownProps) {\n    var id = ownProps.droppableId;\n    var type = ownProps.type;\n\n    if (state.isDragging) {\n      var critical = state.critical;\n\n      if (!isMatchingType(type, critical)) {\n        return idle;\n      }\n\n      var dragging = getDraggable(critical, state.dimensions);\n      var isDraggingOver = whatIsDraggedOver(state.impact) === id;\n      var snapshot = getSnapshot(id, isDraggingOver, dragging);\n      return getMapProps(id, isDraggingOver, dragging, snapshot);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (!isMatchingType(type, completed.critical)) {\n        return idle;\n      }\n\n      var _dragging = getDraggable(completed.critical, state.dimensions);\n\n      var _snapshot = getSnapshot(id, whatIsDraggedOverFromResult(completed.result) === id, _dragging);\n\n      return getMapProps(id, whatIsDraggedOver(completed.impact) === id, _dragging, _snapshot);\n    }\n\n    if (state.phase === 'IDLE' && !state.completed && state.shouldFlush) {\n      return idleWithoutAnimation;\n    }\n\n    if (state.phase === 'IDLE' && state.completed) {\n      var _completed = state.completed;\n\n      if (!isMatchingType(type, _completed.critical)) {\n        return idle;\n      }\n\n      var wasOver = whatIsDraggedOver(_completed.impact) === id;\n      var wasCombining = Boolean(_completed.impact.merge);\n\n      if (state.shouldFlush) {\n        return idleWithoutAnimation;\n      }\n\n      if (wasOver) {\n        return wasCombining ? idle : idleWithoutAnimation;\n      }\n\n      return idle;\n    }\n\n    return idle;\n  };\n\n  return selector;\n};\nvar mapDispatchToProps = {\n  updateViewportMaxScroll: updateViewportMaxScroll\n};\nvar defaultProps = {\n  type: 'DEFAULT',\n  direction: 'vertical',\n  isDropDisabled: false,\n  isCombineEnabled: false,\n  ignoreContainerClipping: false\n};\nvar ConnectedDroppable = connect(makeMapStateToProps, mapDispatchToProps, null, {\n  context: StoreContext,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Droppable);\nConnectedDroppable.defaultProps = defaultProps;\n\nvar zIndexOptions = {\n  dragging: 5000,\n  dropAnimating: 4500\n};\n\nvar getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {\n  if (dropping) {\n    return transitions.drop(dropping.duration);\n  }\n\n  if (shouldAnimateDragMovement) {\n    return transitions.snap;\n  }\n\n  return transitions.fluid;\n};\n\nvar getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {\n  if (!isCombining) {\n    return null;\n  }\n\n  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\n\nvar getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {\n  if (dragging.forceShouldAnimate != null) {\n    return dragging.forceShouldAnimate;\n  }\n\n  return dragging.mode === 'SNAP';\n};\n\nfunction getDraggingStyle(dragging) {\n  var dimension = dragging.dimension;\n  var box = dimension.client;\n  var offset = dragging.offset,\n      combineWith = dragging.combineWith,\n      dropping = dragging.dropping;\n  var isCombining = Boolean(combineWith);\n  var shouldAnimate = getShouldDraggingAnimate(dragging);\n  var isDropAnimating = Boolean(dropping);\n  var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n  var style = {\n    position: 'fixed',\n    top: box.marginBox.top,\n    left: box.marginBox.left,\n    boxSizing: 'border-box',\n    width: box.borderBox.width,\n    height: box.borderBox.height,\n    transition: getDraggingTransition(shouldAnimate, dropping),\n    transform: transform,\n    opacity: getDraggingOpacity(isCombining, isDropAnimating),\n    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n    pointerEvents: 'none'\n  };\n  return style;\n}\n\nfunction getSecondaryStyle(secondary) {\n  return {\n    transform: transforms.moveTo(secondary.offset),\n    transition: secondary.shouldAnimateDisplacement ? null : 'none'\n  };\n}\n\nfunction getStyle$1(mapped) {\n  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\n\nvar createEventMarshal = (function () {\n  var isMouseDownHandled = false;\n\n  var handle = function handle() {\n    !!isMouseDownHandled ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot handle mouse down as it is already handled') : invariant(false) : void 0;\n    isMouseDownHandled = true;\n  };\n\n  var isHandled = function isHandled() {\n    return isMouseDownHandled;\n  };\n\n  var reset = function reset() {\n    isMouseDownHandled = false;\n  };\n\n  return {\n    handle: handle,\n    isHandled: isHandled,\n    reset: reset\n  };\n});\n\nvar getOptions = function getOptions(shared, fromBinding) {\n  return _extends({}, shared, fromBinding);\n};\n\nvar bindEvents = function bindEvents(el, bindings, sharedOptions) {\n  bindings.forEach(function (binding) {\n    var options = getOptions(sharedOptions, binding.options);\n    el.addEventListener(binding.eventName, binding.fn, options);\n  });\n};\nvar unbindEvents = function unbindEvents(el, bindings, sharedOptions) {\n  bindings.forEach(function (binding) {\n    var options = getOptions(sharedOptions, binding.options);\n    el.removeEventListener(binding.eventName, binding.fn, options);\n  });\n};\n\nvar createScheduler = (function (callbacks) {\n  var memoizedMove = memoizeOne(function (x, y) {\n    var point = {\n      x: x,\n      y: y\n    };\n    callbacks.onMove(point);\n  });\n  var move = rafSchd(function (point) {\n    return memoizedMove(point.x, point.y);\n  });\n  var moveUp = rafSchd(callbacks.onMoveUp);\n  var moveDown = rafSchd(callbacks.onMoveDown);\n  var moveRight = rafSchd(callbacks.onMoveRight);\n  var moveLeft = rafSchd(callbacks.onMoveLeft);\n  var windowScrollMove = rafSchd(callbacks.onWindowScroll);\n\n  var cancel = function cancel() {\n    move.cancel();\n    moveUp.cancel();\n    moveDown.cancel();\n    moveRight.cancel();\n    moveLeft.cancel();\n    windowScrollMove.cancel();\n  };\n\n  return {\n    move: move,\n    moveUp: moveUp,\n    moveDown: moveDown,\n    moveRight: moveRight,\n    moveLeft: moveLeft,\n    windowScrollMove: windowScrollMove,\n    cancel: cancel\n  };\n});\n\nvar tab = 9;\nvar enter = 13;\nvar escape = 27;\nvar space = 32;\nvar pageUp = 33;\nvar pageDown = 34;\nvar end = 35;\nvar home = 36;\nvar arrowLeft = 37;\nvar arrowUp = 38;\nvar arrowRight = 39;\nvar arrowDown = 40;\n\nvar supportedEventName = function () {\n  var base = 'visibilitychange';\n\n  if (typeof document === 'undefined') {\n    return base;\n  }\n\n  var candidates = [base, \"ms\" + base, \"webkit\" + base, \"moz\" + base, \"o\" + base];\n  var supported = find(candidates, function (eventName) {\n    return \"on\" + eventName in document;\n  });\n  return supported || base;\n}();\n\nvar sharedOptions = {\n  capture: true\n};\nvar createPostDragEventPreventer = (function (getWindow) {\n  var isBound = false;\n\n  var bind = function bind() {\n    if (isBound) {\n      return;\n    }\n\n    isBound = true;\n    bindEvents(getWindow(), pointerEvents, sharedOptions);\n  };\n\n  var unbind = function unbind() {\n    if (!isBound) {\n      return;\n    }\n\n    isBound = false;\n    unbindEvents(getWindow(), pointerEvents, sharedOptions);\n  };\n\n  var pointerEvents = [{\n    eventName: 'click',\n    fn: function fn(event) {\n      event.preventDefault();\n      unbind();\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: unbind\n  }, {\n    eventName: 'touchstart',\n    fn: unbind\n  }];\n\n  var preventNext = function preventNext() {\n    if (isBound) {\n      unbind();\n    }\n\n    bind();\n  };\n\n  var preventer = {\n    preventNext: preventNext,\n    abort: unbind\n  };\n  return preventer;\n});\n\nvar sloppyClickThreshold = 5;\nvar isSloppyClickThresholdExceeded = (function (original, current) {\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n});\n\nvar _preventedKeys;\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\nvar preventStandardKeyEvents = (function (event) {\n  if (preventedKeys[event.keyCode]) {\n    event.preventDefault();\n  }\n});\n\nvar primaryButton = 0;\n\nvar noop$1 = function noop() {};\n\nvar mouseDownMarshal = createEventMarshal();\nfunction useMouseSensor(args) {\n  var canStartCapturing = args.canStartCapturing,\n      getWindow = args.getWindow,\n      callbacks = args.callbacks,\n      getShouldRespectForcePress = args.getShouldRespectForcePress,\n      onCaptureStart = args.onCaptureStart,\n      onCaptureEnd = args.onCaptureEnd;\n  var pendingRef = useRef(null);\n  var isDraggingRef = useRef(false);\n  var unbindWindowEventsRef = useRef(noop$1);\n  var getIsCapturing = useCallback(function () {\n    return Boolean(pendingRef.current || isDraggingRef.current);\n  }, []);\n  var schedule = useMemo(function () {\n    !!getIsCapturing() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not recreate scheduler while capturing') : invariant(false) : void 0;\n    return createScheduler(callbacks);\n  }, [callbacks, getIsCapturing]);\n  var postDragEventPreventer = useMemo(function () {\n    return createPostDragEventPreventer(getWindow);\n  }, [getWindow]);\n  var stop = useCallback(function () {\n    if (!getIsCapturing()) {\n      return;\n    }\n\n    schedule.cancel();\n    unbindWindowEventsRef.current();\n    var shouldBlockClick = isDraggingRef.current;\n    mouseDownMarshal.reset();\n\n    if (shouldBlockClick) {\n      postDragEventPreventer.preventNext();\n    }\n\n    pendingRef.current = null;\n    isDraggingRef.current = false;\n    onCaptureEnd();\n  }, [getIsCapturing, onCaptureEnd, postDragEventPreventer, schedule]);\n  var cancel = useCallback(function () {\n    var wasDragging = isDraggingRef.current;\n    stop();\n\n    if (wasDragging) {\n      callbacks.onCancel();\n    }\n  }, [callbacks, stop]);\n  var startDragging = useCallback(function () {\n    !!isDraggingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start a drag while dragging') : invariant(false) : void 0;\n    var pending = pendingRef.current;\n    !pending ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start a drag without a pending drag') : invariant(false) : void 0;\n    pendingRef.current = null;\n    isDraggingRef.current = true;\n    callbacks.onLift({\n      clientSelection: pending,\n      movementMode: 'FLUID'\n    });\n  }, [callbacks]);\n  var windowBindings = useMemo(function () {\n    !!getIsCapturing() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not recreate window bindings while capturing') : invariant(false) : void 0;\n    var bindings = [{\n      eventName: 'mousemove',\n      fn: function fn(event) {\n        var button = event.button,\n            clientX = event.clientX,\n            clientY = event.clientY;\n\n        if (button !== primaryButton) {\n          return;\n        }\n\n        var point = {\n          x: clientX,\n          y: clientY\n        };\n\n        if (isDraggingRef.current) {\n          event.preventDefault();\n          schedule.move(point);\n          return;\n        }\n\n        var pending = pendingRef.current;\n\n        if (!pending) {\n          stop();\n          process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected there to be an active or pending drag when window mousemove event is received') : invariant(false);\n        }\n\n        if (!isSloppyClickThresholdExceeded(pending, point)) {\n          return;\n        }\n\n        event.preventDefault();\n        startDragging();\n      }\n    }, {\n      eventName: 'mouseup',\n      fn: function fn(event) {\n        var wasDragging = isDraggingRef.current;\n        stop();\n\n        if (wasDragging) {\n          event.preventDefault();\n          callbacks.onDrop();\n        }\n      }\n    }, {\n      eventName: 'mousedown',\n      fn: function fn(event) {\n        if (isDraggingRef.current) {\n          event.preventDefault();\n        }\n\n        cancel();\n      }\n    }, {\n      eventName: 'keydown',\n      fn: function fn(event) {\n        if (pendingRef.current) {\n          stop();\n          return;\n        }\n\n        if (event.keyCode === escape) {\n          event.preventDefault();\n          cancel();\n          return;\n        }\n\n        preventStandardKeyEvents(event);\n      }\n    }, {\n      eventName: 'resize',\n      fn: cancel\n    }, {\n      eventName: 'scroll',\n      options: {\n        passive: true,\n        capture: false\n      },\n      fn: function fn(event) {\n        if (event.currentTarget !== getWindow()) {\n          return;\n        }\n\n        if (pendingRef.current) {\n          stop();\n          return;\n        }\n\n        schedule.windowScrollMove();\n      }\n    }, {\n      eventName: 'webkitmouseforcechanged',\n      fn: function fn(event) {\n        if (event.webkitForce == null || MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN == null) {\n          process.env.NODE_ENV !== \"production\" ? warning('handling a mouse force changed event when it is not supported') : void 0;\n          return;\n        }\n\n        var forcePressThreshold = MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN;\n        var isForcePressing = event.webkitForce >= forcePressThreshold;\n\n        if (!getShouldRespectForcePress()) {\n          event.preventDefault();\n          return;\n        }\n\n        if (isForcePressing) {\n          cancel();\n        }\n      }\n    }, {\n      eventName: supportedEventName,\n      fn: cancel\n    }];\n    return bindings;\n  }, [getIsCapturing, cancel, startDragging, schedule, stop, callbacks, getWindow, getShouldRespectForcePress]);\n  var bindWindowEvents = useCallback(function () {\n    var win = getWindow();\n    var options = {\n      capture: true\n    };\n\n    unbindWindowEventsRef.current = function () {\n      return unbindEvents(win, windowBindings, options);\n    };\n\n    bindEvents(win, windowBindings, options);\n  }, [getWindow, windowBindings]);\n  var startPendingDrag = useCallback(function (point) {\n    !!pendingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected there to be no pending drag') : invariant(false) : void 0;\n    pendingRef.current = point;\n    onCaptureStart(stop);\n    bindWindowEvents();\n  }, [bindWindowEvents, onCaptureStart, stop]);\n  var onMouseDown = useCallback(function (event) {\n    if (mouseDownMarshal.isHandled()) {\n      return;\n    }\n\n    !!getIsCapturing() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not be able to perform a mouse down while a drag or pending drag is occurring') : invariant(false) : void 0;\n\n    if (!canStartCapturing(event)) {\n      return;\n    }\n\n    if (event.button !== primaryButton) {\n      return;\n    }\n\n    if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n      return;\n    }\n\n    mouseDownMarshal.handle();\n    event.preventDefault();\n    var point = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    startPendingDrag(point);\n  }, [canStartCapturing, getIsCapturing, startPendingDrag]);\n  return onMouseDown;\n}\n\nfunction isElement(el) {\n  return el instanceof getWindowFromEl(el).Element;\n}\n\nvar interactiveTagNames = {\n  input: true,\n  button: true,\n  textarea: true,\n  select: true,\n  option: true,\n  optgroup: true,\n  video: true,\n  audio: true\n};\n\nvar isAnInteractiveElement = function isAnInteractiveElement(parent, current) {\n  if (current == null) {\n    return false;\n  }\n\n  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\n\n  if (hasAnInteractiveTag) {\n    return true;\n  }\n\n  var attribute = current.getAttribute('contenteditable');\n\n  if (attribute === 'true' || attribute === '') {\n    return true;\n  }\n\n  if (current === parent) {\n    return false;\n  }\n\n  return isAnInteractiveElement(parent, current.parentElement);\n};\n\nvar shouldAllowDraggingFromTarget = (function (event, canDragInteractiveElements) {\n  if (canDragInteractiveElements) {\n    return true;\n  }\n\n  var target = event.target,\n      currentTarget = event.currentTarget;\n\n  if (!isElement(target) || !isElement(currentTarget)) {\n    return true;\n  }\n\n  return !isAnInteractiveElement(currentTarget, target);\n});\n\nvar getBorderBoxCenterPosition = (function (el) {\n  return getRect(el.getBoundingClientRect()).center;\n});\n\nvar _scrollJumpKeys;\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\n\nfunction noop$2() {}\n\nfunction useKeyboardSensor(args) {\n  var canStartCapturing = args.canStartCapturing,\n      getWindow = args.getWindow,\n      callbacks = args.callbacks,\n      onCaptureStart = args.onCaptureStart,\n      onCaptureEnd = args.onCaptureEnd,\n      getDraggableRef = args.getDraggableRef;\n  var isDraggingRef = useRef(false);\n  var unbindWindowEventsRef = useRef(noop$2);\n  var getIsDragging = useCallback(function () {\n    return isDraggingRef.current;\n  }, []);\n  var schedule = useMemo(function () {\n    !!getIsDragging() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not recreate scheduler while capturing') : invariant(false) : void 0;\n    return createScheduler(callbacks);\n  }, [callbacks, getIsDragging]);\n  var stop = useCallback(function () {\n    if (!getIsDragging()) {\n      return;\n    }\n\n    schedule.cancel();\n    unbindWindowEventsRef.current();\n    isDraggingRef.current = false;\n    onCaptureEnd();\n  }, [getIsDragging, onCaptureEnd, schedule]);\n  var cancel = useCallback(function () {\n    var wasDragging = isDraggingRef.current;\n    stop();\n\n    if (wasDragging) {\n      callbacks.onCancel();\n    }\n  }, [callbacks, stop]);\n  var windowBindings = useMemo(function () {\n    !!getIsDragging() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not recreate window bindings when dragging') : invariant(false) : void 0;\n    return [{\n      eventName: 'mousedown',\n      fn: cancel\n    }, {\n      eventName: 'mouseup',\n      fn: cancel\n    }, {\n      eventName: 'click',\n      fn: cancel\n    }, {\n      eventName: 'touchstart',\n      fn: cancel\n    }, {\n      eventName: 'resize',\n      fn: cancel\n    }, {\n      eventName: 'wheel',\n      fn: cancel,\n      options: {\n        passive: true\n      }\n    }, {\n      eventName: 'scroll',\n      options: {\n        capture: false\n      },\n      fn: function fn(event) {\n        if (event.currentTarget !== getWindow()) {\n          return;\n        }\n\n        callbacks.onWindowScroll();\n      }\n    }, {\n      eventName: supportedEventName,\n      fn: cancel\n    }];\n  }, [callbacks, cancel, getIsDragging, getWindow]);\n  var bindWindowEvents = useCallback(function () {\n    var win = getWindow();\n    var options = {\n      capture: true\n    };\n\n    unbindWindowEventsRef.current = function () {\n      return unbindEvents(win, windowBindings, options);\n    };\n\n    bindEvents(win, windowBindings, options);\n  }, [getWindow, windowBindings]);\n  var startDragging = useCallback(function () {\n    !!isDraggingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start a drag while dragging') : invariant(false) : void 0;\n    var ref = getDraggableRef();\n    !ref ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start a keyboard drag without a draggable ref') : invariant(false) : void 0;\n    isDraggingRef.current = true;\n    onCaptureStart(stop);\n    bindWindowEvents();\n    var center = getBorderBoxCenterPosition(ref);\n    callbacks.onLift({\n      clientSelection: center,\n      movementMode: 'SNAP'\n    });\n  }, [bindWindowEvents, callbacks, getDraggableRef, onCaptureStart, stop]);\n  var onKeyDown = useCallback(function (event) {\n    if (!getIsDragging()) {\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      if (!canStartCapturing(event)) {\n        return;\n      }\n\n      if (event.keyCode !== space) {\n        return;\n      }\n\n      event.preventDefault();\n      startDragging();\n      return;\n    }\n\n    if (event.keyCode === escape) {\n      event.preventDefault();\n      cancel();\n      return;\n    }\n\n    if (event.keyCode === space) {\n      event.preventDefault();\n      stop();\n      callbacks.onDrop();\n      return;\n    }\n\n    if (event.keyCode === arrowDown) {\n      event.preventDefault();\n      schedule.moveDown();\n      return;\n    }\n\n    if (event.keyCode === arrowUp) {\n      event.preventDefault();\n      schedule.moveUp();\n      return;\n    }\n\n    if (event.keyCode === arrowRight) {\n      event.preventDefault();\n      schedule.moveRight();\n      return;\n    }\n\n    if (event.keyCode === arrowLeft) {\n      event.preventDefault();\n      schedule.moveLeft();\n      return;\n    }\n\n    if (scrollJumpKeys[event.keyCode]) {\n      event.preventDefault();\n      return;\n    }\n\n    preventStandardKeyEvents(event);\n  }, [callbacks, canStartCapturing, cancel, getIsDragging, schedule, startDragging, stop]);\n  return onKeyDown;\n}\n\nvar timeForLongPress = 150;\nvar forcePressThreshold = 0.15;\nvar touchStartMarshal = createEventMarshal();\n\nvar noop$3 = function noop() {};\n\nvar webkitHack = function () {\n  var stub = {\n    preventTouchMove: noop$3,\n    releaseTouchMove: noop$3\n  };\n\n  if (typeof window === 'undefined') {\n    return stub;\n  }\n\n  if (!('ontouchstart' in window)) {\n    return stub;\n  }\n\n  var isBlocking = false;\n  window.addEventListener('touchmove', function (event) {\n    if (!isBlocking) {\n      return;\n    }\n\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    event.preventDefault();\n  }, {\n    passive: false,\n    capture: false\n  });\n\n  var preventTouchMove = function preventTouchMove() {\n    isBlocking = true;\n  };\n\n  var releaseTouchMove = function releaseTouchMove() {\n    isBlocking = false;\n  };\n\n  return {\n    preventTouchMove: preventTouchMove,\n    releaseTouchMove: releaseTouchMove\n  };\n}();\n\nfunction useTouchSensor(args) {\n  var callbacks = args.callbacks,\n      getWindow = args.getWindow,\n      canStartCapturing = args.canStartCapturing,\n      getShouldRespectForcePress = args.getShouldRespectForcePress,\n      onCaptureStart = args.onCaptureStart,\n      onCaptureEnd = args.onCaptureEnd;\n  var pendingRef = useRef(null);\n  var isDraggingRef = useRef(false);\n  var hasMovedRef = useRef(false);\n  var unbindWindowEventsRef = useRef(noop$3);\n  var getIsCapturing = useCallback(function () {\n    return Boolean(pendingRef.current || isDraggingRef.current);\n  }, []);\n  var postDragClickPreventer = useMemo(function () {\n    return createPostDragEventPreventer(getWindow);\n  }, [getWindow]);\n  var schedule = useMemo(function () {\n    !!getIsCapturing() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not recreate scheduler while capturing') : invariant(false) : void 0;\n    return createScheduler(callbacks);\n  }, [callbacks, getIsCapturing]);\n  var stop = useCallback(function () {\n    if (!getIsCapturing()) {\n      return;\n    }\n\n    schedule.cancel();\n    unbindWindowEventsRef.current();\n    touchStartMarshal.reset();\n    webkitHack.releaseTouchMove();\n    hasMovedRef.current = false;\n    onCaptureEnd();\n\n    if (isDraggingRef.current) {\n      postDragClickPreventer.preventNext();\n      isDraggingRef.current = false;\n      return;\n    }\n\n    var pending = pendingRef.current;\n    !pending ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected a pending drag') : invariant(false) : void 0;\n    clearTimeout(pending.longPressTimerId);\n    pendingRef.current = null;\n  }, [getIsCapturing, onCaptureEnd, postDragClickPreventer, schedule]);\n  var cancel = useCallback(function () {\n    var wasDragging = isDraggingRef.current;\n    stop();\n\n    if (wasDragging) {\n      callbacks.onCancel();\n    }\n  }, [callbacks, stop]);\n  var windowBindings = useMemo(function () {\n    !!getIsCapturing() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not recreate window bindings while capturing') : invariant(false) : void 0;\n    var bindings = [{\n      eventName: 'touchmove',\n      options: {\n        passive: false\n      },\n      fn: function fn(event) {\n        if (!isDraggingRef.current) {\n          stop();\n          return;\n        }\n\n        if (!hasMovedRef.current) {\n          hasMovedRef.current = true;\n        }\n\n        var _event$touches$ = event.touches[0],\n            clientX = _event$touches$.clientX,\n            clientY = _event$touches$.clientY;\n        var point = {\n          x: clientX,\n          y: clientY\n        };\n        event.preventDefault();\n        schedule.move(point);\n      }\n    }, {\n      eventName: 'touchend',\n      fn: function fn(event) {\n        if (!isDraggingRef.current) {\n          stop();\n          return;\n        }\n\n        event.preventDefault();\n        stop();\n        callbacks.onDrop();\n      }\n    }, {\n      eventName: 'touchcancel',\n      fn: function fn(event) {\n        if (!isDraggingRef.current) {\n          stop();\n          return;\n        }\n\n        event.preventDefault();\n        cancel();\n      }\n    }, {\n      eventName: 'touchstart',\n      fn: cancel\n    }, {\n      eventName: 'orientationchange',\n      fn: cancel\n    }, {\n      eventName: 'resize',\n      fn: cancel\n    }, {\n      eventName: 'scroll',\n      options: {\n        passive: true,\n        capture: false\n      },\n      fn: function fn() {\n        if (pendingRef.current) {\n          stop();\n          return;\n        }\n\n        schedule.windowScrollMove();\n      }\n    }, {\n      eventName: 'contextmenu',\n      fn: function fn(event) {\n        event.preventDefault();\n      }\n    }, {\n      eventName: 'keydown',\n      fn: function fn(event) {\n        if (!isDraggingRef.current) {\n          cancel();\n          return;\n        }\n\n        if (event.keyCode === escape) {\n          event.preventDefault();\n        }\n\n        cancel();\n      }\n    }, {\n      eventName: 'touchforcechange',\n      fn: function fn(event) {\n        if (!getShouldRespectForcePress()) {\n          event.preventDefault();\n          return;\n        }\n\n        if (hasMovedRef.current) {\n          event.preventDefault();\n          return;\n        }\n\n        var touch = event.touches[0];\n\n        if (touch.force >= forcePressThreshold) {\n          cancel();\n        }\n      }\n    }, {\n      eventName: supportedEventName,\n      fn: cancel\n    }];\n    return bindings;\n  }, [callbacks, cancel, getIsCapturing, getShouldRespectForcePress, schedule, stop]);\n  var bindWindowEvents = useCallback(function () {\n    var win = getWindow();\n    var options = {\n      capture: true\n    };\n\n    unbindWindowEventsRef.current = function () {\n      return unbindEvents(win, windowBindings, options);\n    };\n\n    bindEvents(win, windowBindings, options);\n  }, [getWindow, windowBindings]);\n  var startDragging = useCallback(function () {\n    var pending = pendingRef.current;\n    !pending ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start a drag without a pending drag') : invariant(false) : void 0;\n    isDraggingRef.current = true;\n    pendingRef.current = null;\n    hasMovedRef.current = false;\n    callbacks.onLift({\n      clientSelection: pending.point,\n      movementMode: 'FLUID'\n    });\n  }, [callbacks]);\n  var startPendingDrag = useCallback(function (event) {\n    !!pendingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected there to be no pending drag') : invariant(false) : void 0;\n    var touch = event.touches[0];\n    var clientX = touch.clientX,\n        clientY = touch.clientY;\n    var point = {\n      x: clientX,\n      y: clientY\n    };\n    var longPressTimerId = setTimeout(startDragging, timeForLongPress);\n    var pending = {\n      point: point,\n      longPressTimerId: longPressTimerId\n    };\n    pendingRef.current = pending;\n    onCaptureStart(stop);\n    bindWindowEvents();\n  }, [bindWindowEvents, onCaptureStart, startDragging, stop]);\n\n  var onTouchStart = function onTouchStart(event) {\n    if (touchStartMarshal.isHandled()) {\n      return;\n    }\n\n    !!getIsCapturing() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not be able to perform a touch start while a drag or pending drag is occurring') : invariant(false) : void 0;\n\n    if (!canStartCapturing(event)) {\n      return;\n    }\n\n    touchStartMarshal.handle();\n    webkitHack.preventTouchMove();\n    startPendingDrag(event);\n  };\n\n  return onTouchStart;\n}\n\nfunction isSvgElement(el) {\n  return Boolean(getWindowFromEl(el).SVGElement) && el instanceof getWindowFromEl(el).SVGElement;\n}\n\nvar selector = \"[\" + dragHandle + \"]\";\n\nvar throwIfSVG = function throwIfSVG(el) {\n  !!isSvgElement(el) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"A drag handle cannot be an SVGElement: it has inconsistent focus support.\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/dragging-svgs.md\") : invariant(false) : void 0;\n};\n\nvar getDragHandleRef = function getDragHandleRef(draggableRef) {\n  if (draggableRef.hasAttribute(dragHandle)) {\n    throwIfSVG(draggableRef);\n    return draggableRef;\n  }\n\n  var el = draggableRef.querySelector(selector);\n  throwIfSVG(draggableRef);\n  !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"\\n      Cannot find drag handle element inside of Draggable.\\n      Please be sure to apply the {...provided.dragHandleProps} to your Draggable\\n\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/draggable.md\\n    \") : invariant(false) : void 0;\n  !isHtmlElement(el) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A drag handle must be a HTMLElement') : invariant(false) : void 0;\n  return el;\n};\n\nfunction useValidation$1(_ref) {\n  var isEnabled = _ref.isEnabled,\n      getDraggableRef = _ref.getDraggableRef;\n  useEffect(function () {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isEnabled) {\n        return;\n      }\n\n      var draggableRef = getDraggableRef();\n      !draggableRef ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Drag handle was unable to find draggable ref') : invariant(false) : void 0;\n      getDragHandleRef(draggableRef);\n    }\n  }, [getDraggableRef, isEnabled]);\n}\n\nvar retainingFocusFor = null;\nvar listenerOptions = {\n  capture: true\n};\n\nvar clearRetentionOnFocusChange = function () {\n  var isBound = false;\n\n  var bind = function bind() {\n    if (isBound) {\n      return;\n    }\n\n    isBound = true;\n    window.addEventListener('focus', onWindowFocusChange, listenerOptions);\n  };\n\n  var unbind = function unbind() {\n    if (!isBound) {\n      return;\n    }\n\n    isBound = false;\n    window.removeEventListener('focus', onWindowFocusChange, listenerOptions);\n  };\n\n  var onWindowFocusChange = function onWindowFocusChange() {\n    unbind();\n    retainingFocusFor = null;\n  };\n\n  var result = function result() {\n    return bind();\n  };\n\n  result.cancel = function () {\n    return unbind();\n  };\n\n  return result;\n}();\n\nvar retain = function retain(id) {\n  retainingFocusFor = id;\n  clearRetentionOnFocusChange();\n};\n\nvar tryRestoreFocus = function tryRestoreFocus(id, draggableRef) {\n  if (!retainingFocusFor) {\n    return;\n  }\n\n  if (id !== retainingFocusFor) {\n    return;\n  }\n\n  retainingFocusFor = null;\n  clearRetentionOnFocusChange.cancel();\n  var dragHandleRef = getDragHandleRef(draggableRef);\n\n  if (!dragHandleRef) {\n    process.env.NODE_ENV !== \"production\" ? warning('Could not find drag handle in the DOM to focus on it') : void 0;\n    return;\n  }\n\n  dragHandleRef.focus();\n};\n\nvar retainer = {\n  retain: retain,\n  tryRestoreFocus: tryRestoreFocus\n};\n\nfunction noop$4() {}\n\nfunction useFocusRetainer(args) {\n  var isFocusedRef = useRef(false);\n  var lastArgsRef = usePrevious(args);\n  var getDraggableRef = args.getDraggableRef;\n  var onFocus = useCallback(function () {\n    isFocusedRef.current = true;\n  }, []);\n  var onBlur = useCallback(function () {\n    isFocusedRef.current = false;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    var first = lastArgsRef.current;\n\n    if (!first.isEnabled) {\n      return noop$4;\n    }\n\n    var draggable = getDraggableRef();\n    !draggable ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Drag handle could not obtain draggable ref') : invariant(false) : void 0;\n    var dragHandle = getDragHandleRef(draggable);\n    retainer.tryRestoreFocus(first.draggableId, dragHandle);\n    return function () {\n      var last = lastArgsRef.current;\n\n      var shouldRetainFocus = function () {\n        if (!last.isEnabled) {\n          return false;\n        }\n\n        if (!isFocusedRef.current) {\n          return false;\n        }\n\n        return last.isDragging || last.isDropAnimating;\n      }();\n\n      if (shouldRetainFocus) {\n        retainer.retain(last.draggableId);\n      }\n    };\n  }, [getDraggableRef, lastArgsRef]);\n  var lastDraggableRef = useRef(null);\n  useIsomorphicLayoutEffect(function () {\n    if (!lastDraggableRef.current) {\n      return;\n    }\n\n    var draggableRef = getDraggableRef();\n\n    if (!draggableRef) {\n      return;\n    }\n\n    if (draggableRef === lastDraggableRef.current) {\n      return;\n    }\n\n    if (isFocusedRef.current && lastArgsRef.current.isEnabled) {\n      getDragHandleRef(draggableRef).focus();\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    lastDraggableRef.current = getDraggableRef();\n  });\n  return {\n    onBlur: onBlur,\n    onFocus: onFocus\n  };\n}\n\nfunction preventHtml5Dnd(event) {\n  event.preventDefault();\n}\n\nfunction useDragHandle(args) {\n  var capturingRef = useRef(null);\n  var onCaptureStart = useCallback(function (abort) {\n    !!capturingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start capturing while something else is') : invariant(false) : void 0;\n    capturingRef.current = {\n      abort: abort\n    };\n  }, []);\n  var onCaptureEnd = useCallback(function () {\n    !capturingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot stop capturing while nothing is capturing') : invariant(false) : void 0;\n    capturingRef.current = null;\n  }, []);\n  var abortCapture = useCallback(function () {\n    !capturingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot abort capture when there is none') : invariant(false) : void 0;\n    capturingRef.current.abort();\n  }, []);\n\n  var _useRequiredContext = useRequiredContext(AppContext),\n      canLift = _useRequiredContext.canLift,\n      styleContext = _useRequiredContext.style;\n\n  var isDragging = args.isDragging,\n      isEnabled = args.isEnabled,\n      draggableId = args.draggableId,\n      callbacks = args.callbacks,\n      getDraggableRef = args.getDraggableRef,\n      getShouldRespectForcePress = args.getShouldRespectForcePress,\n      canDragInteractiveElements = args.canDragInteractiveElements;\n  var lastArgsRef = usePrevious(args);\n  useValidation$1({\n    isEnabled: isEnabled,\n    getDraggableRef: getDraggableRef\n  });\n  var getWindow = useCallback(function () {\n    return getWindowFromEl(getDraggableRef());\n  }, [getDraggableRef]);\n  var canStartCapturing = useCallback(function (event) {\n    if (!isEnabled) {\n      return false;\n    }\n\n    if (capturingRef.current) {\n      return false;\n    }\n\n    if (!canLift(draggableId)) {\n      return false;\n    }\n\n    return shouldAllowDraggingFromTarget(event, canDragInteractiveElements);\n  }, [canDragInteractiveElements, canLift, draggableId, isEnabled]);\n\n  var _useFocusRetainer = useFocusRetainer(args),\n      onBlur = _useFocusRetainer.onBlur,\n      onFocus = _useFocusRetainer.onFocus;\n\n  var mouseArgs = useMemo(function () {\n    return {\n      callbacks: callbacks,\n      getDraggableRef: getDraggableRef,\n      getWindow: getWindow,\n      canStartCapturing: canStartCapturing,\n      onCaptureStart: onCaptureStart,\n      onCaptureEnd: onCaptureEnd,\n      getShouldRespectForcePress: getShouldRespectForcePress\n    };\n  }, [callbacks, getDraggableRef, getWindow, canStartCapturing, onCaptureStart, onCaptureEnd, getShouldRespectForcePress]);\n  var onMouseDown = useMouseSensor(mouseArgs);\n  var keyboardArgs = useMemo(function () {\n    return {\n      callbacks: callbacks,\n      getDraggableRef: getDraggableRef,\n      getWindow: getWindow,\n      canStartCapturing: canStartCapturing,\n      onCaptureStart: onCaptureStart,\n      onCaptureEnd: onCaptureEnd\n    };\n  }, [callbacks, canStartCapturing, getDraggableRef, getWindow, onCaptureEnd, onCaptureStart]);\n  var onKeyDown = useKeyboardSensor(keyboardArgs);\n  var touchArgs = useMemo(function () {\n    return {\n      callbacks: callbacks,\n      getDraggableRef: getDraggableRef,\n      getWindow: getWindow,\n      canStartCapturing: canStartCapturing,\n      getShouldRespectForcePress: getShouldRespectForcePress,\n      onCaptureStart: onCaptureStart,\n      onCaptureEnd: onCaptureEnd\n    };\n  }, [callbacks, getDraggableRef, getWindow, canStartCapturing, getShouldRespectForcePress, onCaptureStart, onCaptureEnd]);\n  var onTouchStart = useTouchSensor(touchArgs);\n  useIsomorphicLayoutEffect(function () {\n    return function () {\n      if (!capturingRef.current) {\n        return;\n      }\n\n      abortCapture();\n\n      if (lastArgsRef.current.isDragging) {\n        lastArgsRef.current.callbacks.onCancel();\n      }\n    };\n  }, []);\n\n  if (!isEnabled && capturingRef.current) {\n    abortCapture();\n\n    if (lastArgsRef.current.isDragging) {\n      process.env.NODE_ENV !== \"production\" ? warning('You have disabled dragging on a Draggable while it was dragging. The drag has been cancelled') : void 0;\n      callbacks.onCancel();\n    }\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    if (!isDragging && capturingRef.current) {\n      abortCapture();\n    }\n  }, [abortCapture, isDragging]);\n  var props = useMemo(function () {\n    if (!isEnabled) {\n      return null;\n    }\n\n    return {\n      onMouseDown: onMouseDown,\n      onKeyDown: onKeyDown,\n      onTouchStart: onTouchStart,\n      onFocus: onFocus,\n      onBlur: onBlur,\n      tabIndex: 0,\n      'data-react-beautiful-dnd-drag-handle': styleContext,\n      'aria-roledescription': 'Draggable item. Press space bar to lift',\n      draggable: false,\n      onDragStart: preventHtml5Dnd\n    };\n  }, [isEnabled, onBlur, onFocus, onKeyDown, onMouseDown, onTouchStart, styleContext]);\n  return props;\n}\n\nfunction getDimension$1(descriptor, el, windowScroll) {\n  if (windowScroll === void 0) {\n    windowScroll = origin;\n  }\n\n  var computedStyles = window.getComputedStyle(el);\n  var borderBox = el.getBoundingClientRect();\n  var client = calculateBox(borderBox, computedStyles);\n  var page = withScroll(client, windowScroll);\n  var placeholder = {\n    client: client,\n    tagName: el.tagName.toLowerCase(),\n    display: computedStyles.display\n  };\n  var displaceBy = {\n    x: client.marginBox.width,\n    y: client.marginBox.height\n  };\n  var dimension = {\n    descriptor: descriptor,\n    placeholder: placeholder,\n    displaceBy: displaceBy,\n    client: client,\n    page: page\n  };\n  return dimension;\n}\n\nfunction useDraggableDimensionPublisher(args) {\n  var draggableId = args.draggableId,\n      index = args.index,\n      getDraggableRef = args.getDraggableRef;\n  var appContext = useRequiredContext(AppContext);\n  var marshal = appContext.marshal;\n  var droppableContext = useRequiredContext(DroppableContext);\n  var droppableId = droppableContext.droppableId,\n      type = droppableContext.type;\n  var descriptor = useMemo(function () {\n    var result = {\n      id: draggableId,\n      droppableId: droppableId,\n      type: type,\n      index: index\n    };\n    return result;\n  }, [draggableId, droppableId, index, type]);\n  var publishedDescriptorRef = useRef(descriptor);\n  var makeDimension = useCallback(function (windowScroll) {\n    var latest = publishedDescriptorRef.current;\n    var el = getDraggableRef();\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get dimension when no ref is set') : invariant(false) : void 0;\n    return getDimension$1(latest, el, windowScroll);\n  }, [getDraggableRef]);\n  useIsomorphicLayoutEffect(function () {\n    marshal.registerDraggable(publishedDescriptorRef.current, makeDimension);\n    return function () {\n      return marshal.unregisterDraggable(publishedDescriptorRef.current);\n    };\n  }, [makeDimension, marshal]);\n  useIsomorphicLayoutEffect(function () {\n    if (publishedDescriptorRef.current === descriptor) {\n      return;\n    }\n\n    var previous = publishedDescriptorRef.current;\n    publishedDescriptorRef.current = descriptor;\n    marshal.updateDraggable(previous, descriptor, makeDimension);\n  }, [descriptor, makeDimension, marshal]);\n}\n\nfunction checkOwnProps$1(props) {\n  !_Number$isInteger(props.index) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Draggable requires an integer index prop') : invariant(false) : void 0;\n  !props.draggableId ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Draggable requires a draggableId') : invariant(false) : void 0;\n  !(typeof props.isDragDisabled === 'boolean') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isDragDisabled must be a boolean') : invariant(false) : void 0;\n}\n\nfunction checkForOutdatedProps(props) {\n  if (Object.prototype.hasOwnProperty.call(props, 'shouldRespectForceTouch')) {\n    process.env.NODE_ENV !== \"production\" ? warning('shouldRespectForceTouch has been renamed to shouldRespectForcePress') : void 0;\n  }\n}\n\nfunction useValidation$2(props, getRef) {\n  useEffect(function () {\n    if (process.env.NODE_ENV !== 'production') {\n      checkOwnProps$1(props);\n      checkForOutdatedProps(props);\n      checkIsValidInnerRef(getRef());\n    }\n  });\n}\n\nfunction Draggable(props) {\n  var ref = useRef(null);\n  var setRef = useCallback(function (el) {\n    ref.current = el;\n  }, []);\n  var getRef = useCallback(function () {\n    return ref.current;\n  }, []);\n  var appContext = useRequiredContext(AppContext);\n  useValidation$2(props, getRef);\n  var children = props.children,\n      draggableId = props.draggableId,\n      isDragDisabled = props.isDragDisabled,\n      shouldRespectForcePress = props.shouldRespectForcePress,\n      canDragInteractiveElements = props.disableInteractiveElementBlocking,\n      index = props.index,\n      mapped = props.mapped,\n      moveUpAction = props.moveUp,\n      moveAction = props.move,\n      dropAction = props.drop,\n      moveDownAction = props.moveDown,\n      moveRightAction = props.moveRight,\n      moveLeftAction = props.moveLeft,\n      moveByWindowScrollAction = props.moveByWindowScroll,\n      liftAction = props.lift,\n      dropAnimationFinishedAction = props.dropAnimationFinished;\n  var forPublisher = useMemo(function () {\n    return {\n      draggableId: draggableId,\n      index: index,\n      getDraggableRef: getRef\n    };\n  }, [draggableId, getRef, index]);\n  useDraggableDimensionPublisher(forPublisher);\n  var onLift = useCallback(function (options) {\n    start('LIFT');\n    var el = ref.current;\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n    !!isDragDisabled ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot lift a Draggable when it is disabled') : invariant(false) : void 0;\n    var clientSelection = options.clientSelection,\n        movementMode = options.movementMode;\n    liftAction({\n      id: draggableId,\n      clientSelection: clientSelection,\n      movementMode: movementMode\n    });\n    finish('LIFT');\n  }, [draggableId, isDragDisabled, liftAction]);\n  var getShouldRespectForcePress = useCallback(function () {\n    return shouldRespectForcePress;\n  }, [shouldRespectForcePress]);\n  var callbacks = useMemo(function () {\n    return {\n      onLift: onLift,\n      onMove: function onMove(clientSelection) {\n        return moveAction({\n          client: clientSelection\n        });\n      },\n      onDrop: function onDrop() {\n        return dropAction({\n          reason: 'DROP'\n        });\n      },\n      onCancel: function onCancel() {\n        return dropAction({\n          reason: 'CANCEL'\n        });\n      },\n      onMoveUp: moveUpAction,\n      onMoveDown: moveDownAction,\n      onMoveRight: moveRightAction,\n      onMoveLeft: moveLeftAction,\n      onWindowScroll: function onWindowScroll() {\n        return moveByWindowScrollAction({\n          newScroll: getWindowScroll()\n        });\n      }\n    };\n  }, [dropAction, moveAction, moveByWindowScrollAction, moveDownAction, moveLeftAction, moveRightAction, moveUpAction, onLift]);\n  var isDragging = mapped.type === 'DRAGGING';\n  var isDropAnimating = mapped.type === 'DRAGGING' && Boolean(mapped.dropping);\n  var dragHandleArgs = useMemo(function () {\n    return {\n      draggableId: draggableId,\n      isDragging: isDragging,\n      isDropAnimating: isDropAnimating,\n      isEnabled: !isDragDisabled,\n      callbacks: callbacks,\n      getDraggableRef: getRef,\n      canDragInteractiveElements: canDragInteractiveElements,\n      getShouldRespectForcePress: getShouldRespectForcePress\n    };\n  }, [callbacks, canDragInteractiveElements, draggableId, getRef, getShouldRespectForcePress, isDragDisabled, isDragging, isDropAnimating]);\n  var dragHandleProps = useDragHandle(dragHandleArgs);\n  var onMoveEnd = useCallback(function (event) {\n    if (mapped.type !== 'DRAGGING') {\n      return;\n    }\n\n    if (!mapped.dropping) {\n      return;\n    }\n\n    if (event.propertyName !== 'transform') {\n      return;\n    }\n\n    dropAnimationFinishedAction();\n  }, [dropAnimationFinishedAction, mapped]);\n  var provided = useMemo(function () {\n    var style = getStyle$1(mapped);\n    var onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;\n    var result = {\n      innerRef: setRef,\n      draggableProps: {\n        'data-react-beautiful-dnd-draggable': appContext.style,\n        style: style,\n        onTransitionEnd: onTransitionEnd\n      },\n      dragHandleProps: dragHandleProps\n    };\n    return result;\n  }, [appContext.style, dragHandleProps, mapped, onMoveEnd, setRef]);\n  return children(provided, mapped.snapshot);\n}\n\nvar getCombineWithFromResult = function getCombineWithFromResult(result) {\n  return result.combine ? result.combine.draggableId : null;\n};\n\nvar getCombineWithFromImpact = function getCombineWithFromImpact(impact) {\n  return impact.merge ? impact.merge.combine.draggableId : null;\n};\n\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\n  var getDraggingSnapshot = memoizeOne(function (mode, draggingOver, combineWith, dropping) {\n    return {\n      isDragging: true,\n      isDropAnimating: Boolean(dropping),\n      dropAnimation: dropping,\n      mode: mode,\n      draggingOver: draggingOver,\n      combineWith: combineWith,\n      combineTargetFor: null\n    };\n  });\n  var getSecondarySnapshot = memoizeOne(function (combineTargetFor) {\n    return {\n      isDragging: false,\n      isDropAnimating: false,\n      dropAnimation: null,\n      mode: null,\n      draggingOver: null,\n      combineTargetFor: combineTargetFor,\n      combineWith: null\n    };\n  });\n  var defaultMapProps = {\n    mapped: {\n      type: 'SECONDARY',\n      offset: origin,\n      combineTargetFor: null,\n      shouldAnimateDisplacement: true,\n      snapshot: getSecondarySnapshot(null)\n    }\n  };\n  var memoizedOffset = memoizeOne(function (x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var getDraggingProps = memoizeOne(function (offset, mode, dimension, draggingOver, combineWith, forceShouldAnimate) {\n    return {\n      mapped: {\n        type: 'DRAGGING',\n        dropping: null,\n        draggingOver: draggingOver,\n        combineWith: combineWith,\n        mode: mode,\n        offset: offset,\n        dimension: dimension,\n        forceShouldAnimate: forceShouldAnimate,\n        snapshot: getDraggingSnapshot(mode, draggingOver, combineWith, null)\n      }\n    };\n  });\n  var getSecondaryProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {\n    if (combineTargetFor === void 0) {\n      combineTargetFor = null;\n    }\n\n    return {\n      mapped: {\n        type: 'SECONDARY',\n        offset: offset,\n        combineTargetFor: combineTargetFor,\n        shouldAnimateDisplacement: shouldAnimateDisplacement,\n        snapshot: getSecondarySnapshot(combineTargetFor)\n      }\n    };\n  });\n\n  var getSecondaryMovement = function getSecondaryMovement(ownId, draggingId, impact) {\n    var map = impact.movement.map;\n    var displacement = map[ownId];\n    var movement = impact.movement;\n    var merge = impact.merge;\n    var isCombinedWith = Boolean(merge && merge.combine.draggableId === ownId);\n    var displacedBy = movement.displacedBy.point;\n    var offset = memoizedOffset(displacedBy.x, displacedBy.y);\n\n    if (isCombinedWith) {\n      return getSecondaryProps(displacement ? offset : origin, draggingId, displacement ? displacement.shouldAnimate : true);\n    }\n\n    if (!displacement) {\n      return null;\n    }\n\n    if (!displacement.isVisible) {\n      return null;\n    }\n\n    return getSecondaryProps(offset, null, displacement.shouldAnimate);\n  };\n\n  var draggingSelector = function draggingSelector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id !== ownProps.draggableId) {\n        return null;\n      }\n\n      var offset = state.current.client.offset;\n      var dimension = state.dimensions.draggables[ownProps.draggableId];\n      var mode = state.movementMode;\n      var draggingOver = whatIsDraggedOver(state.impact);\n      var combineWith = getCombineWithFromImpact(state.impact);\n      var forceShouldAnimate = state.forceShouldAnimate;\n      return getDraggingProps(memoizedOffset(offset.x, offset.y), mode, dimension, draggingOver, combineWith, forceShouldAnimate);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (completed.result.draggableId !== ownProps.draggableId) {\n        return null;\n      }\n\n      var _dimension = state.dimensions.draggables[ownProps.draggableId];\n      var result = completed.result;\n      var _mode = result.mode;\n\n      var _draggingOver = whatIsDraggedOverFromResult(result);\n\n      var _combineWith = getCombineWithFromResult(result);\n\n      var duration = state.dropDuration;\n      var dropping = {\n        duration: duration,\n        curve: curves.drop,\n        moveTo: state.newHomeClientOffset,\n        opacity: _combineWith ? combine.opacity.drop : null,\n        scale: _combineWith ? combine.scale.drop : null\n      };\n      return {\n        mapped: {\n          type: 'DRAGGING',\n          offset: state.newHomeClientOffset,\n          dimension: _dimension,\n          dropping: dropping,\n          draggingOver: _draggingOver,\n          combineWith: _combineWith,\n          mode: _mode,\n          forceShouldAnimate: null,\n          snapshot: getDraggingSnapshot(_mode, _draggingOver, _combineWith, dropping)\n        }\n      };\n    }\n\n    return null;\n  };\n\n  var secondarySelector = function secondarySelector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id === ownProps.draggableId) {\n        return null;\n      }\n\n      return getSecondaryMovement(ownProps.draggableId, state.critical.draggable.id, state.impact);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (completed.result.draggableId === ownProps.draggableId) {\n        return null;\n      }\n\n      return getSecondaryMovement(ownProps.draggableId, completed.result.draggableId, completed.impact);\n    }\n\n    return null;\n  };\n\n  var selector = function selector(state, ownProps) {\n    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || defaultMapProps;\n  };\n\n  return selector;\n};\nvar mapDispatchToProps$1 = {\n  lift: lift,\n  move: move,\n  moveUp: moveUp,\n  moveDown: moveDown,\n  moveLeft: moveLeft,\n  moveRight: moveRight,\n  moveByWindowScroll: moveByWindowScroll,\n  drop: drop,\n  dropAnimationFinished: dropAnimationFinished\n};\nvar defaultProps$1 = {\n  isDragDisabled: false,\n  disableInteractiveElementBlocking: false,\n  shouldRespectForcePress: false\n};\nvar ConnectedDraggable = connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n  context: StoreContext,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Draggable);\nConnectedDraggable.defaultProps = defaultProps$1;\n\nexport { DragDropContext, ConnectedDraggable as Draggable, ConnectedDroppable as Droppable, resetServerContext };\n"],"sourceRoot":""}