{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/jss-nested/lib/index.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","getReplaceRef","container","match","rule","getRule","selector","_warning2","options","meta","hasAnd","str","indexOf","replaceParentRefs","nestedProp","parentProp","parentSelectors","split","separatorRegExp","nestedSelectors","result","parent","j","nested","replace","parentRegExp","getOptions","index","nestingLevel","undefined","onProcessStyle","style","type","replaceRef","prop","isNested","isNestedConditional","refRegExp","addRule","obj","_warning","__webpack_require__","__esModule"],"mappings":"4FAEAA,OAAAC,eAAAC,EAAA,cACAC,OAAA,IAGA,IAAAC,EAAAJ,OAAAK,QAAA,SAAAC,GAAmD,QAAAC,EAAA,EAAgBA,EAAAC,UAAAC,OAAsBF,IAAA,CAAO,IAAAG,EAAAF,UAAAD,GAA2B,QAAAI,KAAAD,EAA0BV,OAAAY,UAAAC,eAAAC,KAAAJ,EAAAC,KAAyDL,EAAAK,GAAAD,EAAAC,IAAiC,OAAAL,GAE/OJ,EAAAa,QAkBA,WAEA,SAAAC,EAAAC,GACA,gBAAAC,EAAAP,GACA,IAAAQ,EAAAF,EAAAG,QAAAT,GACA,OAAAQ,IAAAE,WACA,EAAAC,EAAAP,UAAA,uDAAAJ,EAAAM,EAAAM,QAAAC,MAAAP,GACAN,IAIA,IAAAc,EAAA,SAAAC,GACA,WAAAA,EAAAC,QAAA,MAGA,SAAAC,EAAAC,EAAAC,GAMA,IALA,IAAAC,EAAAD,EAAAE,MAAAC,GACAC,EAAAL,EAAAG,MAAAC,GAEAE,EAAA,GAEA5B,EAAA,EAAmBA,EAAAwB,EAAAtB,OAA4BF,IAG/C,IAFA,IAAA6B,EAAAL,EAAAxB,GAEA8B,EAAA,EAAqBA,EAAAH,EAAAzB,OAA4B4B,IAAA,CACjD,IAAAC,EAAAJ,EAAAG,GACAF,OAAA,MAEAA,GAAAV,EAAAa,KAAAC,QAAAC,EAAAJ,KAAA,IAAAE,EAIA,OAAAH,EAGA,SAAAM,EAAAtB,EAAAF,EAAAM,GAEA,GAAAA,EAAA,OAAAnB,EAAA,GAAmCmB,EAAA,CAAYmB,MAAAnB,EAAAmB,MAAA,IAE/C,IAAAC,EAAAxB,EAAAI,QAAAoB,aAIA,OAFAA,OAAAC,IAAAD,EAAA,EAAAA,EAAA,EAEAvC,EAAA,GAAsBe,EAAAI,QAAA,CACtBoB,eACAD,MAAAzB,EAAAU,QAAAR,GAAA,IAsCA,OAAU0B,eAlCV,SAAAC,EAAA3B,GACA,aAAAA,EAAA4B,KAAA,OAAAD,EACA,IAAA7B,EAAAE,EAAAI,QAAAa,OACAb,OAAA,EACAyB,OAAA,EACA,QAAAC,KAAAH,EAAA,CACA,IAAAI,EAAAzB,EAAAwB,GACAE,EAAA,MAAAF,EAAA,GAEA,GAAAC,GAAAC,EAAA,CAIA,GAFA5B,EAAAkB,EAAAtB,EAAAF,EAAAM,GAEA2B,EAAA,CACA,IAAA7B,EAAAO,EAAAqB,EAAA9B,EAAAE,UAGU2B,MAAAhC,EAAAC,IAEAI,IAAAkB,QAAAa,EAAAJ,GAEV/B,EAAAoC,QAAAhC,EAAAyB,EAAAG,GAAA7C,EAAA,GAA4DmB,EAAA,CAAYF,mBACjE8B,GACPlC,EAEAoC,QAAAJ,EAAA,KAAA1B,GAAA8B,QAAAlC,EAAAR,IAAAmC,EAAAG,GAAA,CAAsE5B,SAAAF,EAAAE,kBAGtEyB,EAAAG,IAGA,OAAAH,KAhGA,IAIAQ,EAJAC,EAAeC,EAAQ,QAEvBlC,GAEAgC,EAFAC,IAEsCD,EAAAG,WAAAH,EAAA,CAAuCvC,QAAAuC,GAE7E,IAAArB,EAAA,WACAO,EAAA,KACAY,EAAA","file":"bundle.npm.jss-nested.9edabeecf752ba0c53a1.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = jssNested;\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container) {\n    return function (match, key) {\n      var rule = container.getRule(key);\n      if (rule) return rule.selector;\n      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);\n      return key;\n    };\n  }\n\n  var hasAnd = function hasAnd(str) {\n    return str.indexOf('&') !== -1;\n  };\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', ';\n        // Replace all & by the parent or prefix & with the parent.\n        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, options) {\n    // Options has been already created, now we only increase index.\n    if (options) return _extends({}, options, { index: options.index + 1 });\n\n    var nestingLevel = rule.options.nestingLevel;\n\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    return _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1\n    });\n  }\n\n  function onProcessStyle(style, rule) {\n    if (rule.type !== 'style') return style;\n    var container = rule.options.parent;\n    var options = void 0;\n    var replaceRef = void 0;\n    for (var prop in style) {\n      var isNested = hasAnd(prop);\n      var isNestedConditional = prop[0] === '@';\n\n      if (!isNested && !isNestedConditional) continue;\n\n      options = getOptions(rule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, rule.selector\n        // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n        );if (!replaceRef) replaceRef = getReplaceRef(container\n        // Replace all $refs.\n        );selector = selector.replace(refRegExp, replaceRef);\n\n        container.addRule(selector, style[prop], _extends({}, options, { selector: selector }));\n      } else if (isNestedConditional) {\n        container\n        // Place conditional right after the parent rule to ensure right ordering.\n        .addRule(prop, null, options).addRule(rule.key, style[prop], { selector: rule.selector });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return { onProcessStyle: onProcessStyle };\n}"],"sourceRoot":""}