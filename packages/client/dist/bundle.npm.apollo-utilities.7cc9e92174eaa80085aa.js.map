{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/util/isEqual.js","webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/transform.js","webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/directives.js","webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/util/warnOnce.js","webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/util/assign.js","webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/util/environment.js","webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/getFromAST.js","webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/storeUtils.js","webpack:////var/www/html/utter/node_modules/apollo-utilities/lib/fragments.js"],"names":["isEqual","a","b","Date","getTime","key","Object","prototype","hasOwnProperty","call","__webpack_require__","d","__webpack_exports__","addTypenameToDocument","TYPENAME_FIELD","kind","name","value","doc","visitor","getFromAST","SelectionSet","enter","node","_key","parent","selections","some","selection","lastIndexOf","tslib_es6","concat","getDirectiveInfoFromField","shouldInclude","_storeUtils__WEBPACK_IMPORTED_MODULE_1__","field","variables","directives","length","directiveObj_1","forEach","directive","res","directiveArguments","arguments","directiveName","Error","ifArgument","ifValue","evaledValue","undefined","warnOnceInDevelopment","_environment__WEBPACK_IMPORTED_MODULE_0__","haveWarned","create","msg","type","console","error","warn","assign","target","sources","_i","source","keys","process","isEnv","env","isProduction","isTest","checkDocument","getOperationDefinition","getOperationDefinitionOrDie","getOperationName","getFragmentDefinitions","getQueryDefinition","getMainDefinition","createFragmentMap","getDefaultValues","_util_assign__WEBPACK_IMPORTED_MODULE_0__","operations","definitions","filter","map","definition","document","def","x","queryDef","operation","queryDoc","fragmentDefinition","_a","fragments","symTable","fragment","variableDefinitions","defaultValues","defaultValue","variable","defaultValueObj","apply","valueToObjectRepresentation","storeKeyNameFromField","getStoreKeyName","argumentsObjectFromField","resultKeyNameFromField","isField","isInlineFragment","isIdValue","toIdValue","isJsonValue","tslib__WEBPACK_IMPORTED_MODULE_0__","fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__","fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default","n","argObj","isIntValue","isFloatValue","Number","isBooleanValue","isStringValue","isObjectValue","nestedArgObj_1","fields","obj","isVariable","variableValue","isListValue","values","listValue","nestedArgArrayObj","isEnumValue","isNullValue","directivesObj","KNOWN_DIRECTIVES","fieldName","args","filterKeys","sort","queryArgs_1","filteredArgs_1","JSON","stringify","completeFieldName","stringifiedArgs","indexOf","argObj_1","alias","idObject","generated","idConfig","id","typename","jsonObject","getFragmentQueryDocument","fragmentName","actualFragmentName","push","selectionSet"],"mappings":"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","file":"bundle.npm.apollo-utilities.7cc9e92174eaa80085aa.js","sourcesContent":["export function isEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n    }\n    if (a != null &&\n        typeof a === 'object' &&\n        b != null &&\n        typeof b === 'object') {\n        for (var key in a) {\n            if (Object.prototype.hasOwnProperty.call(a, key)) {\n                if (!Object.prototype.hasOwnProperty.call(b, key)) {\n                    return false;\n                }\n                if (!isEqual(a[key], b[key])) {\n                    return false;\n                }\n            }\n        }\n        for (var key in b) {\n            if (Object.prototype.hasOwnProperty.call(b, key) &&\n                !Object.prototype.hasOwnProperty.call(a, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=isEqual.js.map","import * as tslib_1 from \"tslib\";\nimport { visit } from 'graphql/language/visitor';\nimport { checkDocument, getOperationDefinitionOrDie, getFragmentDefinitions, createFragmentMap, } from './getFromAST';\nimport { filterInPlace } from './util/filterInPlace';\nvar TYPENAME_FIELD = {\n    kind: 'Field',\n    name: {\n        kind: 'Name',\n        value: '__typename',\n    },\n};\nfunction isEmpty(op, fragments) {\n    return op.selectionSet.selections.every(function (selection) {\n        return selection.kind === 'FragmentSpread' &&\n            isEmpty(fragments[selection.name.value], fragments);\n    });\n}\nfunction nullIfDocIsEmpty(doc) {\n    return isEmpty(getOperationDefinitionOrDie(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}\nfunction getDirectiveMatcher(directives) {\n    return function directiveMatcher(directive) {\n        return directives.some(function (dir) {\n            return (dir.name && dir.name === directive.name.value) ||\n                (dir.test && dir.test(directive));\n        });\n    };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n    var variablesInUse = Object.create(null);\n    var variablesToRemove = [];\n    var fragmentSpreadsInUse = Object.create(null);\n    var fragmentSpreadsToRemove = [];\n    var modifiedDoc = nullIfDocIsEmpty(visit(doc, {\n        Variable: {\n            enter: function (node, _key, parent) {\n                if (parent.kind !== 'VariableDefinition') {\n                    variablesInUse[node.name.value] = true;\n                }\n            },\n        },\n        Field: {\n            enter: function (node) {\n                var shouldRemoveField = directives.some(function (directive) { return directive.remove; });\n                if (shouldRemoveField &&\n                    node.directives &&\n                    node.directives.some(getDirectiveMatcher(directives))) {\n                    if (node.arguments) {\n                        node.arguments.forEach(function (arg) {\n                            if (arg.value.kind === 'Variable') {\n                                variablesToRemove.push({\n                                    name: arg.value.name.value,\n                                });\n                            }\n                        });\n                    }\n                    if (node.selectionSet) {\n                        getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {\n                            fragmentSpreadsToRemove.push({\n                                name: frag.name.value,\n                            });\n                        });\n                    }\n                    return null;\n                }\n            },\n        },\n        FragmentSpread: {\n            enter: function (node) {\n                fragmentSpreadsInUse[node.name.value] = true;\n            },\n        },\n        Directive: {\n            enter: function (node) {\n                if (getDirectiveMatcher(directives)(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n    if (modifiedDoc &&\n        filterInPlace(variablesToRemove, function (v) { return !variablesInUse[v.name]; }).length) {\n        modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n    }\n    if (modifiedDoc &&\n        filterInPlace(fragmentSpreadsToRemove, function (fs) { return !fragmentSpreadsInUse[fs.name]; }).length) {\n        modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);\n    }\n    return modifiedDoc;\n}\nexport function addTypenameToDocument(doc) {\n    return visit(checkDocument(doc), {\n        SelectionSet: {\n            enter: function (node, _key, parent) {\n                if (parent &&\n                    parent.kind === 'OperationDefinition') {\n                    return;\n                }\n                var selections = node.selections;\n                if (!selections) {\n                    return;\n                }\n                var skip = selections.some(function (selection) {\n                    return (selection.kind === 'Field' &&\n                        (selection.name.value === '__typename' ||\n                            selection.name.value.lastIndexOf('__', 0) === 0));\n                });\n                if (skip) {\n                    return;\n                }\n                return tslib_1.__assign({}, node, { selections: selections.concat([TYPENAME_FIELD]) });\n            },\n        },\n    });\n}\nvar connectionRemoveConfig = {\n    test: function (directive) {\n        var willRemove = directive.name.value === 'connection';\n        if (willRemove) {\n            if (!directive.arguments ||\n                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {\n                console.warn('Removing an @connection directive even though it does not have a key. ' +\n                    'You may want to use the key parameter to specify a store key.');\n            }\n        }\n        return willRemove;\n    },\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    return (selectionSet &&\n        selectionSet.selections &&\n        selectionSet.selections.some(function (selection) {\n            return hasDirectivesInSelection(directives, selection, nestedCheck);\n        }));\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    if (selection.kind !== 'Field' || !selection) {\n        return true;\n    }\n    if (!selection.directives) {\n        return false;\n    }\n    return (selection.directives.some(getDirectiveMatcher(directives)) ||\n        (nestedCheck &&\n            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));\n}\nexport function getDirectivesFromDocument(directives, doc) {\n    checkDocument(doc);\n    var parentPath;\n    return nullIfDocIsEmpty(visit(doc, {\n        SelectionSet: {\n            enter: function (node, _key, _parent, path) {\n                var currentPath = path.join('-');\n                if (!parentPath ||\n                    currentPath === parentPath ||\n                    !currentPath.startsWith(parentPath)) {\n                    if (node.selections) {\n                        var selectionsWithDirectives = node.selections.filter(function (selection) {\n                            return hasDirectivesInSelection(directives, selection);\n                        });\n                        if (hasDirectivesInSelectionSet(directives, node, false)) {\n                            parentPath = currentPath;\n                        }\n                        return tslib_1.__assign({}, node, { selections: selectionsWithDirectives });\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            },\n        },\n    }));\n}\nfunction getArgumentMatcher(config) {\n    return function argumentMatcher(argument) {\n        return config.some(function (aConfig) {\n            return argument.value &&\n                argument.value.kind === 'Variable' &&\n                argument.value.name &&\n                (aConfig.name === argument.value.name.value ||\n                    (aConfig.test && aConfig.test(argument)));\n        });\n    };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n    var argMatcher = getArgumentMatcher(config);\n    return nullIfDocIsEmpty(visit(doc, {\n        OperationDefinition: {\n            enter: function (node) {\n                return tslib_1.__assign({}, node, { variableDefinitions: node.variableDefinitions.filter(function (varDef) { return !config.some(function (arg) { return arg.name === varDef.variable.name.value; }); }) });\n            },\n        },\n        Field: {\n            enter: function (node) {\n                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });\n                if (shouldRemoveField) {\n                    var argMatchCount_1 = 0;\n                    node.arguments.forEach(function (arg) {\n                        if (argMatcher(arg)) {\n                            argMatchCount_1 += 1;\n                        }\n                    });\n                    if (argMatchCount_1 === 1) {\n                        return null;\n                    }\n                }\n            },\n        },\n        Argument: {\n            enter: function (node) {\n                if (argMatcher(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n    function enter(node) {\n        if (config.some(function (def) { return def.name === node.name.value; })) {\n            return null;\n        }\n    }\n    return nullIfDocIsEmpty(visit(doc, {\n        FragmentSpread: { enter: enter },\n        FragmentDefinition: { enter: enter },\n    }));\n}\nfunction getAllFragmentSpreadsFromSelectionSet(selectionSet) {\n    var allFragments = [];\n    selectionSet.selections.forEach(function (selection) {\n        if ((selection.kind === 'Field' ||\n            selection.kind === 'InlineFragment') &&\n            selection.selectionSet) {\n            getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) { return allFragments.push(frag); });\n        }\n        else if (selection.kind === 'FragmentSpread') {\n            allFragments.push(selection);\n        }\n    });\n    return allFragments;\n}\n//# sourceMappingURL=transform.js.map","import { visit } from 'graphql/language/visitor';\nimport { argumentsObjectFromField } from './storeUtils';\nexport function getDirectiveInfoFromField(field, variables) {\n    if (field.directives && field.directives.length) {\n        var directiveObj_1 = {};\n        field.directives.forEach(function (directive) {\n            directiveObj_1[directive.name.value] = argumentsObjectFromField(directive, variables);\n        });\n        return directiveObj_1;\n    }\n    return null;\n}\nexport function shouldInclude(selection, variables) {\n    if (variables === void 0) { variables = {}; }\n    if (!selection.directives) {\n        return true;\n    }\n    var res = true;\n    selection.directives.forEach(function (directive) {\n        if (directive.name.value !== 'skip' && directive.name.value !== 'include') {\n            return;\n        }\n        var directiveArguments = directive.arguments || [];\n        var directiveName = directive.name.value;\n        if (directiveArguments.length !== 1) {\n            throw new Error(\"Incorrect number of arguments for the @\" + directiveName + \" directive.\");\n        }\n        var ifArgument = directiveArguments[0];\n        if (!ifArgument.name || ifArgument.name.value !== 'if') {\n            throw new Error(\"Invalid argument for the @\" + directiveName + \" directive.\");\n        }\n        var ifValue = directiveArguments[0].value;\n        var evaledValue = false;\n        if (!ifValue || ifValue.kind !== 'BooleanValue') {\n            if (ifValue.kind !== 'Variable') {\n                throw new Error(\"Argument for the @\" + directiveName + \" directive must be a variable or a boolean value.\");\n            }\n            else {\n                evaledValue = variables[ifValue.name.value];\n                if (evaledValue === undefined) {\n                    throw new Error(\"Invalid variable referenced in @\" + directiveName + \" directive.\");\n                }\n            }\n        }\n        else {\n            evaledValue = ifValue.value;\n        }\n        if (directiveName === 'skip') {\n            evaledValue = !evaledValue;\n        }\n        if (!evaledValue) {\n            res = false;\n        }\n    });\n    return res;\n}\nexport function getDirectiveNames(doc) {\n    var names = [];\n    visit(doc, {\n        Directive: function (node) {\n            names.push(node.name.value);\n        },\n    });\n    return names;\n}\nexport function hasDirectives(names, doc) {\n    return getDirectiveNames(doc).some(function (name) { return names.indexOf(name) > -1; });\n}\n//# sourceMappingURL=directives.js.map","import { isProduction, isTest } from './environment';\nvar haveWarned = Object.create({});\nexport function warnOnceInDevelopment(msg, type) {\n    if (type === void 0) { type = 'warn'; }\n    if (isProduction()) {\n        return;\n    }\n    if (!haveWarned[msg]) {\n        if (!isTest()) {\n            haveWarned[msg] = true;\n        }\n        switch (type) {\n            case 'error':\n                console.error(msg);\n                break;\n            default:\n                console.warn(msg);\n        }\n    }\n}\n//# sourceMappingURL=warnOnce.js.map","export function assign(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        if (typeof source === 'undefined' || source === null) {\n            return;\n        }\n        Object.keys(source).forEach(function (key) {\n            target[key] = source[key];\n        });\n    });\n    return target;\n}\n//# sourceMappingURL=assign.js.map","export function getEnv() {\n    if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n        return process.env.NODE_ENV;\n    }\n    return 'development';\n}\nexport function isEnv(env) {\n    return getEnv() === env;\n}\nexport function isProduction() {\n    return isEnv('production') === true;\n}\nexport function isDevelopment() {\n    return isEnv('development') === true;\n}\nexport function isTest() {\n    return isEnv('test') === true;\n}\n//# sourceMappingURL=environment.js.map","import { assign } from './util/assign';\nimport { valueToObjectRepresentation } from './storeUtils';\nexport function getMutationDefinition(doc) {\n    checkDocument(doc);\n    var mutationDef = doc.definitions.filter(function (definition) {\n        return definition.kind === 'OperationDefinition' &&\n            definition.operation === 'mutation';\n    })[0];\n    if (!mutationDef) {\n        throw new Error('Must contain a mutation definition.');\n    }\n    return mutationDef;\n}\nexport function checkDocument(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })\n        .map(function (definition) {\n        if (definition.kind !== 'OperationDefinition') {\n            throw new Error(\"Schema type definitions not allowed in queries. Found: \\\"\" + definition.kind + \"\\\"\");\n        }\n        return definition;\n    });\n    if (operations.length > 1) {\n        throw new Error(\"Ambiguous GraphQL document: contains \" + operations.length + \" operations\");\n    }\n    return doc;\n}\nexport function getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];\n}\nexport function getOperationDefinitionOrDie(document) {\n    var def = getOperationDefinition(document);\n    if (!def) {\n        throw new Error(\"GraphQL document is missing an operation\");\n    }\n    return def;\n}\nexport function getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === 'OperationDefinition' && definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\nexport function getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });\n}\nexport function getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    if (!queryDef || queryDef.operation !== 'query') {\n        throw new Error('Must contain a query definition.');\n    }\n    return queryDef;\n}\nexport function getFragmentDefinition(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    if (doc.definitions.length > 1) {\n        throw new Error('Fragment must have exactly one definition.');\n    }\n    var fragmentDef = doc.definitions[0];\n    if (fragmentDef.kind !== 'FragmentDefinition') {\n        throw new Error('Must be a fragment definition.');\n    }\n    return fragmentDef;\n}\nexport function getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === 'OperationDefinition') {\n            var operation = definition.operation;\n            if (operation === 'query' ||\n                operation === 'mutation' ||\n                operation === 'subscription') {\n                return definition;\n            }\n        }\n        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw new Error('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');\n}\nexport function createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nexport function getDefaultValues(definition) {\n    if (definition &&\n        definition.variableDefinitions &&\n        definition.variableDefinitions.length) {\n        var defaultValues = definition.variableDefinitions\n            .filter(function (_a) {\n            var defaultValue = _a.defaultValue;\n            return defaultValue;\n        })\n            .map(function (_a) {\n            var variable = _a.variable, defaultValue = _a.defaultValue;\n            var defaultValueObj = {};\n            valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);\n            return defaultValueObj;\n        });\n        return assign.apply(void 0, [{}].concat(defaultValues));\n    }\n    return {};\n}\nexport function variablesInOperation(operation) {\n    var names = new Set();\n    if (operation.variableDefinitions) {\n        for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {\n            var definition = _a[_i];\n            names.add(definition.variable.name.value);\n        }\n    }\n    return names;\n}\n//# sourceMappingURL=getFromAST.js.map","import * as tslib_1 from \"tslib\";\nimport stringify from 'fast-json-stable-stringify';\nexport function isScalarValue(value) {\n    return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\nexport function isNumberValue(value) {\n    return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\nfunction isStringValue(value) {\n    return value.kind === 'StringValue';\n}\nfunction isBooleanValue(value) {\n    return value.kind === 'BooleanValue';\n}\nfunction isIntValue(value) {\n    return value.kind === 'IntValue';\n}\nfunction isFloatValue(value) {\n    return value.kind === 'FloatValue';\n}\nfunction isVariable(value) {\n    return value.kind === 'Variable';\n}\nfunction isObjectValue(value) {\n    return value.kind === 'ObjectValue';\n}\nfunction isListValue(value) {\n    return value.kind === 'ListValue';\n}\nfunction isEnumValue(value) {\n    return value.kind === 'EnumValue';\n}\nfunction isNullValue(value) {\n    return value.kind === 'NullValue';\n}\nexport function valueToObjectRepresentation(argObj, name, value, variables) {\n    if (isIntValue(value) || isFloatValue(value)) {\n        argObj[name.value] = Number(value.value);\n    }\n    else if (isBooleanValue(value) || isStringValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isObjectValue(value)) {\n        var nestedArgObj_1 = {};\n        value.fields.map(function (obj) {\n            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n        });\n        argObj[name.value] = nestedArgObj_1;\n    }\n    else if (isVariable(value)) {\n        var variableValue = (variables || {})[value.name.value];\n        argObj[name.value] = variableValue;\n    }\n    else if (isListValue(value)) {\n        argObj[name.value] = value.values.map(function (listValue) {\n            var nestedArgArrayObj = {};\n            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n            return nestedArgArrayObj[name.value];\n        });\n    }\n    else if (isEnumValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isNullValue(value)) {\n        argObj[name.value] = null;\n    }\n    else {\n        throw new Error(\"The inline argument \\\"\" + name.value + \"\\\" of kind \\\"\" + value.kind + \"\\\"\" +\n            'is not supported. Use variables instead of inline arguments to ' +\n            'overcome this limitation.');\n    }\n}\nexport function storeKeyNameFromField(field, variables) {\n    var directivesObj = null;\n    if (field.directives) {\n        directivesObj = {};\n        field.directives.forEach(function (directive) {\n            directivesObj[directive.name.value] = {};\n            if (directive.arguments) {\n                directive.arguments.forEach(function (_a) {\n                    var name = _a.name, value = _a.value;\n                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n                });\n            }\n        });\n    }\n    var argObj = null;\n    if (field.arguments && field.arguments.length) {\n        argObj = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj, name, value, variables);\n        });\n    }\n    return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\n    'connection',\n    'include',\n    'skip',\n    'client',\n    'rest',\n    'export',\n];\nexport function getStoreKeyName(fieldName, args, directives) {\n    if (directives &&\n        directives['connection'] &&\n        directives['connection']['key']) {\n        if (directives['connection']['filter'] &&\n            directives['connection']['filter'].length > 0) {\n            var filterKeys = directives['connection']['filter']\n                ? directives['connection']['filter']\n                : [];\n            filterKeys.sort();\n            var queryArgs_1 = args;\n            var filteredArgs_1 = {};\n            filterKeys.forEach(function (key) {\n                filteredArgs_1[key] = queryArgs_1[key];\n            });\n            return directives['connection']['key'] + \"(\" + JSON.stringify(filteredArgs_1) + \")\";\n        }\n        else {\n            return directives['connection']['key'];\n        }\n    }\n    var completeFieldName = fieldName;\n    if (args) {\n        var stringifiedArgs = stringify(args);\n        completeFieldName += \"(\" + stringifiedArgs + \")\";\n    }\n    if (directives) {\n        Object.keys(directives).forEach(function (key) {\n            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)\n                return;\n            if (directives[key] && Object.keys(directives[key]).length) {\n                completeFieldName += \"@\" + key + \"(\" + JSON.stringify(directives[key]) + \")\";\n            }\n            else {\n                completeFieldName += \"@\" + key;\n            }\n        });\n    }\n    return completeFieldName;\n}\nexport function argumentsObjectFromField(field, variables) {\n    if (field.arguments && field.arguments.length) {\n        var argObj_1 = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj_1, name, value, variables);\n        });\n        return argObj_1;\n    }\n    return null;\n}\nexport function resultKeyNameFromField(field) {\n    return field.alias ? field.alias.value : field.name.value;\n}\nexport function isField(selection) {\n    return selection.kind === 'Field';\n}\nexport function isInlineFragment(selection) {\n    return selection.kind === 'InlineFragment';\n}\nexport function isIdValue(idObject) {\n    return idObject &&\n        idObject.type === 'id' &&\n        typeof idObject.generated === 'boolean';\n}\nexport function toIdValue(idConfig, generated) {\n    if (generated === void 0) { generated = false; }\n    return tslib_1.__assign({ type: 'id', generated: generated }, (typeof idConfig === 'string'\n        ? { id: idConfig, typename: undefined }\n        : idConfig));\n}\nexport function isJsonValue(jsonObject) {\n    return (jsonObject != null &&\n        typeof jsonObject === 'object' &&\n        jsonObject.type === 'json');\n}\nfunction defaultValueFromVariable(node) {\n    throw new Error(\"Variable nodes are not supported by valueFromNode\");\n}\nexport function valueFromNode(node, onVariable) {\n    if (onVariable === void 0) { onVariable = defaultValueFromVariable; }\n    switch (node.kind) {\n        case 'Variable':\n            return onVariable(node);\n        case 'NullValue':\n            return null;\n        case 'IntValue':\n            return parseInt(node.value, 10);\n        case 'FloatValue':\n            return parseFloat(node.value);\n        case 'ListValue':\n            return node.values.map(function (v) { return valueFromNode(v, onVariable); });\n        case 'ObjectValue': {\n            var value = {};\n            for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {\n                var field = _a[_i];\n                value[field.name.value] = valueFromNode(field.value, onVariable);\n            }\n            return value;\n        }\n        default:\n            return node.value;\n    }\n}\n//# sourceMappingURL=storeUtils.js.map","import * as tslib_1 from \"tslib\";\nexport function getFragmentQueryDocument(document, fragmentName) {\n    var actualFragmentName = fragmentName;\n    var fragments = [];\n    document.definitions.forEach(function (definition) {\n        if (definition.kind === 'OperationDefinition') {\n            throw new Error(\"Found a \" + definition.operation + \" operation\" + (definition.name ? \" named '\" + definition.name.value + \"'\" : '') + \". \" +\n                'No operations are allowed when using a fragment as a query. Only fragments are allowed.');\n        }\n        if (definition.kind === 'FragmentDefinition') {\n            fragments.push(definition);\n        }\n    });\n    if (typeof actualFragmentName === 'undefined') {\n        if (fragments.length !== 1) {\n            throw new Error(\"Found \" + fragments.length + \" fragments. `fragmentName` must be provided when there is not exactly 1 fragment.\");\n        }\n        actualFragmentName = fragments[0].name.value;\n    }\n    var query = tslib_1.__assign({}, document, { definitions: [\n            {\n                kind: 'OperationDefinition',\n                operation: 'query',\n                selectionSet: {\n                    kind: 'SelectionSet',\n                    selections: [\n                        {\n                            kind: 'FragmentSpread',\n                            name: {\n                                kind: 'Name',\n                                value: actualFragmentName,\n                            },\n                        },\n                    ],\n                },\n            }\n        ].concat(document.definitions) });\n    return query;\n}\n//# sourceMappingURL=fragments.js.map"],"sourceRoot":""}