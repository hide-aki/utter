{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/base64-js/index.js"],"names":["exports","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","arr","Arr","_byteLength","curByte","len","i","revLookup","charCodeAt","fromByteArray","uint8","length","extraBytes","parts","len2","push","encodeChunk","lookup","join","Uint8Array","Array","code","Error","indexOf","start","end","num","output"],"mappings":"4FAEAA,EAAAC,WAuCA,SAAAC,GACA,IAAAC,EAAAC,EAAAF,GACAG,EAAAF,EAAA,GACAG,EAAAH,EAAA,GACA,UAAAE,EAAAC,GAAA,EAAAA,GA1CAN,EAAAO,YAiDA,SAAAL,GAeA,IAdA,IAAAM,EACAL,EAAAC,EAAAF,GACAG,EAAAF,EAAA,GACAG,EAAAH,EAAA,GAEAM,EAAA,IAAAC,EAVA,SAAAR,EAAAG,EAAAC,GACA,UAAAD,EAAAC,GAAA,EAAAA,EASAK,CAAAT,EAAAG,EAAAC,IAEAM,EAAA,EAGAC,EAAAP,EAAA,EACAD,EAAA,EACAA,EAEAS,EAAA,EAAiBA,EAAAD,EAASC,GAAA,EAC1BN,EACAO,EAAAb,EAAAc,WAAAF,KAAA,GACAC,EAAAb,EAAAc,WAAAF,EAAA,QACAC,EAAAb,EAAAc,WAAAF,EAAA,OACAC,EAAAb,EAAAc,WAAAF,EAAA,IACAL,EAAAG,KAAAJ,GAAA,OACAC,EAAAG,KAAAJ,GAAA,MACAC,EAAAG,KAAA,IAAAJ,EAGA,IAAAF,IACAE,EACAO,EAAAb,EAAAc,WAAAF,KAAA,EACAC,EAAAb,EAAAc,WAAAF,EAAA,OACAL,EAAAG,KAAA,IAAAJ,GAGA,IAAAF,IACAE,EACAO,EAAAb,EAAAc,WAAAF,KAAA,GACAC,EAAAb,EAAAc,WAAAF,EAAA,OACAC,EAAAb,EAAAc,WAAAF,EAAA,OACAL,EAAAG,KAAAJ,GAAA,MACAC,EAAAG,KAAA,IAAAJ,GAGA,OAAAC,GA1FAT,EAAAiB,cAiHA,SAAAC,GAQA,IAPA,IAAAV,EACAK,EAAAK,EAAAC,OACAC,EAAAP,EAAA,EACAQ,EAAA,GAIAP,EAAA,EAAAQ,EAAAT,EAAAO,EAA0CN,EAAAQ,EAAUR,GAHpD,MAIAO,EAAAE,KAAAC,EACAN,EAAAJ,IALA,MAKAQ,IAAAR,EALA,QAUA,IAAAM,GACAZ,EAAAU,EAAAL,EAAA,GACAQ,EAAAE,KACAE,EAAAjB,GAAA,GACAiB,EAAAjB,GAAA,MACA,OAEG,IAAAY,IACHZ,GAAAU,EAAAL,EAAA,OAAAK,EAAAL,EAAA,GACAQ,EAAAE,KACAE,EAAAjB,GAAA,IACAiB,EAAAjB,GAAA,MACAiB,EAAAjB,GAAA,MACA,MAIA,OAAAa,EAAAK,KAAA,KA1IA,IALA,IAAAD,EAAA,GACAV,EAAA,GACAL,EAAA,oBAAAiB,sBAAAC,MAEAC,EAAA,mEACAf,EAAA,EAAAD,EAAAgB,EAAAV,OAAkCL,EAAAD,IAASC,EAC3CW,EAAAX,GAAAe,EAAAf,GACAC,EAAAc,EAAAb,WAAAF,MAQA,SAAAV,EAAAF,GACA,IAAAW,EAAAX,EAAAiB,OAEA,GAAAN,EAAA,IACA,UAAAiB,MAAA,kDAKA,IAAAzB,EAAAH,EAAA6B,QAAA,KAOA,OANA,IAAA1B,MAAAQ,GAMA,CAAAR,EAJAA,IAAAQ,EACA,EACA,EAAAR,EAAA,GAqEA,SAAAmB,EAAAN,EAAAc,EAAAC,GAGA,IAFA,IAAAzB,EARA0B,EASAC,EAAA,GACArB,EAAAkB,EAAqBlB,EAAAmB,EAASnB,GAAA,EAC9BN,GACAU,EAAAJ,IAAA,cACAI,EAAAJ,EAAA,cACA,IAAAI,EAAAJ,EAAA,IACAqB,EAAAZ,KAdAE,GADAS,EAeA1B,IAdA,OACAiB,EAAAS,GAAA,OACAT,EAAAS,GAAA,MACAT,EAAA,GAAAS,IAaA,OAAAC,EAAAT,KAAA,IAhGAX,EAAA,IAAAC,WAAA,OACAD,EAAA,IAAAC,WAAA","file":"bundle.npm.base64-js.bcb31fa163488d5acfb0.js","sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n"],"sourceRoot":""}