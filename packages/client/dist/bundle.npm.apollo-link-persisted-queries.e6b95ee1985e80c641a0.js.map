{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/apollo-link-persisted-queries/node_modules/zen-observable-ts/lib/index.js","webpack:////var/www/html/utter/node_modules/apollo-link-persisted-queries/node_modules/zen-observable-ts/lib/zenObservable.js","webpack:////var/www/html/utter/node_modules/apollo-link-persisted-queries/node_modules/apollo-link/lib/linkUtils.js","webpack:////var/www/html/utter/node_modules/apollo-link-persisted-queries/node_modules/apollo-link/lib/link.js","webpack:////var/www/html/utter/node_modules/apollo-link-persisted-queries/node_modules/apollo-utilities/lib/getFromAST.js","webpack:////var/www/html/utter/node_modules/apollo-link-persisted-queries/lib/index.js"],"names":["lib","a","extendStatics","__extends","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","LinkError","_super","message","link","_this","Error","isTerminating","request","createOperation","starting","operation","context","defineProperty","enumerable","value","next","printer","query","JSON","stringify","variables","operationName","getKey","passthrough","op","forward","of","toLink","handler","ApolloLink","empty","from","links","map","reduce","x","y","concat","split","test","left","right","leftLink","rightLink","first","second","firstLink","console","warn","nextLink","execute","transformedOperation","extensions","definitions","filter","definition","kind","name","transformOperation","OPERATION_FIELDS","_i","_a","keys","key","indexOf","validateOperation","__webpack_require__","__webpack_exports__","createPersistedQueryLink","sha256","defaultOptions","generateHash","update","digest","disable","graphQLErrors","some","response","getContext","status","useGETForHashedQueries","definitionIsMutation","lib_hasOwnProperty","hashesKey","Symbol","for","nextHashesChildKey","options","supportsPersistedQueries","hashesChildKey","getQueryHash","hashes","hashError","persistedQuery","version","sha256Hash","e","observer","subscription","originalFetchOptions","retried","setFetchOptions","retry","cb","networkError","errors","disablePayload","undefined","unsubscribe","setContext","http","includeQuery","includeExtensions","fetchOptions","subscribe","error","complete","bind","operationIsQuery","_b","method"],"mappings":"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","file":"bundle.npm.apollo-link-persisted-queries.e6b95ee1985e80c641a0.js","sourcesContent":["import { Observable } from './zenObservable';\nexport * from './zenObservable';\nexport default Observable;\n//# sourceMappingURL=index.js.map","/* tslint:disable */\nimport zenObservable from 'zen-observable';\nexport var Observable = zenObservable;\n//# sourceMappingURL=zenObservable.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { getOperationName } from 'apollo-utilities';\nimport Observable from 'zen-observable-ts';\nimport { print } from 'graphql/language/printer';\nexport function validateOperation(operation) {\n    var OPERATION_FIELDS = [\n        'query',\n        'operationName',\n        'variables',\n        'extensions',\n        'context',\n    ];\n    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (OPERATION_FIELDS.indexOf(key) < 0) {\n            throw new Error(\"illegal argument: \" + key);\n        }\n    }\n    return operation;\n}\nvar LinkError = /** @class */ (function (_super) {\n    __extends(LinkError, _super);\n    function LinkError(message, link) {\n        var _this = _super.call(this, message) || this;\n        _this.link = link;\n        return _this;\n    }\n    return LinkError;\n}(Error));\nexport { LinkError };\nexport function isTerminating(link) {\n    return link.request.length <= 1;\n}\nexport function toPromise(observable) {\n    var completed = false;\n    return new Promise(function (resolve, reject) {\n        observable.subscribe({\n            next: function (data) {\n                if (completed) {\n                    console.warn(\"Promise Wrapper does not support multiple results from Observable\");\n                }\n                else {\n                    completed = true;\n                    resolve(data);\n                }\n            },\n            error: reject,\n        });\n    });\n}\n// backwards compat\nexport var makePromise = toPromise;\nexport function fromPromise(promise) {\n    return new Observable(function (observer) {\n        promise\n            .then(function (value) {\n            observer.next(value);\n            observer.complete();\n        })\n            .catch(observer.error.bind(observer));\n    });\n}\nexport function fromError(errorValue) {\n    return new Observable(function (observer) {\n        observer.error(errorValue);\n    });\n}\nexport function transformOperation(operation) {\n    var transformedOperation = {\n        variables: operation.variables || {},\n        extensions: operation.extensions || {},\n        operationName: operation.operationName,\n        query: operation.query,\n    };\n    // best guess at an operation name\n    if (!transformedOperation.operationName) {\n        transformedOperation.operationName =\n            typeof transformedOperation.query !== 'string'\n                ? getOperationName(transformedOperation.query)\n                : '';\n    }\n    return transformedOperation;\n}\nexport function createOperation(starting, operation) {\n    var context = __assign({}, starting);\n    var setContext = function (next) {\n        if (typeof next === 'function') {\n            context = __assign({}, context, next(context));\n        }\n        else {\n            context = __assign({}, context, next);\n        }\n    };\n    var getContext = function () { return (__assign({}, context)); };\n    Object.defineProperty(operation, 'setContext', {\n        enumerable: false,\n        value: setContext,\n    });\n    Object.defineProperty(operation, 'getContext', {\n        enumerable: false,\n        value: getContext,\n    });\n    Object.defineProperty(operation, 'toKey', {\n        enumerable: false,\n        value: function () { return getKey(operation); },\n    });\n    return operation;\n}\nexport function getKey(operation) {\n    // XXX we're assuming here that variables will be serialized in the same order.\n    // that might not always be true\n    return print(operation.query) + \"|\" + JSON.stringify(operation.variables) + \"|\" + operation.operationName;\n}\n//# sourceMappingURL=linkUtils.js.map","import Observable from 'zen-observable-ts';\nimport { validateOperation, isTerminating, LinkError, transformOperation, createOperation, } from './linkUtils';\nvar passthrough = function (op, forward) { return (forward ? forward(op) : Observable.of()); };\nvar toLink = function (handler) {\n    return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n};\nexport var empty = function () {\n    return new ApolloLink(function (op, forward) { return Observable.of(); });\n};\nexport var from = function (links) {\n    if (links.length === 0)\n        return empty();\n    return links.map(toLink).reduce(function (x, y) { return x.concat(y); });\n};\nexport var split = function (test, left, right) {\n    if (right === void 0) { right = new ApolloLink(passthrough); }\n    var leftLink = toLink(left);\n    var rightLink = toLink(right);\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n        return new ApolloLink(function (operation) {\n            return test(operation)\n                ? leftLink.request(operation) || Observable.of()\n                : rightLink.request(operation) || Observable.of();\n        });\n    }\n    else {\n        return new ApolloLink(function (operation, forward) {\n            return test(operation)\n                ? leftLink.request(operation, forward) || Observable.of()\n                : rightLink.request(operation, forward) || Observable.of();\n        });\n    }\n};\n// join two Links together\nexport var concat = function (first, second) {\n    var firstLink = toLink(first);\n    if (isTerminating(firstLink)) {\n        console.warn(new LinkError(\"You are calling concat on a terminating link, which will have no effect\", firstLink));\n        return firstLink;\n    }\n    var nextLink = toLink(second);\n    if (isTerminating(nextLink)) {\n        return new ApolloLink(function (operation) {\n            return firstLink.request(operation, function (op) { return nextLink.request(op) || Observable.of(); }) || Observable.of();\n        });\n    }\n    else {\n        return new ApolloLink(function (operation, forward) {\n            return (firstLink.request(operation, function (op) {\n                return nextLink.request(op, forward) || Observable.of();\n            }) || Observable.of());\n        });\n    }\n};\nvar ApolloLink = /** @class */ (function () {\n    function ApolloLink(request) {\n        if (request)\n            this.request = request;\n    }\n    ApolloLink.prototype.split = function (test, left, right) {\n        if (right === void 0) { right = new ApolloLink(passthrough); }\n        return this.concat(split(test, left, right));\n    };\n    ApolloLink.prototype.concat = function (next) {\n        return concat(this, next);\n    };\n    ApolloLink.prototype.request = function (operation, forward) {\n        throw new Error('request is not implemented');\n    };\n    ApolloLink.empty = empty;\n    ApolloLink.from = from;\n    ApolloLink.split = split;\n    ApolloLink.execute = execute;\n    return ApolloLink;\n}());\nexport { ApolloLink };\nexport function execute(link, operation) {\n    return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of());\n}\n//# sourceMappingURL=link.js.map","import { assign } from './util/assign';\nimport { valueToObjectRepresentation } from './storeUtils';\nexport function getMutationDefinition(doc) {\n    checkDocument(doc);\n    var mutationDef = doc.definitions.filter(function (definition) {\n        return definition.kind === 'OperationDefinition' &&\n            definition.operation === 'mutation';\n    })[0];\n    if (!mutationDef) {\n        throw new Error('Must contain a mutation definition.');\n    }\n    return mutationDef;\n}\nexport function checkDocument(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })\n        .map(function (definition) {\n        if (definition.kind !== 'OperationDefinition') {\n            throw new Error(\"Schema type definitions not allowed in queries. Found: \\\"\" + definition.kind + \"\\\"\");\n        }\n        return definition;\n    });\n    if (operations.length > 1) {\n        throw new Error(\"Ambiguous GraphQL document: contains \" + operations.length + \" operations\");\n    }\n    return doc;\n}\nexport function getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];\n}\nexport function getOperationDefinitionOrDie(document) {\n    var def = getOperationDefinition(document);\n    if (!def) {\n        throw new Error(\"GraphQL document is missing an operation\");\n    }\n    return def;\n}\nexport function getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === 'OperationDefinition' && definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\nexport function getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });\n}\nexport function getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    if (!queryDef || queryDef.operation !== 'query') {\n        throw new Error('Must contain a query definition.');\n    }\n    return queryDef;\n}\nexport function getFragmentDefinition(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    if (doc.definitions.length > 1) {\n        throw new Error('Fragment must have exactly one definition.');\n    }\n    var fragmentDef = doc.definitions[0];\n    if (fragmentDef.kind !== 'FragmentDefinition') {\n        throw new Error('Must be a fragment definition.');\n    }\n    return fragmentDef;\n}\nexport function getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === 'OperationDefinition') {\n            var operation = definition.operation;\n            if (operation === 'query' ||\n                operation === 'mutation' ||\n                operation === 'subscription') {\n                return definition;\n            }\n        }\n        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw new Error('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');\n}\nexport function createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nexport function getDefaultValues(definition) {\n    if (definition &&\n        definition.variableDefinitions &&\n        definition.variableDefinitions.length) {\n        var defaultValues = definition.variableDefinitions\n            .filter(function (_a) {\n            var defaultValue = _a.defaultValue;\n            return defaultValue;\n        })\n            .map(function (_a) {\n            var variable = _a.variable, defaultValue = _a.defaultValue;\n            var defaultValueObj = {};\n            valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);\n            return defaultValueObj;\n        });\n        return assign.apply(void 0, [{}].concat(defaultValues));\n    }\n    return {};\n}\nexport function variablesInOperation(operation) {\n    var names = new Set();\n    if (operation.variableDefinitions) {\n        for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {\n            var definition = _a[_i];\n            names.add(definition.variable.name.value);\n        }\n    }\n    return names;\n}\n//# sourceMappingURL=getFromAST.js.map","import { ApolloLink, Observable } from 'apollo-link';\nvar sha256 = require('hash.js/lib/hash/sha/256');\nimport { print } from 'graphql/language/printer';\nexport var VERSION = 1;\nexport var defaultGenerateHash = function (query) {\n    return sha256()\n        .update(print(query))\n        .digest('hex');\n};\nexport var defaultOptions = {\n    generateHash: defaultGenerateHash,\n    disable: function (_a) {\n        var graphQLErrors = _a.graphQLErrors, operation = _a.operation;\n        if (graphQLErrors &&\n            graphQLErrors.some(function (_a) {\n                var message = _a.message;\n                return message === 'PersistedQueryNotSupported';\n            })) {\n            return true;\n        }\n        var response = operation.getContext().response;\n        if (response &&\n            response.status &&\n            (response.status === 400 || response.status === 500)) {\n            return true;\n        }\n        return false;\n    },\n    useGETForHashedQueries: false,\n};\nfunction definitionIsMutation(d) {\n    return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n}\nfunction operationIsQuery(operation) {\n    return !operation.query.definitions.some(definitionIsMutation);\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hashesKeyString = '__createPersistedQueryLink_hashes';\nvar hashesKey = typeof Symbol === 'function'\n    ? Symbol.for(hashesKeyString)\n    : hashesKeyString;\nvar nextHashesChildKey = 0;\nexport var createPersistedQueryLink = function (options) {\n    if (options === void 0) { options = {}; }\n    var _a = Object.assign({}, defaultOptions, options), generateHash = _a.generateHash, disable = _a.disable, useGETForHashedQueries = _a.useGETForHashedQueries;\n    var supportsPersistedQueries = true;\n    var hashesChildKey = 'forLink' + nextHashesChildKey++;\n    function getQueryHash(query) {\n        if (!query || typeof query !== \"object\") {\n            return generateHash(query);\n        }\n        if (!hasOwnProperty.call(query, hashesKey)) {\n            Object.defineProperty(query, hashesKey, {\n                value: Object.create(null),\n                enumerable: false,\n            });\n        }\n        var hashes = query[hashesKey];\n        return hasOwnProperty.call(hashes, hashesChildKey)\n            ? hashes[hashesChildKey]\n            : hashes[hashesChildKey] = generateHash(query);\n    }\n    return new ApolloLink(function (operation, forward) {\n        if (!forward) {\n            throw new Error('PersistedQueryLink cannot be the last link in the chain.');\n        }\n        var query = operation.query;\n        var hashError;\n        if (supportsPersistedQueries) {\n            try {\n                operation.extensions.persistedQuery = {\n                    version: VERSION,\n                    sha256Hash: getQueryHash(query),\n                };\n            }\n            catch (e) {\n                hashError = e;\n            }\n        }\n        return new Observable(function (observer) {\n            if (hashError) {\n                observer.error(hashError);\n                return;\n            }\n            var subscription;\n            var retried = false;\n            var originalFetchOptions;\n            var setFetchOptions = false;\n            var retry = function (_a, cb) {\n                var response = _a.response, networkError = _a.networkError;\n                if (!retried && ((response && response.errors) || networkError)) {\n                    retried = true;\n                    var disablePayload = {\n                        response: response,\n                        networkError: networkError,\n                        operation: operation,\n                        graphQLErrors: response ? response.errors : undefined,\n                    };\n                    supportsPersistedQueries = !disable(disablePayload);\n                    if ((response &&\n                        response.errors &&\n                        response.errors.some(function (_a) {\n                            var message = _a.message;\n                            return message === 'PersistedQueryNotFound';\n                        })) ||\n                        !supportsPersistedQueries) {\n                        if (subscription)\n                            subscription.unsubscribe();\n                        operation.setContext({\n                            http: {\n                                includeQuery: true,\n                                includeExtensions: supportsPersistedQueries,\n                            },\n                        });\n                        if (setFetchOptions) {\n                            operation.setContext({ fetchOptions: originalFetchOptions });\n                        }\n                        subscription = forward(operation).subscribe(handler);\n                        return;\n                    }\n                }\n                cb();\n            };\n            var handler = {\n                next: function (response) {\n                    retry({ response: response }, function () { return observer.next(response); });\n                },\n                error: function (networkError) {\n                    retry({ networkError: networkError }, function () { return observer.error(networkError); });\n                },\n                complete: observer.complete.bind(observer),\n            };\n            operation.setContext({\n                http: {\n                    includeQuery: !supportsPersistedQueries,\n                    includeExtensions: supportsPersistedQueries,\n                },\n            });\n            if (useGETForHashedQueries &&\n                supportsPersistedQueries &&\n                operationIsQuery(operation)) {\n                operation.setContext(function (_a) {\n                    var _b = _a.fetchOptions, fetchOptions = _b === void 0 ? {} : _b;\n                    originalFetchOptions = fetchOptions;\n                    return {\n                        fetchOptions: Object.assign({}, fetchOptions, { method: 'GET' }),\n                    };\n                });\n                setFetchOptions = true;\n            }\n            subscription = forward(operation).subscribe(handler);\n            return function () {\n                if (subscription)\n                    subscription.unsubscribe();\n            };\n        });\n    });\n};\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}