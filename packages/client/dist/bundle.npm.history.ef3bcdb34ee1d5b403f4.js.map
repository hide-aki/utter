{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/history/DOMUtils.js","webpack:////var/www/html/utter/node_modules/history/createTransitionManager.js","webpack:////var/www/html/utter/node_modules/history/es/PathUtils.js","webpack:////var/www/html/utter/node_modules/history/es/LocationUtils.js","webpack:////var/www/html/utter/node_modules/history/es/createTransitionManager.js","webpack:////var/www/html/utter/node_modules/history/es/DOMUtils.js","webpack:////var/www/html/utter/node_modules/history/es/createBrowserHistory.js","webpack:////var/www/html/utter/node_modules/history/es/createHashHistory.js","webpack:////var/www/html/utter/node_modules/history/es/createMemoryHistory.js","webpack:////var/www/html/utter/node_modules/history/es/index.js","webpack:////var/www/html/utter/node_modules/history/createBrowserHistory.js","webpack:////var/www/html/utter/node_modules/history/PathUtils.js","webpack:////var/www/html/utter/node_modules/history/node_modules/warning/browser.js","webpack:////var/www/html/utter/node_modules/history/LocationUtils.js"],"names":["exports","__esModule","canUseDOM","window","document","createElement","addEventListener","node","event","listener","attachEvent","removeEventListener","detachEvent","getConfirmation","message","callback","confirm","supportsHistory","ua","navigator","userAgent","indexOf","history","supportsPopStateOnHashChange","supportsGoWithoutReloadUsingHash","isExtraneousPopstateEvent","undefined","state","obj","_warning","__webpack_require__","_warning2","default","prompt","listeners","setPrompt","nextPrompt","confirmTransitionTo","location","action","getUserConfirmation","result","appendListener","fn","isActive","apply","arguments","push","filter","item","notifyListeners","_len","length","args","Array","_key","forEach","addLeadingSlash","path","charAt","hasBasename","prefix","RegExp","test","stripBasename","substr","stripTrailingSlash","slice","createPath","pathname","search","hash","_extends","Object","assign","target","i","source","key","prototype","hasOwnProperty","call","LocationUtils_createLocation","currentLocation","hashIndex","searchIndex","parsePath","decodeURI","e","URIError","resolve_pathname","LocationUtils_locationsAreEqual","a","b","value_equal","es_createTransitionManager","browser_default","_typeof","Symbol","iterator","constructor","createBrowserHistory_extends","getHistoryState","es_createBrowserHistory","props","invariant_browser_default","globalHistory","canUseHistory","needsHashChangeListener","_props$forceRefresh","forceRefresh","_props$getUserConfirm","_props$keyLength","keyLength","basename","getDOMLocation","historyState","_ref","_window$location","createKey","Math","random","toString","transitionManager","setState","nextState","handlePopState","handlePop","handleHashChange","forceNextPop","ok","revertPop","fromLocation","toLocation","toIndex","allKeys","fromIndex","delta","go","initialLocation","createHref","n","listenerCount","checkDOMListeners","isBlocked","href","pushState","prevIndex","nextKeys","replace","replaceState","goBack","goForward","block","unblock","listen","unlisten","d","__webpack_exports__","_interopRequireDefault","_invariant2","_LocationUtils","_PathUtils","_createTransitionManager2","_DOMUtils","createLocation","stripLeadingSlash","module","locationsAreEqual","_resolvePathname2","_valueEqual2"],"mappings":"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","file":"bundle.npm.history.ef3bcdb34ee1d5b403f4.js","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nvar canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nvar addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {\n  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);\n};\n\nvar removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {\n  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);\n};\n\nvar getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {\n  return callback(window.confirm(message));\n}; // eslint-disable-line no-alert\n\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nvar supportsHistory = exports.supportsHistory = function supportsHistory() {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n\n  return window.history && 'pushState' in window.history;\n};\n\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nvar supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n};\n\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nvar supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n};\n\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\nvar isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n};","'use strict';\n\nexports.__esModule = true;\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');\n\n    prompt = nextPrompt;\n\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(fn) {\n    var isActive = true;\n\n    var listener = function listener() {\n      if (isActive) fn.apply(undefined, arguments);\n    };\n\n    listeners.push(listener);\n\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\nexports.default = createTransitionManager;","export var addLeadingSlash = function addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n};\n\nexport var stripLeadingSlash = function stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n};\n\nexport var hasBasename = function hasBasename(path, prefix) {\n  return new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path);\n};\n\nexport var stripBasename = function stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\n\nexport var stripTrailingSlash = function stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\n\nexport var parsePath = function parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n\n  var hashIndex = pathname.indexOf('#');\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nexport var createPath = function createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n\n\n  var path = pathname || '/';\n\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;\n\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;\n\n  return path;\n};","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport resolvePathname from 'resolve-pathname';\nimport valueEqual from 'value-equal';\nimport { parsePath } from './PathUtils';\n\nexport var createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nexport var locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n};","import warning from 'warning';\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    warning(prompt == null, 'A history supports only one prompt at a time');\n\n    prompt = nextPrompt;\n\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(fn) {\n    var isActive = true;\n\n    var listener = function listener() {\n      if (isActive) fn.apply(undefined, arguments);\n    };\n\n    listeners.push(listener);\n\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\nexport default createTransitionManager;","export var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nexport var addEventListener = function addEventListener(node, event, listener) {\n  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);\n};\n\nexport var removeEventListener = function removeEventListener(node, event, listener) {\n  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);\n};\n\nexport var getConfirmation = function getConfirmation(message, callback) {\n  return callback(window.confirm(message));\n}; // eslint-disable-line no-alert\n\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nexport var supportsHistory = function supportsHistory() {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n\n  return window.history && 'pushState' in window.history;\n};\n\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nexport var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n};\n\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nexport var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n};\n\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\nexport var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n};","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation } from './LocationUtils';\nimport { addLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, isExtraneousPopstateEvent } from './DOMUtils';\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nvar getHistoryState = function getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n};\n\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function createBrowserHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant(canUseDOM, 'Browser history needs a DOM');\n\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n\n  var _props$forceRefresh = props.forceRefresh,\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\n      _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  var getDOMLocation = function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n\n\n    var path = pathname + search + hash;\n\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = stripBasename(path, basename);\n\n    return createLocation(path, state, key);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var handlePopState = function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n\n    handlePop(getDOMLocation(event.state));\n  };\n\n  var handleHashChange = function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  };\n\n  var forceNextPop = false;\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return basename + createPath(location);\n  };\n\n  var push = function push(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.pushState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n\n        window.location.href = href;\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.replaceState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n\n        window.location.replace(href);\n      }\n    });\n  };\n\n  var go = function go(n) {\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      addEventListener(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createBrowserHistory;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation, locationsAreEqual } from './LocationUtils';\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\n\nvar HashChangeEvent = 'hashchange';\n\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant(canUseDOM, 'Hash history needs a DOM');\n\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = stripBasename(path, basename);\n\n    return createLocation(path);\n  };\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + createPath(location));\n  };\n\n  var push = function push(path, state) {\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n        nextPaths.push(path);\n        allPaths = nextPaths;\n\n        setState({ action: action, location: location });\n      } else {\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createHashHistory;","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport { createPath } from './PathUtils';\nimport { createLocation } from './LocationUtils';\nimport createTransitionManager from './createTransitionManager';\n\nvar clamp = function clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n};\n\n/**\n * Creates a history object that stores locations in memory.\n */\nvar createMemoryHistory = function createMemoryHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var getUserConfirmation = props.getUserConfirmation,\n      _props$initialEntries = props.initialEntries,\n      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,\n      _props$initialIndex = props.initialIndex,\n      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\n  });\n\n  // Public interface\n\n  var createHref = createPath;\n\n  var push = function push(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n\n      var nextEntries = history.entries.slice(0);\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      history.entries[history.index] = location;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var canGo = function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  };\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return transitionManager.setPrompt(prompt);\n  };\n\n  var listen = function listen(listener) {\n    return transitionManager.appendListener(listener);\n  };\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createMemoryHistory;","import _createBrowserHistory from './createBrowserHistory';\nexport { _createBrowserHistory as createBrowserHistory };\nimport _createHashHistory from './createHashHistory';\nexport { _createHashHistory as createHashHistory };\nimport _createMemoryHistory from './createMemoryHistory';\nexport { _createMemoryHistory as createMemoryHistory };\n\nexport { createLocation, locationsAreEqual } from './LocationUtils';\nexport { parsePath, createPath } from './PathUtils';","'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _LocationUtils = require('./LocationUtils');\n\nvar _PathUtils = require('./PathUtils');\n\nvar _createTransitionManager = require('./createTransitionManager');\n\nvar _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);\n\nvar _DOMUtils = require('./DOMUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nvar getHistoryState = function getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n};\n\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function createBrowserHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');\n\n  var globalHistory = window.history;\n  var canUseHistory = (0, _DOMUtils.supportsHistory)();\n  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();\n\n  var _props$forceRefresh = props.forceRefresh,\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\n      _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';\n\n  var getDOMLocation = function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n\n\n    var path = pathname + search + hash;\n\n    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);\n\n    return (0, _LocationUtils.createLocation)(path, state, key);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var transitionManager = (0, _createTransitionManager2.default)();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var handlePopState = function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;\n\n    handlePop(getDOMLocation(event.state));\n  };\n\n  var handleHashChange = function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  };\n\n  var forceNextPop = false;\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return basename + (0, _PathUtils.createPath)(location);\n  };\n\n  var push = function push(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.pushState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n\n        window.location.href = href;\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.replaceState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n\n        window.location.replace(href);\n      }\n    });\n  };\n\n  var go = function go(n) {\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexports.default = createBrowserHistory;","'use strict';\n\nexports.__esModule = true;\nvar addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n};\n\nvar stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n};\n\nvar hasBasename = exports.hasBasename = function hasBasename(path, prefix) {\n  return new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path);\n};\n\nvar stripBasename = exports.stripBasename = function stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\n\nvar stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\n\nvar parsePath = exports.parsePath = function parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n\n  var hashIndex = pathname.indexOf('#');\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nvar createPath = exports.createPath = function createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n\n\n  var path = pathname || '/';\n\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;\n\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;\n\n  return path;\n};","/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function() {};\n\nif (process.env.NODE_ENV !== 'production') {\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || (/^[s\\W]*$/).test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n","'use strict';\n\nexports.__esModule = true;\nexports.locationsAreEqual = exports.createLocation = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _resolvePathname = require('resolve-pathname');\n\nvar _resolvePathname2 = _interopRequireDefault(_resolvePathname);\n\nvar _valueEqual = require('value-equal');\n\nvar _valueEqual2 = _interopRequireDefault(_valueEqual);\n\nvar _PathUtils = require('./PathUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = (0, _PathUtils.parsePath)(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nvar locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);\n};"],"sourceRoot":""}