{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/react-router-redux/es/reducer.js","webpack:////var/www/html/utter/node_modules/react-router-redux/es/ConnectedRouter.js","webpack:////var/www/html/utter/node_modules/react-router-redux/es/actions.js","webpack:////var/www/html/utter/node_modules/react-router-redux/es/middleware.js","webpack:////var/www/html/utter/node_modules/react-router-redux/es/index.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","LOCATION_CHANGE","initialState","location","routerReducer","state","undefined","_ref","type","payload","_possibleConstructorReturn","self","ReferenceError","ConnectedRouter_ConnectedRouter","_Component","ConnectedRouter","_temp","_this","instance","Constructor","TypeError","_classCallCheck","this","_len","args","Array","_key","apply","concat","handleLocationChange","store","dispatch","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_inherits","componentWillMount","_props","props","propsStore","history","isSSR","context","unsubscribeFromHistory","listen","componentWillUnmount","render","react_default","a","createElement","Router","react","propTypes","prop_types_default","object","isRequired","children","node","bool","contextTypes","es_ConnectedRouter","CALL_HISTORY_METHOD","updateLocation","method","push","routerMiddleware","next","action","_action$payload","__webpack_require__","d","__webpack_exports__"],"mappings":"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","file":"bundle.npm.react-router-redux.87c7e5977b7f3faf8a19.js","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n/**\n * This action type will be dispatched when your history\n * receives a location change.\n */\nexport var LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\n\nvar initialState = {\n  location: null\n\n  /**\n   * This reducer will update the state with the most recent location history\n   * has transitioned to. This may not be in sync with the router, particularly\n   * if you have asynchronously-loaded routes, so reading from and relying on\n   * this state is discouraged.\n   */\n};export function routerReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      type = _ref.type,\n      payload = _ref.payload;\n\n  if (type === LOCATION_CHANGE) {\n    return _extends({}, state, { location: payload });\n  }\n\n  return state;\n}","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Router } from 'react-router';\n\nimport { LOCATION_CHANGE } from './reducer';\n\nvar ConnectedRouter = function (_Component) {\n  _inherits(ConnectedRouter, _Component);\n\n  function ConnectedRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ConnectedRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.handleLocationChange = function (location) {\n      _this.store.dispatch({\n        type: LOCATION_CHANGE,\n        payload: location\n      });\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  ConnectedRouter.prototype.componentWillMount = function componentWillMount() {\n    var _props = this.props,\n        propsStore = _props.store,\n        history = _props.history,\n        isSSR = _props.isSSR;\n\n    this.store = propsStore || this.context.store;\n    this.handleLocationChange(history.location);\n\n    if (!isSSR) this.unsubscribeFromHistory = history.listen(this.handleLocationChange);\n  };\n\n  ConnectedRouter.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.unsubscribeFromHistory) this.unsubscribeFromHistory();\n  };\n\n  ConnectedRouter.prototype.render = function render() {\n    return React.createElement(Router, this.props);\n  };\n\n  return ConnectedRouter;\n}(Component);\n\nConnectedRouter.propTypes = {\n  store: PropTypes.object,\n  history: PropTypes.object.isRequired,\n  children: PropTypes.node,\n  isSSR: PropTypes.bool\n};\nConnectedRouter.contextTypes = {\n  store: PropTypes.object\n};\n\n\nexport default ConnectedRouter;","\n/**\n * This action type will be dispatched by the history actions below.\n * If you're writing a middleware to watch for navigation events, be sure to\n * look for actions of this type.\n */\nexport var CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';\n\nfunction updateLocation(method) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return {\n      type: CALL_HISTORY_METHOD,\n      payload: { method: method, args: args }\n    };\n  };\n}\n\n/**\n * These actions correspond to the history API.\n * The associated routerMiddleware will capture these events before they get to\n * your reducer and reissue them as the matching function on your history.\n */\nexport var push = updateLocation('push');\nexport var replace = updateLocation('replace');\nexport var go = updateLocation('go');\nexport var goBack = updateLocation('goBack');\nexport var goForward = updateLocation('goForward');\n\nexport var routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };","import { CALL_HISTORY_METHOD } from './actions';\n\n/**\n * This middleware captures CALL_HISTORY_METHOD actions to redirect to the\n * provided history object. This will prevent these actions from reaching your\n * reducer or any middleware that comes after this one.\n */\nexport default function routerMiddleware(history) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type !== CALL_HISTORY_METHOD) {\n          return next(action);\n        }\n\n        var _action$payload = action.payload,\n            method = _action$payload.method,\n            args = _action$payload.args;\n\n        history[method].apply(history, args);\n      };\n    };\n  };\n}","import _ConnectedRouter from './ConnectedRouter';\nexport { _ConnectedRouter as ConnectedRouter };\n\nexport { getLocation, createMatchSelector } from './selectors';\nexport { LOCATION_CHANGE, routerReducer } from './reducer';\nexport { CALL_HISTORY_METHOD, push, replace, go, goBack, goForward, routerActions } from './actions';\nimport _routerMiddleware from './middleware';\nexport { _routerMiddleware as routerMiddleware };"],"sourceRoot":""}