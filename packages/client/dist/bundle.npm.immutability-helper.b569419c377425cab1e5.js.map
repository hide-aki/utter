{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/immutability-helper/index.js"],"names":["invariant","__webpack_require__","hasOwnProperty","Object","prototype","splice","Array","toString","type","obj","call","slice","assign","target","source","getAllKeys","forEach","key","getOwnPropertySymbols","keys","concat","copy","object","isArray","constructor","length","Map","Set","getPrototypeOf","create","newContext","commands","defaultCommands","update","extend","directive","fn","isEquals","a","b","spec","$apply","join","nextObject","objectWasNextObject","nextValueForKey","get","nextObjectValue","set","$push","value","invariantPushAndUnshift","$unshift","$splice","originalObject","invariantSplice","invariantSplices","args","apply","$set","invariantSet","$toggle","targets","invariantSpecArray","nextObjectCopy","$unset","$add","invariantMapOrSet","pair","has","add","$remove","delete","$merge","specValue","original","contextForExport","command","typeOfTarget","module","exports","default"],"mappings":"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","file":"bundle.npm.immutability-helper.b569419c377425cab1e5.js","sourcesContent":["var invariant = require('invariant');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\n\nvar toString = Object.prototype.toString\nvar type = function(obj) {\n  return toString.call(obj).slice(8, -1);\n}\n\nvar assign = Object.assign || /* istanbul ignore next */ function assign(target, source) {\n  getAllKeys(source).forEach(function(key) {\n    if (hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n};\n\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function' ?\n  function(obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)) } :\n  /* istanbul ignore next */ function(obj) { return Object.keys(obj) };\n\n/* istanbul ignore next */\nfunction copy(object) {\n  if (Array.isArray(object)) {\n    return assign(object.constructor(object.length), object)\n  } else if (type(object) === 'Map') {\n    return new Map(object)\n  } else if (type(object) === 'Set') {\n    return new Set(object)\n  } else if (object && typeof object === 'object') {\n    var prototype = Object.getPrototypeOf(object);\n    return assign(Object.create(prototype), object);\n  } else {\n    return object;\n  }\n}\n\nfunction newContext() {\n  var commands = assign({}, defaultCommands);\n  update.extend = function(directive, fn) {\n    commands[directive] = fn;\n  };\n  update.isEquals = function(a, b) { return a === b; };\n\n  return update;\n\n  function update(object, spec) {\n    if (typeof spec === 'function') {\n      spec = { $apply: spec };\n    }\n\n    if (!(Array.isArray(object) && Array.isArray(spec))) {\n      invariant(\n        !Array.isArray(spec),\n        'update(): You provided an invalid spec to update(). The spec may ' +\n        'not contain an array except as the value of $set, $push, $unshift, ' +\n        '$splice or any custom command allowing an array value.'\n      );\n    }\n\n    invariant(\n      typeof spec === 'object' && spec !== null,\n      'update(): You provided an invalid spec to update(). The spec and ' +\n      'every included key path must be plain objects containing one of the ' +\n      'following commands: %s.',\n      Object.keys(commands).join(', ')\n    );\n\n    var nextObject = object;\n    var index, key;\n    getAllKeys(spec).forEach(function(key) {\n      if (hasOwnProperty.call(commands, key)) {\n        var objectWasNextObject = object === nextObject;\n        nextObject = commands[key](spec[key], nextObject, spec, object);\n        if (objectWasNextObject && update.isEquals(nextObject, object)) {\n          nextObject = object;\n        }\n      } else {\n        var nextValueForKey =\n          type(object) === 'Map'\n            ? update(object.get(key), spec[key])\n            : update(object[key], spec[key]);\n        var nextObjectValue =\n          type(nextObject) === 'Map'\n              ? nextObject.get(key)\n              : nextObject[key];\n        if (!update.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === 'undefined' && !hasOwnProperty.call(object, key)) {\n          if (nextObject === object) {\n            nextObject = copy(object);\n          }\n          if (type(nextObject) === 'Map') {\n            nextObject.set(key, nextValueForKey);\n          } else {\n            nextObject[key] = nextValueForKey;\n          }\n        }\n      }\n    })\n    return nextObject;\n  }\n\n}\n\nvar defaultCommands = {\n  $push: function(value, nextObject, spec) {\n    invariantPushAndUnshift(nextObject, spec, '$push');\n    return value.length ? nextObject.concat(value) : nextObject;\n  },\n  $unshift: function(value, nextObject, spec) {\n    invariantPushAndUnshift(nextObject, spec, '$unshift');\n    return value.length ? value.concat(nextObject) : nextObject;\n  },\n  $splice: function(value, nextObject, spec, originalObject) {\n    invariantSplices(nextObject, spec);\n    value.forEach(function(args) {\n      invariantSplice(args);\n      if (nextObject === originalObject && args.length) nextObject = copy(originalObject);\n      splice.apply(nextObject, args);\n    });\n    return nextObject;\n  },\n  $set: function(value, nextObject, spec) {\n    invariantSet(spec);\n    return value;\n  },\n  $toggle: function(targets, nextObject) {\n    invariantSpecArray(targets, '$toggle');\n    var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n\n    targets.forEach(function(target) {\n      nextObjectCopy[target] = !nextObject[target];\n    });\n\n    return nextObjectCopy;\n  },\n  $unset: function(value, nextObject, spec, originalObject) {\n    invariantSpecArray(value, '$unset');\n    value.forEach(function(key) {\n      if (Object.hasOwnProperty.call(nextObject, key)) {\n        if (nextObject === originalObject) nextObject = copy(originalObject);\n        delete nextObject[key];\n      }\n    });\n    return nextObject;\n  },\n  $add: function(value, nextObject, spec, originalObject) {\n    invariantMapOrSet(nextObject, '$add');\n    invariantSpecArray(value, '$add');\n    if (type(nextObject) === 'Map') {\n      value.forEach(function(pair) {\n        var key = pair[0];\n        var value = pair[1];\n        if (nextObject === originalObject && nextObject.get(key) !== value) nextObject = copy(originalObject);\n        nextObject.set(key, value);\n      });\n    } else {\n      value.forEach(function(value) {\n        if (nextObject === originalObject && !nextObject.has(value)) nextObject = copy(originalObject);\n        nextObject.add(value);\n      });\n    }\n    return nextObject;\n  },\n  $remove: function(value, nextObject, spec, originalObject) {\n    invariantMapOrSet(nextObject, '$remove');\n    invariantSpecArray(value, '$remove');\n    value.forEach(function(key) {\n      if (nextObject === originalObject && nextObject.has(key)) nextObject = copy(originalObject);\n      nextObject.delete(key);\n    });\n    return nextObject;\n  },\n  $merge: function(value, nextObject, spec, originalObject) {\n    invariantMerge(nextObject, value);\n    getAllKeys(value).forEach(function(key) {\n      if (value[key] !== nextObject[key]) {\n        if (nextObject === originalObject) nextObject = copy(originalObject);\n        nextObject[key] = value[key];\n      }\n    });\n    return nextObject;\n  },\n  $apply: function(value, original) {\n    invariantApply(value);\n    return value(original);\n  }\n};\n\nvar contextForExport = newContext();\n\nmodule.exports = contextForExport;\nmodule.exports.default = contextForExport;\nmodule.exports.newContext = newContext;\n\n// invariants\n\nfunction invariantPushAndUnshift(value, spec, command) {\n  invariant(\n    Array.isArray(value),\n    'update(): expected target of %s to be an array; got %s.',\n    command,\n    value\n  );\n  invariantSpecArray(spec[command], command)\n}\n\nfunction invariantSpecArray(spec, command) {\n  invariant(\n    Array.isArray(spec),\n    'update(): expected spec of %s to be an array; got %s. ' +\n    'Did you forget to wrap your parameter in an array?',\n    command,\n    spec\n  );\n}\n\nfunction invariantSplices(value, spec) {\n  invariant(\n    Array.isArray(value),\n    'Expected $splice target to be an array; got %s',\n    value\n  );\n  invariantSplice(spec['$splice']);\n}\n\nfunction invariantSplice(value) {\n  invariant(\n    Array.isArray(value),\n    'update(): expected spec of $splice to be an array of arrays; got %s. ' +\n    'Did you forget to wrap your parameters in an array?',\n    value\n  );\n}\n\nfunction invariantApply(fn) {\n  invariant(\n    typeof fn === 'function',\n    'update(): expected spec of $apply to be a function; got %s.',\n    fn\n  );\n}\n\nfunction invariantSet(spec) {\n  invariant(\n    Object.keys(spec).length === 1,\n    'Cannot have more than one key in an object with $set'\n  );\n}\n\nfunction invariantMerge(target, specValue) {\n  invariant(\n    specValue && typeof specValue === 'object',\n    'update(): $merge expects a spec of type \\'object\\'; got %s',\n    specValue\n  );\n  invariant(\n    target && typeof target === 'object',\n    'update(): $merge expects a target of type \\'object\\'; got %s',\n    target\n  );\n}\n\nfunction invariantMapOrSet(target, command) {\n  var typeOfTarget = type(target);\n  invariant(\n    typeOfTarget === 'Map' || typeOfTarget === 'Set',\n    'update(): %s expects a target of type Set or Map; got %s',\n    command,\n    typeOfTarget\n  );\n}\n"],"sourceRoot":""}