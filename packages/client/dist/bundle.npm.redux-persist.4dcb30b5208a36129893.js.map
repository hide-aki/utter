{"version":3,"sources":["webpack:////var/www/html/utter/node_modules/redux-persist/lib/storage/getStorage.js","webpack:////var/www/html/utter/node_modules/redux-persist/lib/storage/createWebStorage.js","webpack:////var/www/html/utter/node_modules/redux-persist/lib/storage/index.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/integration/react.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/constants.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/createPersistoid.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/getStoredState.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/purgeStoredState.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/persistReducer.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/persistStore.js","webpack:////var/www/html/utter/node_modules/redux-persist/es/index.js"],"names":["exports","__esModule","_typeof","Symbol","iterator","obj","constructor","prototype","noop","default","type","storageType","self","storage","testKey","setItem","getItem","removeItem","e","hasStorage","noopStorage","_getStorage2","key","Promise","resolve","reject","item","_getStorage","__webpack_require__","_createWebStorage","_createWebStorage2","d","__webpack_exports__","PersistGate","react__WEBPACK_IMPORTED_MODULE_0__","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","Constructor","protoProps","staticProps","_possibleConstructorReturn","call","ReferenceError","_PureComponent","_ref","_temp","_this","instance","TypeError","_classCallCheck","this","_len","arguments","args","Array","_key","__proto__","getPrototypeOf","apply","concat","state","bootstrapped","handlePersistorState","persistor","getState","onBeforeLift","then","setState","catch","_unsubscribe","subClass","superClass","create","value","setPrototypeOf","_inherits","subscribe","children","loading","defaultProps","KEY_PREFIX","FLUSH","REHYDRATE","PAUSE","PERSIST","PURGE","REGISTER","DEFAULT_VERSION","_extends","assign","source","hasOwnProperty","autoMergeLevel1","inboundState","originalState","reducedState","debug","newState","keys","forEach","createPersistoid","config","blacklist","whitelist","transforms","throttle","storageKey","undefined","keyPrefix","serialize","x","defaultSerialize","lastState","stagedState","keysToProcess","timeIterator","writePromise","processNextKey","clearInterval","shift","endState","reduce","subState","transformer","in","err","console","error","onWriteFail","update","indexOf","passWhitelistBlacklist","push","setInterval","flush","data","JSON","stringify","getStoredState_getStoredState","deserialize","defaultDeserialize","serialized","rawState","reduceRight","out","serial","parse","warnIfRemoveError","persistReducer_extends","DEFAULT_TIMEOUT","persistReducer","baseReducer","version","stateReconciler","getStoredState","timeout","_persistoid","_purge","_paused","conditionalUpdate","_persist","rehydrated","action","restState","_objectWithoutProperties","_sealed","_rehydrate","payload","rehydrate","setTimeout","Error","register","restoredState","migrate","s","v","migratedState","migrateErr","result","purgeStoredState","reconciledRest","_newState","persistStore_extends","_toConsumableArray","arr","isArray","arr2","from","initialState","registry","persistStore_persistorReducer","firstIndex","splice","persistStore","store","options","cb","boostrappedCb","_pStore","es","enhancer","dispatch","rehydrateAction","purge","results","purgeResult","all","flushResult","pause","persist"],"mappings":"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","file":"bundle.npm.redux-persist.4dcb30b5208a36129893.js","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = getStorage;\n\n\nfunction noop() {}\n\nvar noopStorage = {\n  getItem: noop,\n  setItem: noop,\n  removeItem: noop\n};\n\nfunction hasStorage(storageType) {\n  if ((typeof self === 'undefined' ? 'undefined' : _typeof(self)) !== 'object' || !(storageType in self)) {\n    return false;\n  }\n\n  try {\n    var storage = self[storageType];\n    var testKey = 'redux-persist ' + storageType + ' test';\n    storage.setItem(testKey, 'test');\n    storage.getItem(testKey);\n    storage.removeItem(testKey);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') console.warn('redux-persist ' + storageType + ' test failed, persistence will be disabled.');\n    return false;\n  }\n  return true;\n}\n\nfunction getStorage(type) {\n  var storageType = type + 'Storage';\n  if (hasStorage(storageType)) return self[storageType];else {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('redux-persist failed to create sync storage. falling back to memory storage.');\n    }\n    return noopStorage;\n  }\n}","'use strict';\n\nexports.__esModule = true;\nexports.default = createWebStorage;\n\nvar _getStorage = require('./getStorage');\n\nvar _getStorage2 = _interopRequireDefault(_getStorage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createWebStorage(type) {\n  var storage = (0, _getStorage2.default)(type);\n  return {\n    getItem: function getItem(key) {\n      return new Promise(function (resolve, reject) {\n        resolve(storage.getItem(key));\n      });\n    },\n    setItem: function setItem(key, item) {\n      return new Promise(function (resolve, reject) {\n        resolve(storage.setItem(key, item));\n      });\n    },\n    removeItem: function removeItem(key) {\n      return new Promise(function (resolve, reject) {\n        resolve(storage.removeItem(key));\n      });\n    }\n  };\n}","'use strict';\n\nexports.__esModule = true;\n\nvar _createWebStorage = require('./createWebStorage');\n\nvar _createWebStorage2 = _interopRequireDefault(_createWebStorage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (0, _createWebStorage2.default)('local');","var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React, { PureComponent } from 'react'; // eslint-disable-line import/no-unresolved\n// eslint-disable-line import/no-unresolved\n\n\nexport var PersistGate = function (_PureComponent) {\n  _inherits(PersistGate, _PureComponent);\n\n  function PersistGate() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, PersistGate);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = PersistGate.__proto__ || Object.getPrototypeOf(PersistGate)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      bootstrapped: false\n    }, _this.handlePersistorState = function () {\n      var persistor = _this.props.persistor;\n\n      var _persistor$getState = persistor.getState(),\n          bootstrapped = _persistor$getState.bootstrapped;\n\n      if (bootstrapped) {\n        if (_this.props.onBeforeLift) {\n          Promise.resolve(_this.props.onBeforeLift()).then(function () {\n            return _this.setState({ bootstrapped: true });\n          }).catch(function () {\n            return _this.setState({ bootstrapped: true });\n          });\n        } else {\n          _this.setState({ bootstrapped: true });\n        }\n        _this._unsubscribe && _this._unsubscribe();\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(PersistGate, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this._unsubscribe = this.props.persistor.subscribe(this.handlePersistorState);\n      this.handlePersistorState();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this._unsubscribe && this._unsubscribe();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof this.props.children === 'function' && this.props.loading) console.error('redux-persist: PersistGate expects either a function child or loading prop, but not both. The loading prop will be ignored.');\n      }\n      if (typeof this.props.children === 'function') {\n        return this.props.children(this.state.bootstrapped);\n      }\n\n      return this.state.bootstrapped ? this.props.children : this.props.loading;\n    }\n  }]);\n\n  return PersistGate;\n}(PureComponent);\nPersistGate.defaultProps = {\n  loading: null\n};","export var KEY_PREFIX = 'persist:';\nexport var FLUSH = 'persist/FLUSH';\nexport var REHYDRATE = 'persist/REHYDRATE';\nexport var PAUSE = 'persist/PAUSE';\nexport var PERSIST = 'persist/PERSIST';\nexport var PURGE = 'persist/PURGE';\nexport var REGISTER = 'persist/REGISTER';\nexport var DEFAULT_VERSION = -1;","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexport default function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {\n  var debug = _ref.debug;\n\n  var newState = _extends({}, reducedState);\n  // only rehydrate if inboundState exists and is an object\n  if (inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') {\n    Object.keys(inboundState).forEach(function (key) {\n      // ignore _persist data\n      if (key === '_persist') return;\n      // if reducer modifies substate, skip auto rehydration\n      if (originalState[key] !== reducedState[key]) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\n        return;\n      }\n      // otherwise hard set the new value\n      newState[key] = inboundState[key];\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production' && debug && inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') console.log('redux-persist/stateReconciler: rehydrated keys \\'' + Object.keys(inboundState).join(', ') + '\\'');\n\n  return newState;\n}\n\n/*\n  autoMergeLevel1: \n    - merges 1 level of substate\n    - skips substate if already modified\n*/","import { KEY_PREFIX, REHYDRATE } from './constants';\n\n// @TODO remove once flow < 0.63 support is no longer required.\n\nexport default function createPersistoid(config) {\n  // defaults\n  var blacklist = config.blacklist || null;\n  var whitelist = config.whitelist || null;\n  var transforms = config.transforms || [];\n  var throttle = config.throttle || 0;\n  var storageKey = '' + (config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX) + config.key;\n  var storage = config.storage;\n  var serialize = config.serialize === false ? function (x) {\n    return x;\n  } : defaultSerialize;\n\n  // initialize stateful values\n  var lastState = {};\n  var stagedState = {};\n  var keysToProcess = [];\n  var timeIterator = null;\n  var writePromise = null;\n\n  var update = function update(state) {\n    // add any changed keys to the queue\n    Object.keys(state).forEach(function (key) {\n      if (!passWhitelistBlacklist(key)) return; // is keyspace ignored? noop\n      if (lastState[key] === state[key]) return; // value unchanged? noop\n      if (keysToProcess.indexOf(key) !== -1) return; // is key already queued? noop\n      keysToProcess.push(key); // add key to queue\n    });\n\n    //if any key is missing in the new state which was present in the lastState,\n    //add it for processing too\n    Object.keys(lastState).forEach(function (key) {\n      if (state[key] === undefined) {\n        keysToProcess.push(key);\n      }\n    });\n\n    // start the time iterator if not running (read: throttle)\n    if (timeIterator === null) {\n      timeIterator = setInterval(processNextKey, throttle);\n    }\n\n    lastState = state;\n  };\n\n  function processNextKey() {\n    if (keysToProcess.length === 0) {\n      if (timeIterator) clearInterval(timeIterator);\n      timeIterator = null;\n      return;\n    }\n\n    var key = keysToProcess.shift();\n    var endState = transforms.reduce(function (subState, transformer) {\n      return transformer.in(subState, key, lastState);\n    }, lastState[key]);\n\n    if (endState !== undefined) {\n      try {\n        stagedState[key] = serialize(endState);\n      } catch (err) {\n        console.error('redux-persist/createPersistoid: error serializing state', err);\n      }\n    } else {\n      //if the endState is undefined, no need to persist the existing serialized content\n      delete stagedState[key];\n    }\n\n    if (keysToProcess.length === 0) {\n      writeStagedState();\n    }\n  }\n\n  function writeStagedState() {\n    // cleanup any removed keys just before write.\n    Object.keys(stagedState).forEach(function (key) {\n      if (lastState[key] === undefined) {\n        delete stagedState[key];\n      }\n    });\n\n    writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);\n  }\n\n  function passWhitelistBlacklist(key) {\n    if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist') return false;\n    if (blacklist && blacklist.indexOf(key) !== -1) return false;\n    return true;\n  }\n\n  function onWriteFail(err) {\n    // @TODO add fail handlers (typically storage full)\n    if (err && process.env.NODE_ENV !== 'production') {\n      console.error('Error storing data', err);\n    }\n  }\n\n  var flush = function flush() {\n    while (keysToProcess.length !== 0) {\n      processNextKey();\n    }\n    return writePromise || Promise.resolve();\n  };\n\n  // return `persistoid`\n  return {\n    update: update,\n    flush: flush\n  };\n}\n\n// @NOTE in the future this may be exposed via config\nfunction defaultSerialize(data) {\n  return JSON.stringify(data);\n}","\n\nimport { KEY_PREFIX } from './constants';\n\nexport default function getStoredState(config) {\n  var transforms = config.transforms || [];\n  var storageKey = '' + (config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX) + config.key;\n  var storage = config.storage;\n  var debug = config.debug;\n  var deserialize = config.serialize === false ? function (x) {\n    return x;\n  } : defaultDeserialize;\n  return storage.getItem(storageKey).then(function (serialized) {\n    if (!serialized) return undefined;else {\n      try {\n        var state = {};\n        var rawState = deserialize(serialized);\n        Object.keys(rawState).forEach(function (key) {\n          state[key] = transforms.reduceRight(function (subState, transformer) {\n            return transformer.out(subState, key, rawState);\n          }, deserialize(rawState[key]));\n        });\n        return state;\n      } catch (err) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/getStoredState: Error restoring data ' + serialized, err);\n        throw err;\n      }\n    }\n  });\n}\n\nfunction defaultDeserialize(serial) {\n  return JSON.parse(serial);\n}","\n\nimport { KEY_PREFIX } from './constants';\n\nexport default function purgeStoredState(config) {\n  var storage = config.storage;\n  var storageKey = '' + (config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX) + config.key;\n  return storage.removeItem(storageKey, warnIfRemoveError);\n}\n\nfunction warnIfRemoveError(err) {\n  if (err && process.env.NODE_ENV !== 'production') {\n    console.error('redux-persist/purgeStoredState: Error purging data stored state', err);\n  }\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nimport { FLUSH, PAUSE, PERSIST, PURGE, REHYDRATE, DEFAULT_VERSION } from './constants';\n\nimport autoMergeLevel1 from './stateReconciler/autoMergeLevel1';\nimport createPersistoid from './createPersistoid';\nimport defaultGetStoredState from './getStoredState';\nimport purgeStoredState from './purgeStoredState';\n\nvar DEFAULT_TIMEOUT = 5000;\n/*\n  @TODO add validation / handling for:\n  - persisting a reducer which has nested _persist\n  - handling actions that fire before reydrate is called\n*/\nexport default function persistReducer(config, baseReducer) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!config) throw new Error('config is required for persistReducer');\n    if (!config.key) throw new Error('key is required in persistor config');\n    if (!config.storage) throw new Error(\"redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`\");\n  }\n\n  var version = config.version !== undefined ? config.version : DEFAULT_VERSION;\n  var debug = config.debug || false;\n  var stateReconciler = config.stateReconciler === undefined ? autoMergeLevel1 : config.stateReconciler;\n  var getStoredState = config.getStoredState || defaultGetStoredState;\n  var timeout = config.timeout !== undefined ? config.timeout : DEFAULT_TIMEOUT;\n  var _persistoid = null;\n  var _purge = false;\n  var _paused = true;\n  var conditionalUpdate = function conditionalUpdate(state) {\n    // update the persistoid only if we are rehydrated and not paused\n    state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);\n    return state;\n  };\n\n  return function (state, action) {\n    var _ref = state || {},\n        _persist = _ref._persist,\n        rest = _objectWithoutProperties(_ref, ['_persist']);\n\n    var restState = rest;\n\n    if (action.type === PERSIST) {\n      var _sealed = false;\n      var _rehydrate = function _rehydrate(payload, err) {\n        // dev warning if we are already sealed\n        if (process.env.NODE_ENV !== 'production' && _sealed) console.error('redux-persist: rehydrate for \"' + config.key + '\" called after timeout.', payload, err);\n\n        // only rehydrate if we are not already sealed\n        if (!_sealed) {\n          action.rehydrate(config.key, payload, err);\n          _sealed = true;\n        }\n      };\n      timeout && setTimeout(function () {\n        !_sealed && _rehydrate(undefined, new Error('redux-persist: persist timed out for persist key \"' + config.key + '\"'));\n      }, timeout);\n\n      // @NOTE PERSIST resumes if paused.\n      _paused = false;\n\n      // @NOTE only ever create persistoid once, ensure we call it at least once, even if _persist has already been set\n      if (!_persistoid) _persistoid = createPersistoid(config);\n\n      // @NOTE PERSIST can be called multiple times, noop after the first\n      if (_persist) return state;\n      if (typeof action.rehydrate !== 'function' || typeof action.register !== 'function') throw new Error('redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.');\n\n      action.register(config.key);\n\n      getStoredState(config).then(function (restoredState) {\n        var migrate = config.migrate || function (s, v) {\n          return Promise.resolve(s);\n        };\n        migrate(restoredState, version).then(function (migratedState) {\n          _rehydrate(migratedState);\n        }, function (migrateErr) {\n          if (process.env.NODE_ENV !== 'production' && migrateErr) console.error('redux-persist: migration error', migrateErr);\n          _rehydrate(undefined, migrateErr);\n        });\n      }, function (err) {\n        _rehydrate(undefined, err);\n      });\n\n      return _extends({}, baseReducer(restState, action), {\n        _persist: { version: version, rehydrated: false }\n      });\n    } else if (action.type === PURGE) {\n      _purge = true;\n      action.result(purgeStoredState(config));\n      return _extends({}, baseReducer(restState, action), {\n        _persist: _persist\n      });\n    } else if (action.type === FLUSH) {\n      action.result(_persistoid && _persistoid.flush());\n      return _extends({}, baseReducer(restState, action), {\n        _persist: _persist\n      });\n    } else if (action.type === PAUSE) {\n      _paused = true;\n    } else if (action.type === REHYDRATE) {\n      // noop on restState if purging\n      if (_purge) return _extends({}, restState, {\n        _persist: _extends({}, _persist, { rehydrated: true })\n\n        // @NOTE if key does not match, will continue to default else below\n      });if (action.key === config.key) {\n        var reducedState = baseReducer(restState, action);\n        var inboundState = action.payload;\n        // only reconcile state if stateReconciler and inboundState are both defined\n        var reconciledRest = stateReconciler !== false && inboundState !== undefined ? stateReconciler(inboundState, state, reducedState, config) : reducedState;\n\n        var _newState = _extends({}, reconciledRest, {\n          _persist: _extends({}, _persist, { rehydrated: true })\n        });\n        return conditionalUpdate(_newState);\n      }\n    }\n\n    // if we have not already handled PERSIST, straight passthrough\n    if (!_persist) return baseReducer(state, action);\n\n    // run base reducer:\n    // is state modified ? return original : return updated\n    var newState = baseReducer(restState, action);\n    if (newState === restState) return state;else {\n      newState._persist = _persist;\n      return conditionalUpdate(newState);\n    }\n  };\n}","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexport default function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {\n  var debug = _ref.debug;\n\n  var newState = _extends({}, reducedState);\n  // only rehydrate if inboundState exists and is an object\n  if (inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') {\n    Object.keys(inboundState).forEach(function (key) {\n      // ignore _persist data\n      if (key === '_persist') return;\n      // if reducer modifies substate, skip auto rehydration\n      if (originalState[key] !== reducedState[key]) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\n        return;\n      }\n      if (isPlainEnoughObject(reducedState[key])) {\n        // if object is plain enough shallow merge the new values (hence \"Level2\")\n        newState[key] = _extends({}, newState[key], inboundState[key]);\n        return;\n      }\n      // otherwise hard set\n      newState[key] = inboundState[key];\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production' && debug && inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') console.log('redux-persist/stateReconciler: rehydrated keys \\'' + Object.keys(inboundState).join(', ') + '\\'');\n\n  return newState;\n}\n\n/*\n  autoMergeLevel2: \n    - merges 2 level of substate\n    - skips substate if already modified\n    - this is essentially redux-perist v4 behavior\n*/\n\nfunction isPlainEnoughObject(o) {\n  return o !== null && !Array.isArray(o) && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object';\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport { createStore } from 'redux';\n\nimport persistReducer from './persistReducer';\nimport { FLUSH, PAUSE, PERSIST, PURGE, REGISTER, REHYDRATE } from './constants';\n\nvar initialState = {\n  registry: [],\n  bootstrapped: false\n};\n\nvar persistorReducer = function persistorReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments[1];\n\n  switch (action.type) {\n    case REGISTER:\n      return _extends({}, state, { registry: [].concat(_toConsumableArray(state.registry), [action.key]) });\n    case REHYDRATE:\n      var firstIndex = state.registry.indexOf(action.key);\n      var registry = [].concat(_toConsumableArray(state.registry));\n      registry.splice(firstIndex, 1);\n      return _extends({}, state, { registry: registry, bootstrapped: registry.length === 0 });\n    default:\n      return state;\n  }\n};\n\nexport default function persistStore(store, options, cb) {\n  // help catch incorrect usage of passing PersistConfig in as PersistorOptions\n  if (process.env.NODE_ENV !== 'production') {\n    var optionsToTest = options || {};\n    var bannedKeys = ['blacklist', 'whitelist', 'transforms', 'storage', 'keyPrefix', 'migrate'];\n    bannedKeys.forEach(function (k) {\n      if (!!optionsToTest[k]) console.error('redux-persist: invalid option passed to persistStore: \"' + k + '\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.');\n    });\n  }\n  var boostrappedCb = cb || false;\n\n  var _pStore = createStore(persistorReducer, initialState, options ? options.enhancer : undefined);\n  var register = function register(key) {\n    _pStore.dispatch({\n      type: REGISTER,\n      key: key\n    });\n  };\n\n  var rehydrate = function rehydrate(key, payload, err) {\n    var rehydrateAction = {\n      type: REHYDRATE,\n      payload: payload,\n      err: err,\n      key: key\n      // dispatch to `store` to rehydrate and `persistor` to track result\n    };store.dispatch(rehydrateAction);\n    _pStore.dispatch(rehydrateAction);\n    if (boostrappedCb && persistor.getState().bootstrapped) {\n      boostrappedCb();\n      boostrappedCb = false;\n    }\n  };\n\n  var persistor = _extends({}, _pStore, {\n    purge: function purge() {\n      var results = [];\n      store.dispatch({\n        type: PURGE,\n        result: function result(purgeResult) {\n          results.push(purgeResult);\n        }\n      });\n      return Promise.all(results);\n    },\n    flush: function flush() {\n      var results = [];\n      store.dispatch({\n        type: FLUSH,\n        result: function result(flushResult) {\n          results.push(flushResult);\n        }\n      });\n      return Promise.all(results);\n    },\n    pause: function pause() {\n      store.dispatch({\n        type: PAUSE\n      });\n    },\n    persist: function persist() {\n      store.dispatch({ type: PERSIST, register: register, rehydrate: rehydrate });\n    }\n  });\n\n  persistor.persist();\n\n  return persistor;\n}","export { default as persistReducer } from './persistReducer';\nexport { default as persistCombineReducers } from './persistCombineReducers';\nexport { default as persistStore } from './persistStore';\nexport { default as createMigrate } from './createMigrate';\nexport { default as createTransform } from './createTransform';\nexport { default as getStoredState } from './getStoredState';\nexport { default as createPersistoid } from './createPersistoid';\nexport { default as purgeStoredState } from './purgeStoredState';\n\nexport * from './constants';"],"sourceRoot":""}